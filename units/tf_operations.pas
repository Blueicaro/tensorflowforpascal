unit tf_operations;

//**********************************************************************************************************************************
//
//  Pascal methods to create and manage TensorFlow based Operations
//
//  Copyright: (C) 2020, Zsolt Szakaly
//
//  This source is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
//  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
//
//  This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  A copy of the GNU General Public License is available on the World Wide Web at <http://www.gnu.org/copyleft/gpl.html>. You can
//  also obtain it by writing to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1335, USA.
//
//  Change log:
//    13/02/2020 Initial version
//    15/02/2020 TGraph.GetOperationByName added
//               TGraph.AddOper return value change to string, giving back the name of the operation if successful, or '' if not.
//               TGraph.AddConstant added for string type
//               TSession.Run longer version added to run graphs by Operation name as well
//
//**********************************************************************************************************************************
//
//  Description
//
//  The unit has two parts
//    Graph based operations
//    Direct calls (Eager approach)
//
//  Using the Graph approach (TGraph object), you can easily create a TensorFlow Graph and add Nodes or Operations to it. The
//  Generic method is called AddOper. There are some typical, operation independent nodes, often added to a Graph. To make it easier
//  some convenience functions are also implemented to add constants, inputs, variables and tensors. All "real" operations can be
//  added with AddOper, or you can use tf_wrapper, generated by WrapperMaker automatically from the TensorFlow operation description
//  file. For operation specific methods see the tf_wrapper separately.
//
//  For Eager execution (when no Graph is built, but operations are executed on Tensors immediately), there is ExecOper in this
//  file. ExecOper has two versions, one simplified for those operations that has only Inputs, but NO InputLists, and that has
//  ONE output, and no OutputList. For all more complex operations the longer version of ExecOper can be used. Most of the time, you
//  will not want to use ExecOper, but use operation specific Exec<oper> functions that are in tf_wrapper. One additional feature of
//  ExecOper (and all the Exec<oper> functions as well), that Input Tensors can be deleted immediately at the end of the execution
//  of the operation. This can not only save one extra line in your code (TF_DeleteTensor()), but also allows to create input
//  Tensors in the call itself without risking memory leak. See examples.pas for some more details.
//
//  Many of the TensorFlow operations were tested and OK, but there is no guarantee that complex operations, especially with
//  list() type attributes is working correctly. Be careful!
//
//**********************************************************************************************************************************

interface

uses
  ctypes,                              // Used for typecasts
  SysUtils,                            // Needed for string conversions
  tf_api,                              // The c_api.h interface
  tf_tensors;                          // Basic Tensor handling

// Some extra type definitions on top of what tf_api has
type
  TF_OperOutput=record // A record to identify an Operation Output in the Graph by a name (normally only operations have name)
    FName:string;
    FOutput:TF_Output;
    end;
  TF_OperOutputs=array of TF_OperOutput; // The type to store all the OperOutputs of a Graph

//**********************************************************************************************************************************
//    Graph based operations
//**********************************************************************************************************************************

type
  TGraph=object                // The main Graph Object, including a TF Graph, a TF Status and an Outputs array for easier reference
    private                    // Fields to access through methods
      FGraph:TF_GraphPtr;
      FStatus:TF_StatusPtr;
      FOperOutputs:TF_OperOutputs;
    public                     // The constructor and destructor
      constructor Init;
      destructor  Done; virtual;
    public                     // The generic function to add an Operation to the Graph
      function AddOper(const AOperationType:string;
                       const AInputs:array of string; const AInputLists:array of string; const AInputListLengths:array of UInt64;
                       const AOutputs:array of string;
                       const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                       const AOperationName:string=''):
        string;
    public                     // Functions to find Output or OutputList based on its name
      function GetOutputByName(const AName:string):TF_Output;
      function GetOutputListByName(const AName:string):TF_OutputPtr;
      function GetOperationByName(const AName:string):TF_OperationPtr;
    public                     // Convenience functions to add Constants, Inputs, Tensors and Variables to a Graph
      function AddConstant(const AName:string;const AValue; ADataType:TF_DataType):string;
      function AddConstant(const AName:string; AValue:Int8):string;
      function AddConstant(const AName:string; AValue:Int16):string;
      function AddConstant(const AName:string; AValue:Int32):string;
      function AddConstant(const AName:string; AValue:Int64):string;
      function AddConstant(const AName:string;AValue:UInt8):string;
      function AddConstant(const AName:string;AValue:UInt16):string;
      function AddConstant(const AName:string;AValue:UInt32):string;
      function AddConstant(const AName:string;AValue:UInt64):string;
      function AddConstant(const AName:string; AValue:Single):string;
      function AddConstant(const AName:string; AValue:String):string;
      function AddInput(const AName:string;  ADataType:TF_DataType):string;
      function AddTensor(const AName:string; const ATensor:TF_TensorPtr; ADeleteTensor:boolean=false):string;
      function AddVariable(const AName:string; const AShape:TF_ShapePtr; AType:TF_AttrType):string;
    end;

type
  TSession=object
    private
      FSession:TF_SessionPtr;
      FGraph:TGraph;
      FStatus:TF_StatusPtr;
    public
      constructor Init(const AGraph:TGraph);
      destructor Done; virtual;
      function Run(const AInputs:array of string;const AInputValues:array of TF_TensorPtr;
                   const AOutputs:array of string):TF_TensorPtrs;
      function Run(const AInputs:array of string;const AInputValues:array of TF_TensorPtr;
                   const AOutputs:array of string; const AOperations:array of string):TF_TensorPtrs;
    end;

// *********************************************************************************************************************************
// THE EAGER OPERATION
// *********************************************************************************************************************************

function ExecOper(const AOperationType:string;
                  const AInputTs:array of TF_TensorPtr; const AInputLs:array of TF_TensorPtrs; const AInputLLengths:array of UInt64;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer):
                  TF_TensorPtrs;
function ExecOper(const AOperationType:string;
                  const AInputTs:array of TF_TensorPtr;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                  const ADeletes:array of boolean):TF_TensorPtr;


implementation

// *********************************************************************************************************************************
// THE GRAPH OPERATIONS
// *********************************************************************************************************************************

constructor TGraph.Init;
  begin
  FGraph:=TF_NewGraph;
  FStatus:=TF_NewStatus;
  SetLength(FOperOutputs,0);
  end;
destructor TGraph.Done;
  begin
  SetLength(FOperOutputs,0);
  TF_DeleteStatus(FStatus);
  TF_DeleteGraph(FGraph);
  end;
function TGraph.AddOper(const AOperationType:string;
                        const AInputs:array of string; const AInputLists:array of string; const AInputListLengths:array of UInt64;
                        const AOutputs: array of string;
                        const AAttrNames: array of string; const AAttrTypes: array of string; const AAttrValues: array of pointer;
                        const AOperationName:string=''):string;
  var
    OperationDescription:      TF_OperationDescriptionPtr;
    OperationType:             string;
    OperationName:             string;
    AttrName:                  string;
    AttrDims:                  array of cint;
    OffSet:                    Int32;
    Index:                     integer;
    i:                         integer;
    Operation:                 TF_OperationPtr;
    OK:boolean;
  begin
  OK:=true;
  OffSet:=Length(FOperOutputs);
  SetLength(FOperOutputs,OffSet+Length(AOutputs));
  OperationType:=AOperationType+#0; // depending on the compiler, string can be null-terminated or not. To be safe, a #0 is added
  if AOperationName<>'' then
    OperationName:=AOperationName+#0
  else
    OperationName:=AOperationType+IntToStr(OffSet)+#0;
  OperationDescription:=TF_NewOperation(FGraph, @OperationType[1], @OperationName[1]);
  for Index:=0 to length(AInputs)-1 do
    TF_AddInput(OperationDescription,GetOutputByName(AInputs[Index]));
  for Index:=0 to Length(AInputLists)-1 do
    TF_AddInputList(OperationDescription,GetOutputListByName(AInputLists[Index]),AInputListLengths[Index]);
  for Index:=0 to Length(AAttrNames)-1 do
    begin
    AttrName:=AAttrNames[Index]+#0;
    if AAttrTypes[Index]='bool' then
      begin
      TF_SetAttrBool(OperationDescription,@AttrName[1],char(AAttrValues[Index]^));
      end
    else if AAttrTypes[Index]='float' then
      begin
      TF_SetAttrFloat(OperationDescription,@AttrName[1],cfloat(AAttrValues[Index]^));
      end
    else if AAttrTypes[Index]='func' then
      begin
      TF_SetAttrFuncname(OperationDescription,@AttrName[1],charptr(@string(AAttrValues[Index]^)[1]),length(string(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='int' then
      begin
      TF_SetAttrInt(OperationDescription,@AttrName[1],cint64(AAttrValues[Index]^));
      end
    else if AAttrTypes[Index]='list(float)' then
      begin
      TF_SetAttrFloatList(OperationDescription,@AttrName[1],cfloatptr(@TF_FloatList(AAttrValues[Index]^)[0]),Length(TF_FloatList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='list(func)' then { TODO : There is no dedicated TF_SetAttFuncnameList. Is it OK like this? }
      begin
      TF_SetAttrFuncname(OperationDescription,@AttrName[1],charptr(@TF_FuncnameList(AAttrValues[Index]^)[0]),Length(TF_FuncnameList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='list(int)' then
      begin
      TF_SetAttrIntList(OperationDescription,@AttrName[1],cint64ptr(@TF_IntList(AAttrValues[Index]^)[0]),Length(TF_IntList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='list(shape)' then
      begin
      SetLength(AttrDims,Length(TF_ShapeList(AAttrValues[Index]^)));
      for i:=0 to Length(AttrDims)-1 do
        AttrDims[i]:=Length(TF_ShapeList(AAttrValues[Index]^)[i]);
      TF_SetAttrShapeList(OperationDescription,@AttrName[1],cint64ptrptr(@TF_ShapeList(AAttrValues[Index]^)[0]),
                        cintptr(@AttrDims[0]),Length(TF_ShapeList(AAttrValues[Index]^)));
      SetLength(AttrDims,0);
      end
    else if AAttrTypes[Index]='list(string)' then
      begin
      SetLength(AttrDims,Length(TF_StringList(AAttrValues[Index]^)));
      for i:=0 to Length(AttrDims)-1 do
        AttrDims[i]:=Length(TF_StringList(AAttrValues[Index]^)[i]);
      TF_SetAttrStringList(OperationDescription,@AttrName[1],pointerptr(@TF_StringList(AAttrValues[Index]^)[0]),
                           csize_tptr(@AttrDims[0]),Length(TF_StringList(AAttrValues[Index]^)));
      SetLength(AttrDims,0);
      end
    else if AAttrTypes[Index]='list(type)' then
      begin
      TF_SetAttrTypeList(OperationDescription,@AttrName[1],TF_DataTypePtr(@TF_TypeList(AAttrValues[Index]^)[0]),Length(TF_TypeList(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='shape' then
      begin
      TF_SetAttrShape(OperationDescription,@AttrName[1],cint64ptr(@(TF_ShapePtr(AAttrValues[Index])^[0])),Length(TF_ShapePtr(AAttrValues[Index])^));
      end
    else if AAttrTypes[Index]='string' then
      begin
      TF_SetAttrString(OperationDescription,@AttrName[1],pointer(@(string(AAttrValues[Index]^)[1])),Length(string(AAttrValues[Index]^)));
      end
    else if AAttrTypes[Index]='tensor' then
      begin
      TF_SetAttrTensor(OperationDescription,@AttrName[1],TF_TensorPtr(AAttrValues[Index]^),FStatus);
      OK:=OK and TF_CheckStatus(FStatus);
      end
    else if AAttrTypes[Index]='type' then
      begin
      TF_SetAttrType(OperationDescription,@AttrName[1],TF_DataType(AAttrValues[Index]^));
      end
    else writeln('Unknown parameter type '+AAttrTypes[Index]);
    end;
  Operation:=TF_FinishOperation(OperationDescription,FStatus);
  OK:=OK and TF_CheckStatus(FStatus);
  for Index:=0 to Length(AOutputs)-1 do
    with FOperOutputs[OffSet+Index] do
      begin
      FOutput.Oper:=Operation;
      FOutput.Index:=Index;
      FName:=AOutputs[Index];
      end;
  if OK then
    result:=OperationName
  else
    result:='';
  end;
function TGraph.GetOutputByName(const AName:string):TF_Output;
  var i:integer;
  begin
  i:=0;
  while i<=length(FOperOutputs) do
    begin
    if FOperOutputs[i].FName=AName then
      begin
      result:=FOperOutputs[i].FOutput;
      exit;
      end;
    inc(i);
    end;
  end;
function TGraph.GetOutputListByName(const AName:string):TF_OutputPtr;
  var i:integer;
  begin
  i:=0;
  while i<=length(FOperOutputs) do
    begin
    if FOperOutputs[i].FName=AName then
      begin
      result:=@FOperOutputs[i].FOutput;
      exit;
      end;
    inc(i);
    end;
  end;
function TGraph.GetOperationByName(const AName:string):TF_OperationPtr;
  var Name:string;
  begin
  Name:=AName+#0;
  result:=TF_GraphOperationByName(FGraph,@Name[1]);
  end;

function TGraph.AddConstant(const AName:string;const AValue; ADataType:TF_DataType):string;
  var
    ConstantT:TF_TensorPtr;
  begin
  case ADataType of
    TF_INT8:ConstantT:=CreateTensorInt8(Int8(AValue));
    TF_INT16:ConstantT:=CreateTensorInt16(Int16(AValue));
    TF_INT32:ConstantT:=CreateTensorInt32(Int32(AValue));
    TF_INT64:ConstantT:=CreateTensorInt64(Int64(AValue));
    TF_UINT8:ConstantT:=CreateTensorUInt8(UInt8(AValue));
    TF_UINT16:ConstantT:=CreateTensorUInt16(UInt16(AValue));
    TF_UINT32:ConstantT:=CreateTensorUInt32(UInt32(AValue));
    TF_UINT64:ConstantT:=CreateTensorUInt64(UInt64(AValue));
    TF_FLOAT:ConstantT:=CreateTensorSingle(Single(AValue));
    TF_STRING:ConstantT:=CreateTensorString(PChar(AValue));
    else
      raise Exception.Create('Data type not implemented');
    end;
  result:=AddOper('Const',[],[],[],[AName],['dtype','value'],['type','tensor'],[@ADataType,@ConstantT]);
  TF_DeleteTensor(ConstantT);
  end;
function TGraph.AddConstant(const AName:string; AValue:Int8):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT8);
  end;
function TGraph.AddConstant(const AName:string; AValue:Int16):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT16);
  end;
function TGraph.AddConstant(const AName:string; AValue:Int32):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT32);
  end;
function TGraph.AddConstant(const AName:string; AValue:Int64):string;
  begin
  result:=AddConstant(AName,AValue,TF_INT64);
  end;
function TGraph.AddConstant(const AName:string;AValue:UInt8):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT8);
  end;
function TGraph.AddConstant(const AName:string;AValue:UInt16):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT16);
  end;
function TGraph.AddConstant(const AName:string;AValue:UInt32):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT32);
  end;
function TGraph.AddConstant(const AName:string;AValue:UInt64):string;
  begin
  result:=AddConstant(AName,AValue,TF_UINT64);
  end;
function TGraph.AddConstant(const AName:string; AValue:Single):string;
  begin
  result:=AddConstant(AName,AValue,TF_FLOAT);
  end;
function TGraph.AddConstant(const AName:string; AValue:String):string;
  begin
  result:=AddConstant(AName,AValue,TF_String);
  end;
function TGraph.AddInput(const AName:string;  ADataType:TF_DataType):string;
  begin
  result:=AddOper('Placeholder',[],[],[],[AName],['dtype'],['type'],[@ADataType]);
  end;
function TGraph.AddTensor(const AName:string; const ATensor:TF_TensorPtr; ADeleteTensor:boolean=false):string;
  var TensorType:TF_DataType;
  begin
  TensorType:=TF_TensorType(ATensor);
  result:=AddOper('Const',[],[],[],[AName],['dtype','value'],['type','tensor'],[@TensorType,ATensor]);
  if ADeleteTensor then
    TF_DeleteTensor(ATensor);
  end;
function TGraph.AddVariable(const AName:string; const AShape:TF_ShapePtr; AType:TF_AttrType):string;
  begin
  result:=AddOper('Variable',[],[],[],[AName],['dtype','shape'],['type','shape'],[@AType,@AShape]);
  end;

constructor TSession.Init(const AGraph:TGraph);
  var
    SessionOptions:TF_SessionOptionsPtr;
  begin
  FGraph:=AGraph;
  FStatus:=FGraph.FStatus;
  SessionOptions:=TF_NewSessionOptions;
  FSession:=TF_NewSession(FGraph.FGraph,SessionOptions,FStatus); // using the GGraph and the Options created earlier
  TF_CheckStatus(AGraph.FStatus);
  TF_DeleteSessionOptions(SessionOptions);
  end;
destructor TSession.Done;
  begin
  TF_CloseSession(FSession,FStatus);
  TF_CheckStatus(FStatus);
  TF_DeleteSession(FSession,FStatus);
  TF_CheckStatus(FStatus);
  end;
function TSession.Run(const AInputs:array of string;const AInputValues:array of TF_TensorPtr;
                      const AOutputs:array of string):TF_TensorPtrs;
  begin
  result:=Run(AInputs,AInputValues,AOutputs,[]);
  end;
function TSession.Run(const AInputs:array of string;const AInputValues:array of TF_TensorPtr;
                      const AOutputs:array of string; const AOperations:array of string):TF_TensorPtrs;
  var
    InputOperations:array of TF_Output;
    OutputOperations:array of TF_Output;
    ExecuteOperations:array of TF_OperationPtr;
    i:integer;
  begin
  SetLength(InputOperations,length(AInputs));
  for i:=0 to Length(AInputs)-1 do
    InputOperations[i]:=FGraph.GetOutputByName(AInputs[i]);
  SetLength(OutputOperations,length(AOutputs));
  for i:=0 to Length(AOutputs)-1 do
    OutputOperations[i]:=FGraph.GetOutputByName(AOutputs[i]);
  SetLength(result,Length(OutputOperations));
  SetLength(ExecuteOperations,length(AOperations));
  for i:=0 to Length(AOperations)-1 do
    ExecuteOperations[i]:=FGraph.GetOperationByName(AOperations[i]);
  TF_SessionRun(FSession, nil,
                @InputOperations[0],@AInputValues[0],Length(InputOperations),
                @OutputOperations[0],@result[0],Length(OutputOperations),
                @ExecuteOperations[0],Length(ExecuteOperations),
                nil, FStatus);
  TF_CheckStatus(FStatus);
  end;

// *********************************************************************************************************************************
// THE EAGER OPERATION
// *********************************************************************************************************************************

function ExecOper(const AOperationType:string;
                  const AInputTs:array of TF_TensorPtr; const AInputLs:array of TF_TensorPtrs; const AInputLLengths:array of UInt64;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer):
                  TF_TensorPtrs;
  var
    Graph:TGraph;
    Index:integer;
    InputNames:array of string;
    InputListNames:array of string;
    Session:TSession;
    InputTensors:array of TF_TensorPtr;
  begin
  Graph.Init;
  SetLength(InputNames,Length(AInputTs));
  for Index:=0 to Length(AInputTs)-1 do
    begin
    InputNames[Index]:='Input'+IntToStr(Index);
    Graph.AddInput(Inputnames[Index],TF_TensorType(AInputTs[Index]));
    end;
  SetLength(InputListNames,Length(AInputLs));
  for Index:=0 to Length(AInputLs)-1 do
    begin
    InputListNames[Index]:='InputList'+IntToStr(Index);
    Graph.AddInput(InputListNames[Index],TF_TensorType(AInputLs[Index][0])); // All tensors in a tensor list must have the same type
    end;
  Graph.AddOper(AOperationType,InputNames,InputListNames,AInputLLengths,[AOperationType],AAttrNames,AAttrTypes,AAttrValues);
  Session.Init(Graph);
  SetLength(InputNames,Length(InputNames)+Length(InputListNames));
  for Index:=0 to Length(InputListNames)-1 do
    InputNames[Length(AInputTs)+Index]:=InputListNames[Index];
  SetLength(InputListNames,0);
  SetLength(InputTensors,Length(AInputTs)+Length(AInputLs));
  for Index:=0 to Length(AInputTs)-1 do
    InputTensors[Index]:=AInputTs[Index]; // only a pointer copy, no need to free at the end
  for Index:=0 to Length(AInputLs)-1 do
    InputTensors[Length(AInputTs)+Index]:=AInputLs[Index][0];

  result:=Session.Run(InputNames,InputTensors,[AOperationType]);
  Session.Done;
  Graph.Done;
  end;
function ExecOper(const AOperationType:string;
                  const AInputTs:array of TF_TensorPtr;
                  const AAttrNames:array of string; const AAttrTypes:array of string; const AAttrValues:array of pointer;
                  const ADeletes:array of boolean):TF_TensorPtr;
  var
    ResultPtrs:TF_TensorPtrs;
    Index:Integer;
  begin
  ResultPtrs:=ExecOper(AOperationType,AInputTs,[],[],AAttrNames,AAttrTypes,AAttrValues);
  result:=ResultPtrs[0]; // only give back the first result as a Tensor (most of the time OK, otherwise use the longer version)
  for Index:=1 to Length(ResultPtrs)-1 do
    TF_DeleteTensor(ResultPtrs[Index]);
  for Index:=0 to Length(ADeletes)-1 do // No check, need to make sure that Length(ADeletes)<=Length(AInputTs)
    if ADeletes[Index] then
      TF_DeleteTensor(AInputTs[Index]);
  end;

end.

