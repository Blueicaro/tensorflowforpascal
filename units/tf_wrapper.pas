unit tf_wrapper;

//**********************************************************************************************************************************
//
//  Pascal methods to create and manage TensorFlow based Operations in a Specific manner
//
//  Copyright: (C) 2020, Zsolt Szakaly
//
//  This source is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
//  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
//
//  This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  A copy of the GNU General Public License is available on the World Wide Web at <http://www.gnu.org/copyleft/gpl.html>. You can
//  also obtain it by writing to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1335, USA.
//
//  Change log:
//    11/02/2020 Initial version
//    15/02/2020 ctypes add to uses
//
//**********************************************************************************************************************************
//
//  Description
//
//  This wrapper file includes a TGraphExt object, built on the TGraph object defined in tf_operations. This extension of the
//  TGraph adds operation specific Add<oper> methods. Using them is functionally the same as using the original AddOper function.
//  There are some benefits though. Already at the time typing the Add<oper>( the editor (if you use an IDE, like Lazarus) will
//  bring up the parameter list, so you can see what inputs and parameters are needed for a given operation. This can simplify
//  the programming work. On the other hand, it must be mentioned that certain TensorFlow operations have default attributes. E.g.
//  MatMul (matrix multiplication) have two attributes (transpose_a and transpose_b) indicating whether the input matrix/matrices
//  need to be transposed before the operation or not. The default value for both, is false. If you use AddOper, you can safely skip
//  these attributes if you do not want to transpose your matrices. In the Specific calls (e.g. AddMatMul), included in this file
//  all attributes of the given operation must be specified. There were considerations to avoid this, but none of the options is
//  practical to implement. The "elegant" way of having "transpose:boolean=false" instead of just having "transpose:boolean" in the
//  declaration could be done. The problem with this approach is that there are operations that use a Tensor as an attribute and it
//  even has a default, but it is not possible to use something like "const Attr:TF_Tensor=CreateTensor". For the majority of
//  attributes with default however this approach could work, but in this case the default value would already be in tf_wrapper and
//  if TensorFlow changes it in the library, the wrapper would still call it with the old default. This was not a desired outcome.
//  Another approach could be to have different versions of the definition. In case of the above mentioned MatMul, there could be
//  three different versions, one with no transpose atribute, one with one transpose atribute and one with two transpose attributes.
//  The problem that in case of one, it can only be either the first or the second, but there is no way do define versions depending
//  which one you want to give. For more complicated operations with more attributes the number of combinations increases rapidly,
//  especially when the attributes have different types. So, again this was not a desired outcome. The third way is even uglier.
//  There could be functions with different names, depending which attribute is specified and which is not. This would make the use
//  probably even more complicated, e.g. having AddMatMul, AddMatMulTransposea, AddMatMulTransposeb, AddMatMulTransposeaTransposeb.
//  Oddly enough in this case the name could already indicate even the value of the attribute (using the one with Transposea
//  probably means that you want to transpose a, so it is not needed as an attribute. For more comlex operations the number of such
//  name combinations would be 2^n, what is again not a desired outcome. This is why the Add<oper> functions include all the
//  attributes, regardless if they have default value or not.
//  It is possible, that later the WrapperMaker will be improved in a way, that at least for the easy cases some simplification is
//  added, but it is not a priority. If for whatever reason you cannot specify the attribute and you want to use the TensorFlow
//  default value, you can still use the base AddOper function. AddOper and the different Add<oper> functions can be used together,
//  so if only for one operation you have this problem with, you can still use TGraphExt and use the different Add<oper> functions.
//
//
//  This wrapper file includes operation specific Exec<oper> functions. These functions are built on the Generic ExecOper function
//  defined in tf_operations. Exec<oper> functions are only generated for operations that have only ONE Output and no InputList or
//  OutputList parameters. In the background the Specific Exec<oper> functions call the short version of the  ExecOper function.
//  The benefit of using Exec<oper> is that it lists what parameters are required to call the given operation, let it be Inputs or
//  Attributes. If you use an IDE, already at typing Exec<oper>(, you can see the parameter list, do not need to look it up in the
//  specification. Also, if an Attribute can be retrieved from the Input Tensor (typically the data type of it, often called "T"),
//  then it is automatically done, you do not need to input it.
//  As described in the Description of the TGraphExt.Add<oper> (if this tf_wrapper was generated without generating TGraphExt, then
//  you can find this description in the tf_wrappertemplate file) there is a difference between how ExecOper and Exec<oper> handle
//  the TensorFlow default attributes. In ExecOper you can skip those attributes that have a default value and you are happy with
//  it. In the Exec<oper> functions you have to explicitely give all attributes of the given operations. The reasons can be found in
//  the mentioned TGraphExt description. Similarly to TGraphExt this is currently a low priority to improve on this. It is not a bad
//  programming practice anyway to specify these parameters explicitely, but if you want to avoid it, just use the base ExecOper.
//  Just like, in case of ExecOper, all Exec<oper> functions have optional boolean parameters (starting with D_) to delete the input
//  Tensors at the end of the Operation. This is to make memory management much easier and allow in-line TensorCreate when calling
//  ExecOper or one of the Exec<oper> functions, without creating a memory leak.
//
//**********************************************************************************************************************************


interface

uses
  ctypes,
  SysUtils,
  tf_api,
  tf_operations;


// The new TGraphExt object based on the TGraph, specified in tf_operations
type
  TGraphExt=object(TGraph)
    function AddAbort(const A_error_msg:string; const A_exit_without_error:boolean):string;
    function AddAbs(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAccumulateNV2(const IL_inputs:string; const O_sum:string; const A_N:cint64; const A_T:TF_DataType; const A_shape:TF_Shape):string;
    function AddAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient:string; const A_dtype:TF_DataType):string;
    function AddAccumulatorNumAccumulated(const I_handle:string; const O_num_accumulated:string):string;
    function AddAccumulatorSetGlobalStep(const I_handle:string; const I_new_global_step:string):string;
    function AddAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_average:string; const A_dtype:TF_DataType):string;
    function AddAcos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAcosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAdd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddAddManySparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handles:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddAddN(const IL_inputs:string; const O_sum:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddAddSparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handle:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddAddV2(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddAdjustContrast(const I_images:string; const I_contrast_factor:string; const I_min_value:string; const I_max_value:string; const O_output:string; const A_T:TF_DataType):string;
    function AddAdjustContrastv2(const I_images:string; const I_contrast_factor:string; const O_output:string; const A_T:TF_DataType):string;
    function AddAdjustHue(const I_images:string; const I_delta:string; const O_output:string; const A_T:TF_DataType):string;
    function AddAdjustSaturation(const I_images:string; const I_scale:string; const O_output:string; const A_T:TF_DataType):string;
    function AddAll(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
    function AddAllCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_seed:cint64; const A_seed2:cint64):string;
    function AddAllToAll(const I_input:string; const I_group_assignment:string; const O_output:string; const A_T:TF_DataType; const A_concat_dimension:cint64; const A_split_dimension:cint64; const A_split_count:cint64):string;
    function AddAngle(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddAnonymousIterator(const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddAnonymousIteratorV2(const O_handle:string; const O_deleter:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddAnonymousMemoryCache(const O_handle:string; const O_deleter:string):string;
    function AddAnonymousMultiDeviceIterator(const O_handle:string; const O_deleter:string; const A_devices:TF_StringList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddAnonymousRandomSeedGenerator(const I_seed:string; const I_seed2:string; const O_handle:string; const O_deleter:string):string;
    function AddAny(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
    function AddApplyAdaMax(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddApplyAddSign(const I_var:string; const I_m:string; const I_lr:string; const I_alpha:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddApplyPowerSign(const I_var:string; const I_m:string; const I_lr:string; const I_logbase:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddApproximateEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_tolerance:real):string;
    function AddArgMax(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
    function AddArgMin(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
    function AddAsString(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_precision:cint64; const A_scientific:boolean; const A_shortest:boolean; const A_width:cint64; const A_fill:string):string;
    function AddAsin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAsinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAssert(const I_condition:string; const IL_data:string; const A_T:TF_TypeList; const A_summarize:cint64):string;
    function AddAssertNextDataset(const I_input_dataset:string; const I_transformations:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddAssign(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_validate_shape:boolean; const A_use_locking:boolean):string;
    function AddAssignAdd(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddAssignAddVariableOp(const I_resource:string; const I_value:string; const A_dtype:TF_DataType):string;
    function AddAssignSub(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddAssignSubVariableOp(const I_resource:string; const I_value:string; const A_dtype:TF_DataType):string;
    function AddAssignVariableOp(const I_resource:string; const I_value:string; const A_dtype:TF_DataType):string;
    function AddAtan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAtan2(const I_y:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddAtanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddAudioSpectrogram(const I_input:string; const O_spectrogram:string; const A_window_size:cint64; const A_stride:cint64; const A_magnitude_squared:boolean):string;
    function AddAudioSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_sample_rate:real; const A_max_outputs:cint64):string;
    function AddAudioSummaryV2(const I_tag:string; const I_tensor:string; const I_sample_rate:string; const O_summary:string; const A_max_outputs:cint64):string;
    function AddAutoShardDataset(const I_input_dataset:string; const I_num_workers:string; const I_index:string; const O_handle:string; const A_auto_shard_policy:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddAvgPool(const I_value:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddAvgPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddAvgPool3DGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddAvgPoolGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddBarrier(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddBarrierClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
    function AddBarrierIncompleteSize(const I_handle:string; const O_size:string):string;
    function AddBarrierInsertMany(const I_handle:string; const I_keys:string; const I_values:string; const A_T:TF_DataType; const A_component_index:cint64):string;
    function AddBarrierReadySize(const I_handle:string; const O_size:string):string;
    function AddBarrierTakeMany(const I_handle:string; const I_num_elements:string; const O_indices:string; const O_keys:string; const OL_values:string; const A_component_types:TF_TypeList; const A_allow_small_batch:boolean; const A_wait_for_incomplete:boolean; const A_timeout_ms:cint64):string;
    function AddBatch(const IL_in_tensors:string; const O_batch_index:string; const O_id:string; const OL_batched_tensors:string; const A_num_batch_threads:cint64; const A_max_batch_size:cint64; const A_max_enqueued_batches:cint64; const A_batch_timeout_micros:cint64; const A_allowed_batch_sizes:TF_IntList; const A_grad_timeout_micros:cint64; const A_container:string; const A_shared_name:string; const A_batching_queue:string; const A_T:TF_TypeList):string;
    function AddBatchCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchDataset(const I_input_dataset:string; const I_batch_size:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddBatchDatasetV2(const I_input_dataset:string; const I_batch_size:string; const I_drop_remainder:string; const O_handle:string; const A_parallel_copy:boolean; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddBatchFFT(const I_input:string; const O_output:string):string;
    function AddBatchFFT2D(const I_input:string; const O_output:string):string;
    function AddBatchFFT3D(const I_input:string; const O_output:string):string;
    function AddBatchFunction(const IL_in_tensors:string; const IL_captured_tensors:string; const OL_out_tensors:string; const A_f:TF_Function; const A_num_batch_threads:cint64; const A_max_batch_size:cint64; const A_batch_timeout_micros:cint64; const A_max_enqueued_batches:cint64; const A_allowed_batch_sizes:TF_IntList; const A_container:string; const A_shared_name:string; const A_batching_queue:string; const A_Tin:TF_TypeList; const A_Tcaptured:TF_TypeList; const A_Tout:TF_TypeList):string;
    function AddBatchIFFT(const I_input:string; const O_output:string):string;
    function AddBatchIFFT2D(const I_input:string; const O_output:string):string;
    function AddBatchIFFT3D(const I_input:string; const O_output:string):string;
    function AddBatchMatMul(const I_x:string; const I_y:string; const O_output:string; const A_T:TF_DataType; const A_adj_x:boolean; const A_adj_y:boolean):string;
    function AddBatchMatMulV2(const I_x:string; const I_y:string; const O_output:string; const A_T:TF_DataType; const A_adj_x:boolean; const A_adj_y:boolean):string;
    function AddBatchMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType):string;
    function AddBatchMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddBatchMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddBatchMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddBatchMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
    function AddBatchMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddBatchNormWithGlobalNormalization(const I_t:string; const I_m:string; const I_v:string; const I_beta:string; const I_gamma:string; const O_result:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
    function AddBatchNormWithGlobalNormalizationGrad(const I_t:string; const I_m:string; const I_v:string; const I_gamma:string; const I_backprop:string; const O_dx:string; const O_dm:string; const O_dv:string; const O_db:string; const O_dg:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
    function AddBatchSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBatchSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
    function AddBatchSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
    function AddBatchToSpace(const I_input:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_Tidx:TF_DataType):string;
    function AddBatchToSpaceND(const I_input:string; const I_block_shape:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tcrops:TF_DataType):string;
    function AddBesselI0e(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddBesselI1e(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddBetainc(const I_a:string; const I_b:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBiasAdd(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
    function AddBiasAddGrad(const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
    function AddBiasAddV1(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType):string;
    function AddBincount(const I_arr:string; const I_size:string; const I_weights:string; const O_bins:string; const A_T:TF_DataType):string;
    function AddBitcast(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_type:TF_DataType):string;
    function AddBitwiseAnd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBitwiseOr(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBitwiseXor(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddBlockLSTM(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const O_i:string; const O_cs:string; const O_f:string; const O_o:string; const O_ci:string; const O_co:string; const O_h:string; const A_forget_bias:real; const A_cell_clip:real; const A_use_peephole:boolean; const A_T:TF_DataType):string;
    function AddBlockLSTMGrad(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const I_i:string; const I_cs:string; const I_f:string; const I_o:string; const I_ci:string; const I_co:string; const I_h:string; const I_cs_grad:string; const I_h_grad:string; const O_x_grad:string; const O_cs_prev_grad:string; const O_h_prev_grad:string; const O_w_grad:string; const O_wci_grad:string; const O_wcf_grad:string; const O_wco_grad:string; const O_b_grad:string; const A_use_peephole:boolean; const A_T:TF_DataType):string;
    function AddBlockLSTMGradV2(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const I_i:string; const I_cs:string; const I_f:string; const I_o:string; const I_ci:string; const I_co:string; const I_h:string; const I_cs_grad:string; const I_h_grad:string; const O_x_grad:string; const O_cs_prev_grad:string; const O_h_prev_grad:string; const O_w_grad:string; const O_wci_grad:string; const O_wcf_grad:string; const O_wco_grad:string; const O_b_grad:string; const A_use_peephole:boolean; const A_T:TF_DataType):string;
    function AddBlockLSTMV2(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const O_i:string; const O_cs:string; const O_f:string; const O_o:string; const O_ci:string; const O_co:string; const O_h:string; const A_cell_clip:real; const A_use_peephole:boolean; const A_T:TF_DataType):string;
    function AddBoostedTreesAggregateStats(const I_node_ids:string; const I_gradients:string; const I_hessians:string; const I_feature:string; const O_stats_summary:string; const A_max_splits:cint64; const A_num_buckets:cint64):string;
    function AddBoostedTreesBucketize(const IL_float_values:string; const IL_bucket_boundaries:string; const OL_buckets:string; const A_num_features:cint64):string;
    function AddBoostedTreesCalculateBestFeatureSplit(const I_node_id_range:string; const I_stats_summary:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const O_node_ids:string; const O_gains:string; const O_feature_dimensions:string; const O_thresholds:string; const O_left_node_contribs:string; const O_right_node_contribs:string; const O_split_with_default_directions:string; const A_logits_dimension:cint64; const A_split_type:string):string;
    function AddBoostedTreesCalculateBestFeatureSplitV2(const I_node_id_range:string; const I_split_types:string; const I_candidate_feature_ids:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const IL_stats_summaries_list:string; const O_node_ids:string; const O_gains:string; const O_feature_ids:string; const O_feature_dimensions:string; const O_thresholds:string; const O_left_node_contribs:string; const O_right_node_contribs:string; const O_split_with_default_directions:string; const A_num_features:cint64; const A_logits_dimension:cint64):string;
    function AddBoostedTreesCalculateBestGainsPerFeature(const I_node_id_range:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const IL_stats_summary_list:string; const OL_node_ids_list:string; const OL_gains_list:string; const OL_thresholds_list:string; const OL_left_node_contribs_list:string; const OL_right_node_contribs_list:string; const A_max_splits:cint64; const A_num_features:cint64):string;
    function AddBoostedTreesCenterBias(const I_tree_ensemble_handle:string; const I_mean_gradients:string; const I_mean_hessians:string; const I_l1:string; const I_l2:string; const O_continue_centering:string):string;
    function AddBoostedTreesCreateEnsemble(const I_tree_ensemble_handle:string; const I_stamp_token:string; const I_tree_ensemble_serialized:string):string;
    function AddBoostedTreesCreateQuantileStreamResource(const I_quantile_stream_resource_handle:string; const I_epsilon:string; const I_num_streams:string; const A_max_elements:cint64):string;
    function AddBoostedTreesDeserializeEnsemble(const I_tree_ensemble_handle:string; const I_stamp_token:string; const I_tree_ensemble_serialized:string):string;
    function AddBoostedTreesEnsembleResourceHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string):string;
    function AddBoostedTreesExampleDebugOutputs(const I_tree_ensemble_handle:string; const IL_bucketized_features:string; const O_examples_debug_outputs_serialized:string; const A_num_bucketized_features:cint64; const A_logits_dimension:cint64):string;
    function AddBoostedTreesFlushQuantileSummaries(const I_quantile_stream_resource_handle:string; const OL_summaries:string; const A_num_features:cint64):string;
    function AddBoostedTreesGetEnsembleStates(const I_tree_ensemble_handle:string; const O_stamp_token:string; const O_num_trees:string; const O_num_finalized_trees:string; const O_num_attempted_layers:string; const O_last_layer_nodes_range:string):string;
    function AddBoostedTreesMakeQuantileSummaries(const I_example_weights:string; const I_epsilon:string; const IL_float_values:string; const OL_summaries:string; const A_num_features:cint64):string;
    function AddBoostedTreesMakeStatsSummary(const I_node_ids:string; const I_gradients:string; const I_hessians:string; const IL_bucketized_features_list:string; const O_stats_summary:string; const A_max_splits:cint64; const A_num_buckets:cint64; const A_num_features:cint64):string;
    function AddBoostedTreesPredict(const I_tree_ensemble_handle:string; const IL_bucketized_features:string; const O_logits:string; const A_num_bucketized_features:cint64; const A_logits_dimension:cint64):string;
    function AddBoostedTreesQuantileStreamResourceAddSummaries(const I_quantile_stream_resource_handle:string; const IL_summaries:string; const A_num_features:cint64):string;
    function AddBoostedTreesQuantileStreamResourceDeserialize(const I_quantile_stream_resource_handle:string; const IL_bucket_boundaries:string; const A_num_streams:cint64):string;
    function AddBoostedTreesQuantileStreamResourceFlush(const I_quantile_stream_resource_handle:string; const I_num_buckets:string; const A_generate_quantiles:boolean):string;
    function AddBoostedTreesQuantileStreamResourceGetBucketBoundaries(const I_quantile_stream_resource_handle:string; const OL_bucket_boundaries:string; const A_num_features:cint64):string;
    function AddBoostedTreesQuantileStreamResourceHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string):string;
    function AddBoostedTreesSerializeEnsemble(const I_tree_ensemble_handle:string; const O_stamp_token:string; const O_tree_ensemble_serialized:string):string;
    function AddBoostedTreesSparseAggregateStats(const I_node_ids:string; const I_gradients:string; const I_hessians:string; const I_feature_indices:string; const I_feature_values:string; const I_feature_shape:string; const O_stats_summary_indices:string; const O_stats_summary_values:string; const O_stats_summary_shape:string; const A_max_splits:cint64; const A_num_buckets:cint64):string;
    function AddBoostedTreesSparseCalculateBestFeatureSplit(const I_node_id_range:string; const I_stats_summary_indices:string; const I_stats_summary_values:string; const I_stats_summary_shape:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const O_node_ids:string; const O_gains:string; const O_feature_dimensions:string; const O_thresholds:string; const O_left_node_contribs:string; const O_right_node_contribs:string; const O_split_with_default_directions:string; const A_logits_dimension:cint64; const A_split_type:string):string;
    function AddBoostedTreesTrainingPredict(const I_tree_ensemble_handle:string; const I_cached_tree_ids:string; const I_cached_node_ids:string; const IL_bucketized_features:string; const O_partial_logits:string; const O_tree_ids:string; const O_node_ids:string; const A_num_bucketized_features:cint64; const A_logits_dimension:cint64):string;
    function AddBoostedTreesUpdateEnsemble(const I_tree_ensemble_handle:string; const I_feature_ids:string; const I_max_depth:string; const I_learning_rate:string; const IL_node_ids:string; const IL_gains:string; const IL_thresholds:string; const IL_left_node_contribs:string; const IL_right_node_contribs:string; const A_pruning_mode:cint64; const A_num_features:cint64):string;
    function AddBoostedTreesUpdateEnsembleV2(const I_tree_ensemble_handle:string; const I_max_depth:string; const I_learning_rate:string; const I_pruning_mode:string; const IL_feature_ids:string; const IL_dimension_ids:string; const IL_node_ids:string; const IL_gains:string; const IL_thresholds:string; const IL_left_node_contribs:string; const IL_right_node_contribs:string; const IL_split_types:string; const A_num_features:cint64; const A_logits_dimension:cint64; const A_num_groups:cint64):string;
    function AddBroadcastArgs(const I_s0:string; const I_s1:string; const O_r0:string; const A_T:TF_DataType):string;
    function AddBroadcastGradientArgs(const I_s0:string; const I_s1:string; const O_r0:string; const O_r1:string; const A_T:TF_DataType):string;
    function AddBroadcastTo(const I_input:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddBucketize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_boundaries:TF_FloatList):string;
    function AddBytesProducedStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddCSRSparseMatrixComponents(const I_csr_sparse_matrix:string; const I_index:string; const O_row_ptrs:string; const O_col_inds:string; const O_values:string; const A_type:TF_DataType):string;
    function AddCSRSparseMatrixToDense(const I_sparse_input:string; const O_dense_output:string; const A_type:TF_DataType):string;
    function AddCSRSparseMatrixToSparseTensor(const I_sparse_matrix:string; const O_indices:string; const O_values:string; const O_dense_shape:string; const A_type:TF_DataType):string;
    function AddCSVDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const I_header:string; const I_field_delim:string; const I_use_quote_delim:string; const I_na_value:string; const I_select_cols:string; const IL_record_defaults:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddCTCBeamSearchDecoder(const I_inputs:string; const I_sequence_length:string; const O_log_probability:string; const OL_decoded_indices:string; const OL_decoded_values:string; const OL_decoded_shape:string; const A_beam_width:cint64; const A_top_paths:cint64; const A_merge_repeated:boolean; const A_T:TF_DataType):string;
    function AddCTCGreedyDecoder(const I_inputs:string; const I_sequence_length:string; const O_decoded_indices:string; const O_decoded_values:string; const O_decoded_shape:string; const O_log_probability:string; const A_merge_repeated:boolean; const A_T:TF_DataType):string;
    function AddCTCLoss(const I_inputs:string; const I_labels_indices:string; const I_labels_values:string; const I_sequence_length:string; const O_loss:string; const O_gradient:string; const A_preprocess_collapse_repeated:boolean; const A_ctc_merge_repeated:boolean; const A_ignore_longer_outputs_than_inputs:boolean; const A_T:TF_DataType):string;
    function AddCTCLossV2(const I_inputs:string; const I_labels_indices:string; const I_labels_values:string; const I_sequence_length:string; const O_loss:string; const O_gradient:string; const A_preprocess_collapse_repeated:boolean; const A_ctc_merge_repeated:boolean; const A_ignore_longer_outputs_than_inputs:boolean):string;
    function AddCacheDataset(const I_input_dataset:string; const I_filename:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddCacheDatasetV2(const I_input_dataset:string; const I_filename:string; const I_cache:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddCase(const I_branch_index:string; const IL_input:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_branches:TF_FuncnameList; const A_output_shapes:TF_ShapeList):string;
    function AddCast(const I_x:string; const O_y:string; const A_SrcT:TF_DataType; const A_DstT:TF_DataType; const A_Truncate:boolean):string;
    function AddCeil(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddCheckNumerics(const I_tensor:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
    function AddCheckNumericsV2(const I_tensor:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
    function AddCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
    function AddChooseFastestBranchDataset(const I_input_dataset:string; const I_ratio_numerator:string; const I_ratio_denominator:string; const IL_other_arguments:string; const O_handle:string; const A_Targuments:TF_TypeList; const A_num_elements_per_branch:cint64; const A_branches:TF_FuncnameList; const A_other_arguments_lengths:TF_IntList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddChooseFastestDataset(const IL_input_datasets:string; const O_handle:string; const A_N:cint64; const A_num_experiments:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddClipByValue(const I_t:string; const I_clip_value_min:string; const I_clip_value_max:string; const O_output:string; const A_T:TF_DataType):string;
    function AddCloseSummaryWriter(const I_writer:string):string;
    function AddCollectiveBcastRecv(const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_shape:TF_Shape; const A_communication_hint:string):string;
    function AddCollectiveBcastSend(const I_input:string; const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_shape:TF_Shape; const A_communication_hint:string):string;
    function AddCollectiveGather(const I_input:string; const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_shape:TF_Shape; const A_communication_hint:string):string;
    function AddCollectivePermute(const I_input:string; const I_source_target_pairs:string; const O_output:string; const A_T:TF_DataType):string;
    function AddCollectiveReduce(const I_input:string; const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_merge_op:string; const A_final_op:string; const A_subdiv_offsets:TF_IntList; const A_wait_for:TF_IntList; const A_communication_hint:string):string;
    function AddCombinedNonMaxSuppression(const I_boxes:string; const I_scores:string; const I_max_output_size_per_class:string; const I_max_total_size:string; const I_iou_threshold:string; const I_score_threshold:string; const O_nmsed_boxes:string; const O_nmsed_scores:string; const O_nmsed_classes:string; const O_valid_detections:string; const A_pad_per_class:boolean; const A_clip_boxes:boolean):string;
    function AddCompareAndBitpack(const I_input:string; const I_threshold:string; const O_output:string; const A_T:TF_DataType):string;
    function AddComplex(const I_real:string; const I_imag:string; const O_out:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddComplexAbs(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddComputeAccidentalHits(const I_true_classes:string; const I_sampled_candidates:string; const O_indices:string; const O_ids:string; const O_weights:string; const A_num_true:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddConcat(const I_concat_dim:string; const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddConcatOffset(const I_concat_dim:string; const IL_shape:string; const OL_offset:string; const A_N:cint64):string;
    function AddConcatV2(const I_axis:string; const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddConcatenateDataset(const I_input_dataset:string; const I_another_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):string;
    function AddConfigureDistributedTPU(const O_topology:string; const A_embedding_config:string; const A_tpu_embedding_config:string; const A_is_global_init:boolean; const A_enable_whole_mesh_compilations:boolean; const A_compilation_failure_closes_chips:boolean):string;
    function AddConfigureTPUEmbedding(const A_config:string):string;
    function AddConj(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddConjugateTranspose(const I_x:string; const I_perm:string; const O_y:string; const A_T:TF_DataType; const A_Tperm:TF_DataType):string;
    function AddConst(const O_output:string; const A_value:TF_TensorPtr; const A_dtype:TF_DataType):string;
    function AddConsumeMutexLock(const I_mutex_lock:string):string;
    function AddControlTrigger():string;
    function AddConv2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:TF_IntList; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddConv2DBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:TF_IntList; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddConv2DBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:TF_IntList; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddConv3D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddConv3DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
    function AddConv3DBackpropFilterV2(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddConv3DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
    function AddConv3DBackpropInputV2(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList; const A_Tshape:TF_DataType):string;
    function AddCopy(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
    function AddCopyHost(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
    function AddCos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddCosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddCountUpTo(const I_ref:string; const O_output:string; const A_limit:cint64; const A_T:TF_DataType):string;
    function AddCreateSummaryDbWriter(const I_writer:string; const I_db_uri:string; const I_experiment_name:string; const I_run_name:string; const I_user_name:string):string;
    function AddCreateSummaryFileWriter(const I_writer:string; const I_logdir:string; const I_max_queue:string; const I_flush_millis:string; const I_filename_suffix:string):string;
    function AddCropAndResize(const I_image:string; const I_boxes:string; const I_box_ind:string; const I_crop_size:string; const O_crops:string; const A_T:TF_DataType; const A_method:string; const A_extrapolation_value:real):string;
    function AddCropAndResizeGradBoxes(const I_grads:string; const I_image:string; const I_boxes:string; const I_box_ind:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
    function AddCropAndResizeGradImage(const I_grads:string; const I_boxes:string; const I_box_ind:string; const I_image_size:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
    function AddCross(const I_a:string; const I_b:string; const O_product:string; const A_T:TF_DataType):string;
    function AddCrossReplicaSum(const I_input:string; const I_group_assignment:string; const O_output:string; const A_T:TF_DataType):string;
    function AddCudnnRNN(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const O_output:string; const O_output_h:string; const O_output_c:string; const O_reserve_space:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_is_training:boolean):string;
    function AddCudnnRNNBackprop(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_output:string; const I_output_h:string; const I_output_c:string; const I_output_backprop:string; const I_output_h_backprop:string; const I_output_c_backprop:string; const I_reserve_space:string; const O_input_backprop:string; const O_input_h_backprop:string; const O_input_c_backprop:string; const O_params_backprop:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
    function AddCudnnRNNBackpropV2(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_output:string; const I_output_h:string; const I_output_c:string; const I_output_backprop:string; const I_output_h_backprop:string; const I_output_c_backprop:string; const I_reserve_space:string; const I_host_reserved:string; const O_input_backprop:string; const O_input_h_backprop:string; const O_input_c_backprop:string; const O_params_backprop:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
    function AddCudnnRNNBackpropV3(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_sequence_lengths:string; const I_output:string; const I_output_h:string; const I_output_c:string; const I_output_backprop:string; const I_output_h_backprop:string; const I_output_c_backprop:string; const I_reserve_space:string; const I_host_reserved:string; const O_input_backprop:string; const O_input_h_backprop:string; const O_input_c_backprop:string; const O_params_backprop:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64; const A_time_major:boolean):string;
    function AddCudnnRNNCanonicalToParams(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const IL_weights:string; const IL_biases:string; const O_params:string; const A_T:TF_DataType; const A_num_params:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
    function AddCudnnRNNCanonicalToParamsV2(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const IL_weights:string; const IL_biases:string; const O_params:string; const A_T:TF_DataType; const A_num_params_weights:cint64; const A_num_params_biases:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64):string;
    function AddCudnnRNNParamsSize(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const O_params_size:string; const A_T:TF_DataType; const A_S:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64):string;
    function AddCudnnRNNParamsToCanonical(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const I_params:string; const OL_weights:string; const OL_biases:string; const A_T:TF_DataType; const A_num_params:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
    function AddCudnnRNNParamsToCanonicalV2(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const I_params:string; const OL_weights:string; const OL_biases:string; const A_T:TF_DataType; const A_num_params_weights:cint64; const A_num_params_biases:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64):string;
    function AddCudnnRNNV2(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const O_output:string; const O_output_h:string; const O_output_c:string; const O_reserve_space:string; const O_host_reserved:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_is_training:boolean):string;
    function AddCudnnRNNV3(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_sequence_lengths:string; const O_output:string; const O_output_h:string; const O_output_c:string; const O_reserve_space:string; const O_host_reserved:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64; const A_is_training:boolean; const A_time_major:boolean):string;
    function AddCumprod(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddCumsum(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddCumulativeLogsumexp(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddDataFormatDimMap(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_src_format:string; const A_dst_format:string):string;
    function AddDataFormatVecPermute(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_src_format:string; const A_dst_format:string):string;
    function AddDatasetCardinality(const I_input_dataset:string; const O_cardinality:string):string;
    function AddDatasetFromGraph(const I_graph_def:string; const O_handle:string):string;
    function AddDatasetToGraph(const I_input_dataset:string; const O_graph:string; const A_stateful_whitelist:TF_StringList; const A_allow_stateful:boolean; const A_strip_device_assignment:boolean):string;
    function AddDatasetToGraphV2(const I_input_dataset:string; const O_graph:string; const A_external_state_policy:cint64; const A_strip_device_assignment:boolean):string;
    function AddDatasetToSingleElement(const I_dataset:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddDatasetToTFRecord(const I_input_dataset:string; const I_filename:string; const I_compression_type:string):string;
    function AddDawsn(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddDebugGradientIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDebugGradientRefIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDebugIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
    function AddDebugIdentityV2(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tfdbg_context_id:string; const A_op_name:string; const A_output_slot:cint64; const A_tensor_debug_mode:cint64; const A_debug_urls:TF_StringList):string;
    function AddDebugNanCount(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
    function AddDebugNumericSummary(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean):string;
    function AddDebugNumericSummaryV2(const I_input:string; const O_output:string; const A_output_dtype:TF_DataType; const A_T:TF_DataType; const A_tensor_debug_mode:cint64; const A_tensor_id:cint64):string;
    function AddDecodeAndCropJpeg(const I_contents:string; const I_crop_window:string; const O_image:string; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string):string;
    function AddDecodeBase64(const I_input:string; const O_output:string):string;
    function AddDecodeBmp(const I_contents:string; const O_image:string; const A_channels:cint64):string;
    function AddDecodeCSV(const I_records:string; const IL_record_defaults:string; const OL_output:string; const A_OUT_TYPE:TF_TypeList; const A_field_delim:string; const A_use_quote_delim:boolean; const A_na_value:string; const A_select_cols:TF_IntList):string;
    function AddDecodeCompressed(const I_bytes:string; const O_output:string; const A_compression_type:string):string;
    function AddDecodeGif(const I_contents:string; const O_image:string):string;
    function AddDecodeJSONExample(const I_json_examples:string; const O_binary_examples:string):string;
    function AddDecodeJpeg(const I_contents:string; const O_image:string; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string):string;
    function AddDecodePaddedRaw(const I_input_bytes:string; const I_fixed_length:string; const O_output:string; const A_out_type:TF_DataType; const A_little_endian:boolean):string;
    function AddDecodePng(const I_contents:string; const O_image:string; const A_channels:cint64; const A_dtype:TF_DataType):string;
    function AddDecodeProtoV2(const I_bytes:string; const O_sizes:string; const OL_values:string; const A_message_type:string; const A_field_names:TF_StringList; const A_output_types:TF_TypeList; const A_descriptor_source:string; const A_message_format:string; const A_sanitize:boolean):string;
    function AddDecodeRaw(const I_bytes:string; const O_output:string; const A_out_type:TF_DataType; const A_little_endian:boolean):string;
    function AddDecodeWav(const I_contents:string; const O_audio:string; const O_sample_rate:string; const A_desired_channels:cint64; const A_desired_samples:cint64):string;
    function AddDeepCopy(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddDeleteIterator(const I_handle:string; const I_deleter:string):string;
    function AddDeleteMemoryCache(const I_handle:string; const I_deleter:string):string;
    function AddDeleteMultiDeviceIterator(const I_multi_device_iterator:string; const I_deleter:string; const IL_iterators:string; const A_N:cint64):string;
    function AddDeleteRandomSeedGenerator(const I_handle:string; const I_deleter:string):string;
    function AddDeleteSessionTensor(const I_handle:string):string;
    function AddDenseToCSRSparseMatrix(const I_dense_input:string; const I_indices:string; const O_sparse_output:string; const A_T:TF_DataType):string;
    function AddDenseToDenseSetOperation(const I_set1:string; const I_set2:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddDenseToSparseBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_row_shape:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddDenseToSparseSetOperation(const I_set1:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddDepthToSpace(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_data_format:string):string;
    function AddDepthwiseConv2dNative(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddDepthwiseConv2dNativeBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddDepthwiseConv2dNativeBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
    function AddDequantize(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const A_T:TF_DataType; const A_mode:string; const A_narrow_range:boolean; const A_axis:cint64; const A_dtype:TF_DataType):string;
    function AddDeserializeIterator(const I_resource_handle:string; const I_serialized:string):string;
    function AddDeserializeManySparse(const I_serialized_sparse:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType):string;
    function AddDeserializeSparse(const I_serialized_sparse:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType; const A_Tserialized:TF_DataType):string;
    function AddDestroyResourceOp(const I_resource:string; const A_ignore_lookup_error:boolean):string;
    function AddDestroyTemporaryVariable(const I_ref:string; const O_value:string; const A_T:TF_DataType; const A_var_name:string):string;
    function AddDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddDigamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddDilation2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
    function AddDilation2DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_filter_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
    function AddDilation2DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_in_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
    function AddDirectedInterleaveDataset(const I_selector_input_dataset:string; const IL_data_input_datasets:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    function AddDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddDivNoNan(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddDrawBoundingBoxes(const I_images:string; const I_boxes:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDrawBoundingBoxesV2(const I_images:string; const I_boxes:string; const I_colors:string; const O_output:string; const A_T:TF_DataType):string;
    function AddDynamicPartition(const I_data:string; const I_partitions:string; const OL_outputs:string; const A_num_partitions:cint64; const A_T:TF_DataType):string;
    function AddDynamicStitch(const IL_indices:string; const IL_data:string; const O_merged:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddEagerPyFunc(const IL_input:string; const OL_output:string; const A_token:string; const A_is_async:boolean; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
    function AddEditDistance(const I_hypothesis_indices:string; const I_hypothesis_values:string; const I_hypothesis_shape:string; const I_truth_indices:string; const I_truth_values:string; const I_truth_shape:string; const O_output:string; const A_normalize:boolean; const A_T:TF_DataType):string;
    function AddEig(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddEinsum(const IL_inputs:string; const O_output:string; const A_equation:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddElu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddEluGrad(const I_gradients:string; const I_outputs:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddEmpty(const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_init:boolean):string;
    function AddEmptyTensorList(const I_element_shape:string; const I_max_num_elements:string; const O_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddEncodeBase64(const I_input:string; const O_output:string; const A_pad:boolean):string;
    function AddEncodeJpeg(const I_image:string; const O_contents:string; const A_format:string; const A_quality:cint64; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:cint64; const A_y_density:cint64; const A_xmp_metadata:string):string;
    function AddEncodeJpegVariableQuality(const I_images:string; const I_quality:string; const O_contents:string):string;
    function AddEncodePng(const I_image:string; const O_contents:string; const A_compression:cint64; const A_T:TF_DataType):string;
    function AddEncodeProto(const I_sizes:string; const IL_values:string; const O_bytes:string; const A_field_names:TF_StringList; const A_message_type:string; const A_descriptor_source:string; const A_Tinput_types:TF_TypeList):string;
    function AddEncodeWav(const I_audio:string; const I_sample_rate:string; const O_contents:string):string;
    function AddEnqueueTPUEmbeddingIntegerBatch(const I_mode_override:string; const IL_batch:string; const A_N:cint64; const A_device_ordinal:cint64):string;
    function AddEnqueueTPUEmbeddingSparseBatch(const I_mode_override:string; const IL_sample_indices:string; const IL_embedding_indices:string; const IL_aggregation_weights:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_T3:TF_DataType; const A_N:cint64; const A_device_ordinal:cint64; const A_combiners:TF_StringList):string;
    function AddEnqueueTPUEmbeddingSparseTensorBatch(const I_mode_override:string; const IL_sample_indices:string; const IL_embedding_indices:string; const IL_aggregation_weights:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_T3:TF_DataType; const A_N:cint64; const A_device_ordinal:cint64; const A_combiners:TF_StringList; const A_table_ids:TF_IntList; const A_max_sequence_lengths:TF_IntList):string;
    function AddEnsureShape(const I_input:string; const O_output:string; const A_shape:TF_Shape; const A_T:TF_DataType):string;
    function AddEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
    function AddEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_incompatible_shape_error:boolean):string;
    function AddErf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddErfc(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddErfinv(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddEuclideanNorm(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddExp(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddExpandDims(const I_input:string; const I_dim:string; const O_output:string; const A_T:TF_DataType; const A_Tdim:TF_DataType):string;
    function AddExperimentalAssertNextDataset(const I_input_dataset:string; const I_transformations:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalAutoShardDataset(const I_input_dataset:string; const I_num_workers:string; const I_index:string; const O_handle:string; const A_auto_shard_policy:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalBytesProducedStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalCSVDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const I_header:string; const I_field_delim:string; const I_use_quote_delim:string; const I_na_value:string; const I_select_cols:string; const IL_record_defaults:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalChooseFastestDataset(const IL_input_datasets:string; const O_handle:string; const A_N:cint64; const A_num_experiments:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalDatasetCardinality(const I_input_dataset:string; const O_cardinality:string):string;
    function AddExperimentalDatasetToTFRecord(const I_input_dataset:string; const I_filename:string; const I_compression_type:string):string;
    function AddExperimentalDenseToSparseBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_row_shape:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalDirectedInterleaveDataset(const I_selector_input_dataset:string; const IL_data_input_datasets:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    function AddExperimentalGroupByReducerDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_init_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_finalize_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_init_func:TF_Function; const A_reduce_func:TF_Function; const A_finalize_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Tinit_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Tfinalize_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalGroupByWindowDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_window_size_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_reduce_func:TF_Function; const A_window_size_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Twindow_size_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalIgnoreErrorsDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalIteratorGetDevice(const I_resource:string; const O_device:string):string;
    function AddExperimentalLMDBDataset(const I_filenames:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalLatencyStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalMapAndBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_num_parallel_calls:string; const I_drop_remainder:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean):string;
    function AddExperimentalMapDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean; const A_preserve_cardinality:boolean):string;
    function AddExperimentalMatchingFilesDataset(const I_patterns:string; const O_handle:string):string;
    function AddExperimentalMaxIntraOpParallelismDataset(const I_input_dataset:string; const I_max_intra_op_parallelism:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalNonSerializableDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalParallelInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_sloppy:string; const I_buffer_output_elements:string; const I_prefetch_input_elements:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalParseExampleDataset(const I_input_dataset:string; const I_num_parallel_calls:string; const IL_dense_defaults:string; const O_handle:string; const A_sparse_keys:TF_StringList; const A_dense_keys:TF_StringList; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_sloppy:boolean):string;
    function AddExperimentalPrivateThreadPoolDataset(const I_input_dataset:string; const I_num_threads:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalRandomDataset(const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalRebatchDataset(const I_input_dataset:string; const I_num_replicas:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_fallback:boolean):string;
    function AddExperimentalScanDataset(const I_input_dataset:string; const IL_initial_state:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Tstate:TF_TypeList; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean):string;
    function AddExperimentalSetStatsAggregatorDataset(const I_input_dataset:string; const I_stats_aggregator:string; const I_tag:string; const I_counter_prefix:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalSleepDataset(const I_input_dataset:string; const I_sleep_microseconds:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalSlidingWindowDataset(const I_input_dataset:string; const I_window_size:string; const I_window_shift:string; const I_window_stride:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalSqlDataset(const I_driver_name:string; const I_data_source_name:string; const I_query:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalStatsAggregatorHandle(const O_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddExperimentalStatsAggregatorSummary(const I_iterator:string; const O_summary:string):string;
    function AddExperimentalTakeWhileDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalThreadPoolDataset(const I_input_dataset:string; const I_thread_pool:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalThreadPoolHandle(const O_handle:string; const A_num_threads:cint64; const A_max_intra_op_parallelism:cint64; const A_display_name:string; const A_container:string; const A_shared_name:string):string;
    function AddExperimentalUnbatchDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExperimentalUniqueDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddExpint(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddExpm1(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddExtractGlimpse(const I_input:string; const I_size:string; const I_offsets:string; const O_glimpse:string; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean; const A_noise:string):string;
    function AddExtractImagePatches(const I_images:string; const O_patches:string; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_T:TF_DataType; const A_padding:string):string;
    function AddExtractJpegShape(const I_contents:string; const O_image_shape:string; const A_output_type:TF_DataType):string;
    function AddExtractVolumePatches(const I_input:string; const O_patches:string; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_T:TF_DataType; const A_padding:string):string;
    function AddFFT(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
    function AddFFT2D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
    function AddFFT3D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
    function AddFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddFact(const O_fact:string):string;
    function AddFakeParam(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddFakeQuantWithMinMaxArgs(const I_inputs:string; const O_outputs:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxArgsGradient(const I_gradients:string; const I_inputs:string; const O_backprops:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVars(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVarsGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVarsPerChannel(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQuantWithMinMaxVarsPerChannelGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
    function AddFakeQueue(const I_resource:string; const O_handle:string):string;
    function AddFill(const I_dims:string; const I_value:string; const O_output:string; const A_T:TF_DataType; const A_index_type:TF_DataType):string;
    function AddFilterByLastComponentDataset(const I_input_dataset:string; const O_output:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddFilterDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddFingerprint(const I_data:string; const I_method:string; const O_fingerprint:string; const A_T:TF_DataType):string;
    function AddFixedLengthRecordDataset(const I_filenames:string; const I_header_bytes:string; const I_record_bytes:string; const I_footer_bytes:string; const I_buffer_size:string; const O_handle:string):string;
    function AddFixedLengthRecordDatasetV2(const I_filenames:string; const I_header_bytes:string; const I_record_bytes:string; const I_footer_bytes:string; const I_buffer_size:string; const I_compression_type:string; const O_handle:string):string;
    function AddFixedLengthRecordReader(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string):string;
    function AddFixedLengthRecordReaderV2(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string; const A_encoding:string):string;
    function AddFixedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_vocab_file:string; const A_distortion:real; const A_num_reserved_ids:cint64; const A_num_shards:cint64; const A_shard:cint64; const A_unigrams:TF_FloatList; const A_seed:cint64; const A_seed2:cint64):string;
    function AddFlatMapDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddFloor(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddFloorDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddFloorMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddFlushSummaryWriter(const I_writer:string):string;
    function AddFor(const I_start:string; const I_limit:string; const I_delta:string; const IL_input:string; const OL_output:string; const A_T:TF_TypeList; const A_body:TF_Function):string;
    function AddFractionalAvgPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddFractionalAvgPoolGrad(const I_orig_input_tensor_shape:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
    function AddFractionalMaxPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddFractionalMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
    function AddFresnelCos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddFresnelSin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddFusedBatchNorm(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedBatchNormGrad(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_3:string; const O_reserve_space_4:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedBatchNormGradV2(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_3:string; const O_reserve_space_4:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedBatchNormGradV3(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const I_reserve_space_3:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_4:string; const O_reserve_space_5:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedBatchNormV2(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedBatchNormV3(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const O_reserve_space_3:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
    function AddFusedPadConv2D(const I_input:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
    function AddFusedResizeAndPadConv2D(const I_input:string; const I_size:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
    function AddGRUBlockCell(const I_x:string; const I_h_prev:string; const I_w_ru:string; const I_w_c:string; const I_b_ru:string; const I_b_c:string; const O_r:string; const O_u:string; const O_c:string; const O_h:string; const A_T:TF_DataType):string;
    function AddGRUBlockCellGrad(const I_x:string; const I_h_prev:string; const I_w_ru:string; const I_w_c:string; const I_b_ru:string; const I_b_c:string; const I_r:string; const I_u:string; const I_c:string; const I_d_h:string; const O_d_x:string; const O_d_h_prev:string; const O_d_c_bar:string; const O_d_r_bar_u_bar:string; const A_T:TF_DataType):string;
    function AddGather(const I_params:string; const I_indices:string; const O_output:string; const A_validate_indices:boolean; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddGatherNd(const I_params:string; const I_indices:string; const O_output:string; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddGatherV2(const I_params:string; const I_indices:string; const I_axis:string; const O_output:string; const A_batch_dims:cint64; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType; const A_Taxis:TF_DataType):string;
    function AddGenerateBoundingBoxProposals(const I_scores:string; const I_bbox_deltas:string; const I_image_info:string; const I_anchors:string; const I_nms_threshold:string; const I_pre_nms_topn:string; const I_min_size:string; const O_rois:string; const O_roi_probabilities:string; const A_post_nms_topn:cint64):string;
    function AddGenerateVocabRemapping(const I_new_vocab_file:string; const I_old_vocab_file:string; const O_remapping:string; const O_num_present:string; const A_new_vocab_offset:cint64; const A_num_new_vocab:cint64; const A_old_vocab_size:cint64):string;
    function AddGeneratorDataset(const IL_init_func_other_args:string; const IL_next_func_other_args:string; const IL_finalize_func_other_args:string; const O_handle:string; const A_init_func:TF_Function; const A_next_func:TF_Function; const A_finalize_func:TF_Function; const A_Tinit_func_args:TF_TypeList; const A_Tnext_func_args:TF_TypeList; const A_Tfinalize_func_args:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddGetSessionHandle(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
    function AddGetSessionHandleV2(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
    function AddGetSessionTensor(const I_handle:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddGreater(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddGreaterEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddGroupByReducerDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_init_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_finalize_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_init_func:TF_Function; const A_reduce_func:TF_Function; const A_finalize_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Tinit_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Tfinalize_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddGroupByWindowDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_window_size_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_reduce_func:TF_Function; const A_window_size_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Twindow_size_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddGuaranteeConst(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddHSVToRGB(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
    function AddHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddHistogramFixedWidth(const I_values:string; const I_value_range:string; const I_nbins:string; const O_out:string; const A_T:TF_DataType; const A_dtype:TF_DataType):string;
    function AddHistogramSummary(const I_tag:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
    function AddHostConst(const O_output:string; const A_value:TF_TensorPtr; const A_dtype:TF_DataType):string;
    function AddIFFT(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
    function AddIFFT2D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
    function AddIFFT3D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
    function AddIRFFT(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
    function AddIRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
    function AddIRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
    function AddIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddIdentityN(const IL_input:string; const OL_output:string; const A_T:TF_TypeList):string;
    function AddIdentityReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddIdentityReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddIf(const I_cond:string; const IL_input:string; const OL_output:string; const A_Tcond:TF_DataType; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_then_branch:TF_Function; const A_else_branch:TF_Function; const A_output_shapes:TF_ShapeList):string;
    function AddIgamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddIgammaGradA(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddIgammac(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddIgnoreErrorsDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddImag(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddImageProjectiveTransformV2(const I_images:string; const I_transforms:string; const I_output_shape:string; const O_transformed_images:string; const A_dtype:TF_DataType; const A_interpolation:string):string;
    function AddImageSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_max_images:cint64; const A_T:TF_DataType; const A_bad_color:TF_TensorPtr):string;
    function AddImmutableConst(const O_tensor:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):string;
    function AddImportEvent(const I_writer:string; const I_event:string):string;
    function AddInTopK(const I_predictions:string; const I_targets:string; const O_precision:string; const A_k:cint64; const A_T:TF_DataType):string;
    function AddInTopKV2(const I_predictions:string; const I_targets:string; const I_k:string; const O_precision:string; const A_T:TF_DataType):string;
    function AddInfeedDequeue(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddInfeedDequeueTuple(const OL_outputs:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList):string;
    function AddInfeedEnqueue(const I_input:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_layout:TF_IntList; const A_device_ordinal:cint64):string;
    function AddInfeedEnqueuePrelinearizedBuffer(const I_input:string; const A_device_ordinal:cint64):string;
    function AddInfeedEnqueueTuple(const IL_inputs:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList; const A_layouts:TF_IntList; const A_device_ordinal:cint64):string;
    function AddInitializeTable(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
    function AddInitializeTableFromTextFile(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
    function AddInitializeTableFromTextFileV2(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
    function AddInitializeTableV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
    function AddInplaceAdd(const I_x:string; const I_i:string; const I_v:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInplaceSub(const I_x:string; const I_i:string; const I_v:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInplaceUpdate(const I_x:string; const I_i:string; const I_v:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddInv(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInvGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
    function AddInvert(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddInvertPermutation(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsBoostedTreesEnsembleInitialized(const I_tree_ensemble_handle:string; const O_is_initialized:string):string;
    function AddIsBoostedTreesQuantileStreamResourceInitialized(const I_quantile_stream_resource_handle:string; const O_is_initialized:string):string;
    function AddIsFinite(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsInf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsNan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddIsVariableInitialized(const I_ref:string; const O_is_initialized:string; const A_dtype:TF_DataType):string;
    function AddIterator(const O_handle:string; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorFromStringHandle(const I_string_handle:string; const O_resource_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorFromStringHandleV2(const I_string_handle:string; const O_resource_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorGetDevice(const I_resource:string; const O_device:string):string;
    function AddIteratorGetNext(const I_iterator:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorGetNextAsOptional(const I_iterator:string; const O_optional:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorGetNextSync(const I_iterator:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddIteratorToStringHandle(const I_resource_handle:string; const O_string_handle:string):string;
    function AddIteratorV2(const O_handle:string; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddKMC2ChainInitialization(const I_distances:string; const I_seed:string; const O_index:string):string;
    function AddKmeansPlusPlusInitialization(const I_points:string; const I_num_to_sample:string; const I_seed:string; const I_num_retries_per_sample:string; const O_samples:string):string;
    function AddL2Loss(const I_t:string; const O_output:string; const A_T:TF_DataType):string;
    function AddLMDBDataset(const I_filenames:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddLMDBReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddLRN(const I_input:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
    function AddLRNGrad(const I_input_grads:string; const I_input_image:string; const I_output_image:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
    function AddLSTMBlockCell(const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const O_i:string; const O_cs:string; const O_f:string; const O_o:string; const O_ci:string; const O_co:string; const O_h:string; const A_forget_bias:real; const A_cell_clip:real; const A_use_peephole:boolean; const A_T:TF_DataType):string;
    function AddLSTMBlockCellGrad(const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const I_i:string; const I_cs:string; const I_f:string; const I_o:string; const I_ci:string; const I_co:string; const I_cs_grad:string; const I_h_grad:string; const O_cs_prev_grad:string; const O_dicfo:string; const O_wci_grad:string; const O_wcf_grad:string; const O_wco_grad:string; const A_use_peephole:boolean; const A_T:TF_DataType):string;
    function AddLatencyStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddLeakyRelu(const I_features:string; const O_activations:string; const A_alpha:real; const A_T:TF_DataType):string;
    function AddLeakyReluGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_alpha:real; const A_T:TF_DataType):string;
    function AddLearnedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddLeftShift(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddLess(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddLessEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddLgamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddLinSpace(const I_start:string; const I_stop:string; const I_num:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddListDiff(const I_x:string; const I_y:string; const O_out:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddLoadAndRemapMatrix(const I_ckpt_path:string; const I_old_tensor_name:string; const I_row_remapping:string; const I_col_remapping:string; const I_initializing_values:string; const O_output_matrix:string; const A_num_rows:cint64; const A_num_cols:cint64; const A_max_rows_in_memory:cint64):string;
    function AddLoadTPUEmbeddingADAMParameters(const I_parameters:string; const I_momenta:string; const I_velocities:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingADAMParametersGradAccumDebug(const I_parameters:string; const I_momenta:string; const I_velocities:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingAdadeltaParameters(const I_parameters:string; const I_accumulators:string; const I_updates:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingAdadeltaParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_updates:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingAdagradParameters(const I_parameters:string; const I_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingAdagradParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingCenteredRMSPropParameters(const I_parameters:string; const I_ms:string; const I_mom:string; const I_mg:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingFTRLParameters(const I_parameters:string; const I_accumulators:string; const I_linears:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingFTRLParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_linears:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingMDLAdagradLightParameters(const I_parameters:string; const I_accumulators:string; const I_weights:string; const I_benefits:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingMomentumParameters(const I_parameters:string; const I_momenta:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingMomentumParametersGradAccumDebug(const I_parameters:string; const I_momenta:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingProximalAdagradParameters(const I_parameters:string; const I_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingRMSPropParameters(const I_parameters:string; const I_ms:string; const I_mom:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingRMSPropParametersGradAccumDebug(const I_parameters:string; const I_ms:string; const I_mom:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLoadTPUEmbeddingStochasticGradientDescentParameters(const I_parameters:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddLog(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddLog1p(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddLogMatrixDeterminant(const I_input:string; const O_sign:string; const O_log_abs_determinant:string; const A_T:TF_DataType):string;
    function AddLogSoftmax(const I_logits:string; const O_logsoftmax:string; const A_T:TF_DataType):string;
    function AddLogUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddLogicalAnd(const I_x:string; const I_y:string; const O_z:string):string;
    function AddLogicalNot(const I_x:string; const O_y:string):string;
    function AddLogicalOr(const I_x:string; const I_y:string; const O_z:string):string;
    function AddLookupTableExport(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
    function AddLookupTableExportV2(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
    function AddLookupTableFind(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableFindV2(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableImport(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableImportV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableInsert(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableInsertV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
    function AddLookupTableRemoveV2(const I_table_handle:string; const I_keys:string; const A_Tin:TF_DataType):string;
    function AddLookupTableSize(const I_table_handle:string; const O_size:string):string;
    function AddLookupTableSizeV2(const I_table_handle:string; const O_size:string):string;
    function AddLoopCond(const I_input:string; const O_output:string):string;
    function AddLowerBound(const I_sorted_inputs:string; const I_values:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddLu(const I_input:string; const O_lu:string; const O_p:string; const A_T:TF_DataType; const A_output_idx_type:TF_DataType):string;
    function AddMakeIterator(const I_dataset:string; const I_iterator:string):string;
    function AddMapAndBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_num_parallel_calls:string; const I_drop_remainder:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean):string;
    function AddMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean; const A_preserve_cardinality:boolean):string;
    function AddMapDefun(const IL_arguments:string; const IL_captured_inputs:string; const OL_output:string; const A_Targuments:TF_TypeList; const A_Tcaptured:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_f:TF_Function; const A_max_intra_op_parallelism:cint64):string;
    function AddMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapPeek(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapStage(const I_key:string; const I_indices:string; const IL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapUnstage(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_T:TF_DataType):string;
    function AddMatchingFiles(const I_pattern:string; const O_filenames:string):string;
    function AddMatchingFilesDataset(const I_patterns:string; const O_handle:string):string;
    function AddMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType; const A_Tindex:TF_DataType):string;
    function AddMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddMatrixDiagPartV2(const I_input:string; const I_k:string; const I_padding_value:string; const O_diagonal:string; const A_T:TF_DataType):string;
    function AddMatrixDiagPartV3(const I_input:string; const I_k:string; const I_padding_value:string; const O_diagonal:string; const A_T:TF_DataType; const A_align:string):string;
    function AddMatrixDiagV2(const I_diagonal:string; const I_k:string; const I_num_rows:string; const I_num_cols:string; const I_padding_value:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixDiagV3(const I_diagonal:string; const I_k:string; const I_num_rows:string; const I_num_cols:string; const I_padding_value:string; const O_output:string; const A_T:TF_DataType; const A_align:string):string;
    function AddMatrixExponential(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddMatrixLogarithm(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixSetDiagV2(const I_input:string; const I_diagonal:string; const I_k:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixSetDiagV3(const I_input:string; const I_diagonal:string; const I_k:string; const O_output:string; const A_T:TF_DataType; const A_align:string):string;
    function AddMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
    function AddMatrixSquareRoot(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
    function AddMax(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddMaxIntraOpParallelismDataset(const I_input_dataset:string; const I_max_intra_op_parallelism:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddMaxPool(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
    function AddMaxPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPool3DGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType; const A_TInput:TF_DataType):string;
    function AddMaxPool3DGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGradGradV2(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const I_ksize:string; const I_strides:string; const O_output:string; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGradGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_include_batch_in_index:boolean; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
    function AddMaxPoolGradV2(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const I_ksize:string; const I_strides:string; const O_output:string; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
    function AddMaxPoolGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_include_batch_in_index:boolean; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
    function AddMaxPoolV2(const I_input:string; const I_ksize:string; const I_strides:string; const O_output:string; const A_T:TF_DataType; const A_padding:string; const A_data_format:string):string;
    function AddMaxPoolWithArgmax(const I_input:string; const O_output:string; const O_argmax:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_Targmax:TF_DataType; const A_padding:string; const A_include_batch_in_index:boolean; const A_T:TF_DataType):string;
    function AddMaximum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMean(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddMerge(const IL_inputs:string; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
    function AddMergeSummary(const IL_inputs:string; const O_summary:string; const A_N:cint64):string;
    function AddMergeV2Checkpoints(const I_checkpoint_prefixes:string; const I_destination_prefix:string; const A_delete_old_dirs:boolean):string;
    function AddMfcc(const I_spectrogram:string; const I_sample_rate:string; const O_output:string; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:cint64; const A_dct_coefficient_count:cint64):string;
    function AddMin(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddMinimum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMirrorPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
    function AddMirrorPadGrad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
    function AddMlirPassthroughOp(const IL_inputs:string; const OL_outputs:string; const A_mlir_module:string; const A_Tinputs:TF_TypeList; const A_Toutputs:TF_TypeList):string;
    function AddMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddModelDataset(const I_input_dataset:string; const O_handle:string; const A_algorithm:cint64; const A_cpu_budget:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddMul(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMulNoNan(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddMultiDeviceIterator(const O_handle:string; const A_devices:TF_StringList; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddMultiDeviceIteratorFromStringHandle(const I_string_handle:string; const O_multi_device_iterator:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddMultiDeviceIteratorGetNextFromShard(const I_multi_device_iterator:string; const I_shard_num:string; const I_incarnation_id:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddMultiDeviceIteratorInit(const I_dataset:string; const I_multi_device_iterator:string; const I_max_buffer_size:string; const O_incarnation_id:string):string;
    function AddMultiDeviceIteratorToStringHandle(const I_multi_device_iterator:string; const O_string_handle:string):string;
    function AddMultinomial(const I_logits:string; const I_num_samples:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType; const A_output_dtype:TF_DataType):string;
    function AddMutableDenseHashTable(const I_empty_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
    function AddMutableDenseHashTableV2(const I_empty_key:string; const I_deleted_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
    function AddMutableHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddMutableHashTableOfTensors(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
    function AddMutableHashTableOfTensorsV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
    function AddMutableHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
    function AddMutexLock(const I_mutex:string; const O_mutex_lock:string):string;
    function AddMutexV2(const O_resource:string; const A_container:string; const A_shared_name:string):string;
    function AddNcclAllReduce(const I_input:string; const O_data:string; const A_reduction:string; const A_T:TF_DataType; const A_num_devices:cint64; const A_shared_name:string):string;
    function AddNcclBroadcast(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_shape:TF_Shape):string;
    function AddNcclReduce(const IL_input:string; const O_data:string; const A_reduction:string; const A_T:TF_DataType; const A_num_devices:cint64):string;
    function AddNdtri(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddNearestNeighbors(const I_points:string; const I_centers:string; const I_k:string; const O_nearest_center_indices:string; const O_nearest_center_distances:string):string;
    function AddNeg(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddNegTrain(const I_w_in:string; const I_w_out:string; const I_examples:string; const I_labels:string; const I_lr:string; const A_vocab_count:TF_IntList; const A_num_negative_samples:cint64):string;
    function AddNextAfter(const I_x1:string; const I_x2:string; const O_output:string; const A_T:TF_DataType):string;
    function AddNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddNoOp():string;
    function AddNonDeterministicInts(const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddNonMaxSuppression(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const O_selected_indices:string; const A_iou_threshold:real):string;
    function AddNonMaxSuppressionV2(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const O_selected_indices:string; const A_T:TF_DataType; const A_T_threshold:TF_DataType):string;
    function AddNonMaxSuppressionV3(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const I_score_threshold:string; const O_selected_indices:string; const A_T:TF_DataType; const A_T_threshold:TF_DataType):string;
    function AddNonMaxSuppressionV4(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const I_score_threshold:string; const O_selected_indices:string; const O_valid_outputs:string; const A_T:TF_DataType; const A_T_threshold:TF_DataType; const A_pad_to_max_output_size:boolean):string;
    function AddNonMaxSuppressionV5(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const I_score_threshold:string; const I_soft_nms_sigma:string; const O_selected_indices:string; const O_selected_scores:string; const O_valid_outputs:string; const A_T:TF_DataType; const A_pad_to_max_output_size:boolean):string;
    function AddNonMaxSuppressionWithOverlaps(const I_overlaps:string; const I_scores:string; const I_max_output_size:string; const I_overlap_threshold:string; const I_score_threshold:string; const O_selected_indices:string):string;
    function AddNonSerializableDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddNotEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_incompatible_shape_error:boolean):string;
    function AddNthElement(const I_input:string; const I_n:string; const O_values:string; const A_reverse:boolean; const A_T:TF_DataType):string;
    function AddOneHot(const I_indices:string; const I_depth:string; const I_on_value:string; const I_off_value:string; const O_output:string; const A_axis:cint64; const A_T:TF_DataType; const A_TI:TF_DataType):string;
    function AddOneShotIterator(const O_handle:string; const A_dataset_factory:TF_Function; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_container:string; const A_shared_name:string):string;
    function AddOnesLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddOptimizeDataset(const I_input_dataset:string; const I_optimizations:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_optimization_configs:TF_StringList):string;
    function AddOptionalFromValue(const IL_components:string; const O_optional:string; const A_Toutput_types:TF_TypeList):string;
    function AddOptionalGetValue(const I_optional:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddOptionalHasValue(const I_optional:string; const O_has_value:string):string;
    function AddOptionalNone(const O_optional:string):string;
    function AddOrderedMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapPeek(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapStage(const I_key:string; const I_indices:string; const IL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapUnstage(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOrderedMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddOutfeedDequeue(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_device_ordinal:cint64):string;
    function AddOutfeedDequeueTuple(const OL_outputs:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList; const A_device_ordinal:cint64):string;
    function AddOutfeedEnqueue(const I_input:string; const A_dtype:TF_DataType):string;
    function AddOutfeedEnqueueTuple(const IL_inputs:string; const A_dtypes:TF_TypeList):string;
    function AddPack(const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
    function AddPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
    function AddPadV2(const I_input:string; const I_paddings:string; const I_constant_values:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
    function AddPaddedBatchDataset(const I_input_dataset:string; const I_batch_size:string; const IL_padded_shapes:string; const IL_padding_values:string; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    function AddPaddedBatchDatasetV2(const I_input_dataset:string; const I_batch_size:string; const I_drop_remainder:string; const IL_padded_shapes:string; const IL_padding_values:string; const O_handle:string; const A_parallel_copy:boolean; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    function AddPaddingFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddPaddingFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddParallelConcat(const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_shape:TF_Shape):string;
    function AddParallelDynamicStitch(const IL_indices:string; const IL_data:string; const O_merged:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddParallelInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_sloppy:string; const I_buffer_output_elements:string; const I_prefetch_input_elements:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddParallelInterleaveDatasetV2(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_num_parallel_calls:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_sloppy:boolean):string;
    function AddParallelInterleaveDatasetV3(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_num_parallel_calls:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_deterministic:string; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddParallelMapDataset(const I_input_dataset:string; const I_num_parallel_calls:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean; const A_sloppy:boolean; const A_preserve_cardinality:boolean):string;
    function AddParameterizedTruncatedNormal(const I_shape:string; const I_means:string; const I_stdevs:string; const I_minvals:string; const I_maxvals:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddParseExample(const I_serialized:string; const I_names:string; const IL_sparse_keys:string; const IL_dense_keys:string; const IL_dense_defaults:string; const OL_sparse_indices:string; const OL_sparse_values:string; const OL_sparse_shapes:string; const OL_dense_values:string; const A_Nsparse:cint64; const A_Ndense:cint64; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
    function AddParseExampleDataset(const I_input_dataset:string; const I_num_parallel_calls:string; const IL_dense_defaults:string; const O_handle:string; const A_sparse_keys:TF_StringList; const A_dense_keys:TF_StringList; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_sloppy:boolean; const A_ragged_keys:TF_StringList; const A_ragged_value_types:TF_TypeList; const A_ragged_split_types:TF_TypeList):string;
    function AddParseExampleV2(const I_serialized:string; const I_names:string; const I_sparse_keys:string; const I_dense_keys:string; const I_ragged_keys:string; const IL_dense_defaults:string; const OL_sparse_indices:string; const OL_sparse_values:string; const OL_sparse_shapes:string; const OL_dense_values:string; const OL_ragged_values:string; const OL_ragged_row_splits:string; const A_Tdense:TF_TypeList; const A_num_sparse:cint64; const A_sparse_types:TF_TypeList; const A_ragged_value_types:TF_TypeList; const A_ragged_split_types:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
    function AddParseSequenceExample(const I_serialized:string; const I_debug_name:string; const IL_context_dense_defaults:string; const OL_context_sparse_indices:string; const OL_context_sparse_values:string; const OL_context_sparse_shapes:string; const OL_context_dense_values:string; const OL_feature_list_sparse_indices:string; const OL_feature_list_sparse_values:string; const OL_feature_list_sparse_shapes:string; const OL_feature_list_dense_values:string; const OL_feature_list_dense_lengths:string; const A_feature_list_dense_missing_assumed_empty:TF_StringList; const A_context_sparse_keys:TF_StringList; const A_context_dense_keys:TF_StringList; const A_feature_list_sparse_keys:TF_StringList; const A_feature_list_dense_keys:TF_StringList; const A_Ncontext_sparse:cint64; const A_Ncontext_dense:cint64; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_context_sparse_types:TF_TypeList; const A_Tcontext_dense:TF_TypeList; const A_feature_list_dense_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
    function AddParseSequenceExampleV2(const I_serialized:string; const I_debug_name:string; const I_context_sparse_keys:string; const I_context_dense_keys:string; const I_context_ragged_keys:string; const I_feature_list_sparse_keys:string; const I_feature_list_dense_keys:string; const I_feature_list_ragged_keys:string; const I_feature_list_dense_missing_assumed_empty:string; const IL_context_dense_defaults:string; const OL_context_sparse_indices:string; const OL_context_sparse_values:string; const OL_context_sparse_shapes:string; const OL_context_dense_values:string; const OL_context_ragged_values:string; const OL_context_ragged_row_splits:string; const OL_feature_list_sparse_indices:string; const OL_feature_list_sparse_values:string; const OL_feature_list_sparse_shapes:string; const OL_feature_list_dense_values:string; const OL_feature_list_dense_lengths:string; const OL_feature_list_ragged_values:string; const OL_feature_list_ragged_outer_splits:string; const OL_feature_list_ragged_inner_splits:string; const A_Ncontext_sparse:cint64; const A_Tcontext_dense:TF_TypeList; const A_context_sparse_types:TF_TypeList; const A_context_ragged_value_types:TF_TypeList; const A_context_ragged_split_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_feature_list_dense_types:TF_TypeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_ragged_value_types:TF_TypeList; const A_feature_list_ragged_split_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
    function AddParseSingleExample(const I_serialized:string; const IL_dense_defaults:string; const OL_sparse_indices:string; const OL_sparse_values:string; const OL_sparse_shapes:string; const OL_dense_values:string; const A_num_sparse:cint64; const A_sparse_keys:TF_StringList; const A_dense_keys:TF_StringList; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
    function AddParseSingleSequenceExample(const I_serialized:string; const I_feature_list_dense_missing_assumed_empty:string; const I_debug_name:string; const IL_context_sparse_keys:string; const IL_context_dense_keys:string; const IL_feature_list_sparse_keys:string; const IL_feature_list_dense_keys:string; const IL_context_dense_defaults:string; const OL_context_sparse_indices:string; const OL_context_sparse_values:string; const OL_context_sparse_shapes:string; const OL_context_dense_values:string; const OL_feature_list_sparse_indices:string; const OL_feature_list_sparse_values:string; const OL_feature_list_sparse_shapes:string; const OL_feature_list_dense_values:string; const A_Ncontext_sparse:cint64; const A_Ncontext_dense:cint64; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_context_sparse_types:TF_TypeList; const A_Tcontext_dense:TF_TypeList; const A_feature_list_dense_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
    function AddParseTensor(const I_serialized:string; const O_output:string; const A_out_type:TF_DataType):string;
    function AddPartitionedCall(const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function; const A_config:string; const A_config_proto:string; const A_executor_type:string):string;
    function AddPlaceholder(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddPlaceholderV2(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddPlaceholderWithDefault(const I_input:string; const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddPolygamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
    function AddPopulationCount(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddPow(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddPrefetchDataset(const I_input_dataset:string; const I_buffer_size:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_slack_period:cint64; const A_legacy_autotune:boolean):string;
    function AddPrelinearize(const I_input:string; const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_layout:TF_IntList):string;
    function AddPrelinearizeTuple(const IL_inputs:string; const O_output:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList; const A_layouts:TF_IntList):string;
    function AddPreventGradient(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
    function AddPrint(const I_input:string; const IL_data:string; const O_output:string; const A_T:TF_DataType; const A_U:TF_TypeList; const A_message:string; const A_first_n:cint64; const A_summarize:cint64):string;
    function AddPrintV2(const I_input:string; const A_output_stream:string; const A_end:string):string;
    function AddPriorityQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddPriorityQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
    function AddPrivateThreadPoolDataset(const I_input_dataset:string; const I_num_threads:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddProd(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddPyFunc(const IL_input:string; const OL_output:string; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
    function AddPyFuncStateless(const IL_input:string; const OL_output:string; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
    function AddQr(const I_input:string; const O_q:string; const O_r:string; const A_full_matrices:boolean; const A_T:TF_DataType):string;
    function AddQuantizeAndDequantize(const I_input:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const A_T:TF_DataType):string;
    function AddQuantizeAndDequantizeV2(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_T:TF_DataType; const A_round_mode:string; const A_narrow_range:boolean; const A_axis:cint64):string;
    function AddQuantizeAndDequantizeV3(const I_input:string; const I_input_min:string; const I_input_max:string; const I_num_bits:string; const O_output:string; const A_signed_input:boolean; const A_range_given:boolean; const A_T:TF_DataType; const A_narrow_range:boolean; const A_axis:cint64):string;
    function AddQuantizeDownAndShrinkRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizeV2(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_mode:string; const A_round_mode:string; const A_narrow_range:boolean; const A_axis:cint64; const A_ensure_minimum_range:real):string;
    function AddQuantizedAdd(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
    function AddQuantizedAvgPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
    function AddQuantizedBatchNormWithGlobalNormalization(const I_t:string; const I_t_min:string; const I_t_max:string; const I_m:string; const I_m_min:string; const I_m_max:string; const I_v:string; const I_v_min:string; const I_v_max:string; const I_beta:string; const I_beta_min:string; const I_beta_max:string; const I_gamma:string; const I_gamma_min:string; const I_gamma_max:string; const O_result:string; const O_result_min:string; const O_result_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
    function AddQuantizedBiasAdd(const I_input:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_bias:string; const I_max_bias:string; const O_output:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedConcat(const I_concat_dim:string; const IL_values:string; const IL_input_mins:string; const IL_input_maxes:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_N:cint64; const A_T:TF_DataType):string;
    function AddQuantizedConv2D(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
    function AddQuantizedConv2DAndRelu(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DAndReluAndRequantize(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DAndRequantize(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DPerChannel(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
    function AddQuantizedConv2DWithBias(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DWithBiasAndRelu(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DWithBiasAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DWithBiasAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DWithBiasSignedSumAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const I_summand:string; const I_min_summand:string; const I_max_summand:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_Tsummand:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DWithBiasSumAndRelu(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_summand:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedConv2DWithBiasSumAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const I_summand:string; const I_min_summand:string; const I_max_summand:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_Tsummand:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedDepthwiseConv2D(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
    function AddQuantizedDepthwiseConv2DWithBias(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
    function AddQuantizedDepthwiseConv2DWithBiasAndRelu(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedDepthwiseConv2DWithBiasAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
    function AddQuantizedInstanceNorm(const I_x:string; const I_x_min:string; const I_x_max:string; const O_y:string; const O_y_min:string; const O_y_max:string; const A_T:TF_DataType; const A_output_range_given:boolean; const A_given_y_min:real; const A_given_y_max:real; const A_variance_epsilon:real; const A_min_separation:real):string;
    function AddQuantizedMatMul(const I_a:string; const I_b:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_Tactivation:TF_DataType):string;
    function AddQuantizedMatMulWithBias(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Tbias:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
    function AddQuantizedMatMulWithBiasAndRelu(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
    function AddQuantizedMatMulWithBiasAndReluAndRequantize(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Tbias:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
    function AddQuantizedMatMulWithBiasAndRequantize(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Tbias:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
    function AddQuantizedMaxPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
    function AddQuantizedMul(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
    function AddQuantizedRelu(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedRelu6(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedReluX(const I_features:string; const I_max_value:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddQuantizedReshape(const I_tensor:string; const I_shape:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
    function AddQuantizedResizeBilinear(const I_images:string; const I_size:string; const I_min:string; const I_max:string; const O_resized_images:string; const O_out_min:string; const O_out_max:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddQueueClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
    function AddQueueCloseV2(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
    function AddQueueDequeue(const I_handle:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueMany(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueManyV2(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueUpTo(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueUpToV2(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueDequeueV2(const I_handle:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueue(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueueMany(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueueManyV2(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueEnqueueV2(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
    function AddQueueIsClosed(const I_handle:string; const O_is_closed:string):string;
    function AddQueueIsClosedV2(const I_handle:string; const O_is_closed:string):string;
    function AddQueueSize(const I_handle:string; const O_size:string):string;
    function AddQueueSizeV2(const I_handle:string; const O_size:string):string;
    function AddRFFT(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
    function AddRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
    function AddRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
    function AddRGBToHSV(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRaggedGather(const I_params_dense_values:string; const I_indices:string; const IL_params_nested_splits:string; const O_output_dense_values:string; const OL_output_nested_splits:string; const A_Tvalues:TF_DataType; const A_Tindices:TF_DataType; const A_Tsplits:TF_DataType; const A_PARAMS_RAGGED_RANK:cint64; const A_OUTPUT_RAGGED_RANK:cint64):string;
    function AddRaggedRange(const I_starts:string; const I_limits:string; const I_deltas:string; const O_rt_nested_splits:string; const O_rt_dense_values:string; const A_T:TF_DataType; const A_Tsplits:TF_DataType):string;
    function AddRaggedTensorFromVariant(const I_encoded_ragged:string; const O_output_dense_values:string; const OL_output_nested_splits:string; const A_input_ragged_rank:cint64; const A_output_ragged_rank:cint64; const A_Tvalues:TF_DataType; const A_Tsplits:TF_DataType):string;
    function AddRaggedTensorToSparse(const I_rt_dense_values:string; const IL_rt_nested_splits:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_dense_shape:string; const A_RAGGED_RANK:cint64; const A_T:TF_DataType; const A_Tsplits:TF_DataType):string;
    function AddRaggedTensorToTensor(const I_shape:string; const I_values:string; const I_default_value:string; const IL_row_partition_tensors:string; const O_result:string; const A_T:TF_DataType; const A_Tindex:TF_DataType; const A_Tshape:TF_DataType; const A_num_row_partition_tensors:cint64; const A_row_partition_types:TF_StringList):string;
    function AddRaggedTensorToVariant(const I_rt_dense_values:string; const IL_rt_nested_splits:string; const O_encoded_ragged:string; const A_RAGGED_RANK:cint64; const A_Tvalues:TF_DataType; const A_Tsplits:TF_DataType; const A_batched_input:boolean):string;
    function AddRandomCrop(const I_image:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64):string;
    function AddRandomDataset(const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddRandomGamma(const I_shape:string; const I_alpha:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_T:TF_DataType):string;
    function AddRandomGammaGrad(const I_alpha:string; const I_sample:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRandomPoisson(const I_shape:string; const I_rate:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_dtype:TF_DataType):string;
    function AddRandomPoissonV2(const I_shape:string; const I_rate:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_R:TF_DataType; const A_dtype:TF_DataType):string;
    function AddRandomShuffle(const I_value:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
    function AddRandomShuffleQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
    function AddRandomShuffleQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
    function AddRandomStandardNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddRandomUniform(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddRandomUniformInt(const I_shape:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_Tout:TF_DataType; const A_T:TF_DataType):string;
    function AddRange(const I_start:string; const I_limit:string; const I_delta:string; const O_output:string; const A_Tidx:TF_DataType):string;
    function AddRangeDataset(const I_start:string; const I_stop:string; const I_step:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddRank(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddReadFile(const I_filename:string; const O_contents:string):string;
    function AddReadVariableOp(const I_resource:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddReaderNumRecordsProduced(const I_reader_handle:string; const O_records_produced:string):string;
    function AddReaderNumRecordsProducedV2(const I_reader_handle:string; const O_records_produced:string):string;
    function AddReaderNumWorkUnitsCompleted(const I_reader_handle:string; const O_units_completed:string):string;
    function AddReaderNumWorkUnitsCompletedV2(const I_reader_handle:string; const O_units_completed:string):string;
    function AddReaderRead(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
    function AddReaderReadUpTo(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
    function AddReaderReadUpToV2(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
    function AddReaderReadV2(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
    function AddReaderReset(const I_reader_handle:string):string;
    function AddReaderResetV2(const I_reader_handle:string):string;
    function AddReaderRestoreState(const I_reader_handle:string; const I_state:string):string;
    function AddReaderRestoreStateV2(const I_reader_handle:string; const I_state:string):string;
    function AddReaderSerializeState(const I_reader_handle:string; const O_state:string):string;
    function AddReaderSerializeStateV2(const I_reader_handle:string; const O_state:string):string;
    function AddReal(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
    function AddRealDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddRebatchDataset(const I_input_dataset:string; const I_num_replicas:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_fallback:boolean):string;
    function AddReciprocal(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddReciprocalGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
    function AddRecordInput(const O_records:string; const A_file_pattern:string; const A_file_random_seed:cint64; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:cint64; const A_file_parallelism:cint64; const A_batch_size:cint64; const A_compression_type:string):string;
    function AddRecv(const O_tensor:string; const A_tensor_type:TF_DataType; const A_tensor_name:string; const A_send_device:string; const A_send_device_incarnation:cint64; const A_recv_device:string; const A_client_terminated:boolean):string;
    function AddRecvTPUEmbeddingActivations(const OL_outputs:string; const A_num_outputs:cint64; const A_config:string):string;
    function AddReduceDataset(const I_input_dataset:string; const IL_initial_state:string; const IL_other_arguments:string; const OL_components:string; const A_f:TF_Function; const A_Tstate:TF_TypeList; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean):string;
    function AddReduceJoin(const I_inputs:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_separator:string):string;
    function AddRefEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
    function AddRefExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRefIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRefMerge(const IL_inputs:string; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
    function AddRefNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
    function AddRefSelect(const I_index:string; const IL_inputs:string; const O_output:string; const A_T:TF_DataType; const A_N:cint64):string;
    function AddRefSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
    function AddRegexFullMatch(const I_input:string; const I_pattern:string; const O_output:string):string;
    function AddRegexReplace(const I_input:string; const I_pattern:string; const I_rewrite:string; const O_output:string; const A_replace_global:boolean):string;
    function AddRelu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddRelu6(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddRelu6Grad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddReluGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddRemoteCall(const I_target:string; const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function):string;
    function AddRemoteFusedGraphExecute(const IL_inputs:string; const OL_outputs:string; const A_Tinputs:TF_TypeList; const A_Toutputs:TF_TypeList; const A_serialized_remote_fused_graph_execute_info:string):string;
    function AddRepeatDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddRequantizationRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType):string;
    function AddRequantizationRangePerChannel(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_clip_value_max:real):string;
    function AddRequantize(const I_input:string; const I_input_min:string; const I_input_max:string; const I_requested_output_min:string; const I_requested_output_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
    function AddRequantizePerChannel(const I_input:string; const I_input_min:string; const I_input_max:string; const I_requested_output_min:string; const I_requested_output_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddReshape(const I_tensor:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
    function AddResizeArea(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
    function AddResizeBicubic(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddResizeBicubicGrad(const I_grads:string; const I_original_image:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddResizeBilinear(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddResizeBilinearGrad(const I_grads:string; const I_original_image:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddResizeNearestNeighbor(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddResizeNearestNeighborGrad(const I_grads:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
    function AddResourceAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient:string; const A_dtype:TF_DataType):string;
    function AddResourceAccumulatorNumAccumulated(const I_handle:string; const O_num_accumulated:string):string;
    function AddResourceAccumulatorSetGlobalStep(const I_handle:string; const I_new_global_step:string):string;
    function AddResourceAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_average:string; const A_dtype:TF_DataType):string;
    function AddResourceApplyAdaMax(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddResourceApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddResourceApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceApplyAdamWithAmsgrad(const I_var:string; const I_m:string; const I_v:string; const I_vhat:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyAddSign(const I_var:string; const I_m:string; const I_lr:string; const I_alpha:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyKerasMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceApplyPowerSign(const I_var:string; const I_m:string; const I_lr:string; const I_logbase:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):string;
    function AddResourceCountUpTo(const I_resource:string; const O_output:string; const A_limit:cint64; const A_T:TF_DataType):string;
    function AddResourceGather(const I_resource:string; const I_indices:string; const O_output:string; const A_batch_dims:cint64; const A_validate_indices:boolean; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceGatherNd(const I_resource:string; const I_indices:string; const O_output:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterAdd(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterDiv(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterMax(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterMin(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterMul(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterNdAdd(const I_ref:string; const I_indices:string; const I_updates:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceScatterNdSub(const I_ref:string; const I_indices:string; const I_updates:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceScatterNdUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceScatterSub(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceScatterUpdate(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddResourceSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddResourceSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddResourceSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyKerasMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddResourceSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddResourceStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddRestore(const I_file_pattern:string; const I_tensor_name:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
    function AddRestoreSlice(const I_file_pattern:string; const I_tensor_name:string; const I_shape_and_slice:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
    function AddRestoreV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const OL_tensors:string; const A_dtypes:TF_TypeList):string;
    function AddRetrieveTPUEmbeddingADAMParameters(const O_parameters:string; const O_momenta:string; const O_velocities:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingADAMParametersGradAccumDebug(const O_parameters:string; const O_momenta:string; const O_velocities:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingAdadeltaParameters(const O_parameters:string; const O_accumulators:string; const O_updates:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_updates:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingAdagradParameters(const O_parameters:string; const O_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingAdagradParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingCenteredRMSPropParameters(const O_parameters:string; const O_ms:string; const O_mom:string; const O_mg:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingFTRLParameters(const O_parameters:string; const O_accumulators:string; const O_linears:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingFTRLParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_linears:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingMDLAdagradLightParameters(const O_parameters:string; const O_accumulators:string; const O_weights:string; const O_benefits:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingMomentumParameters(const O_parameters:string; const O_momenta:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingMomentumParametersGradAccumDebug(const O_parameters:string; const O_momenta:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingProximalAdagradParameters(const O_parameters:string; const O_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingRMSPropParameters(const O_parameters:string; const O_ms:string; const O_mom:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(const O_parameters:string; const O_ms:string; const O_mom:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddRetrieveTPUEmbeddingStochasticGradientDescentParameters(const O_parameters:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
    function AddReverse(const I_tensor:string; const I_dims:string; const O_output:string; const A_T:TF_DataType):string;
    function AddReverseSequence(const I_input:string; const I_seq_lengths:string; const O_output:string; const A_seq_dim:cint64; const A_batch_dim:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
    function AddReverseV2(const I_tensor:string; const I_axis:string; const O_output:string; const A_Tidx:TF_DataType; const A_T:TF_DataType):string;
    function AddRightShift(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddRint(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddRngSkip(const I_resource:string; const I_algorithm:string; const I_delta:string):string;
    function AddRoll(const I_input:string; const I_shift:string; const I_axis:string; const O_output:string; const A_T:TF_DataType; const A_Tshift:TF_DataType; const A_Taxis:TF_DataType):string;
    function AddRound(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddRpc(const I_address:string; const I_method:string; const I_request:string; const O_response:string; const A_protocol:string; const A_fail_fast:boolean; const A_timeout_in_ms:cint64):string;
    function AddRsqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddRsqrtGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSampleDistortedBoundingBox(const I_image_size:string; const I_bounding_boxes:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_min_object_covered:real; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
    function AddSampleDistortedBoundingBoxV2(const I_image_size:string; const I_bounding_boxes:string; const I_min_object_covered:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
    function AddSamplingDataset(const I_input_dataset:string; const I_rate:string; const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSave(const I_filename:string; const I_tensor_names:string; const IL_data:string; const A_T:TF_TypeList):string;
    function AddSaveSlices(const I_filename:string; const I_tensor_names:string; const I_shapes_and_slices:string; const IL_data:string; const A_T:TF_TypeList):string;
    function AddSaveV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const IL_tensors:string; const A_dtypes:TF_TypeList):string;
    function AddScalarSummary(const I_tags:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
    function AddScaleAndTranslate(const I_images:string; const I_size:string; const I_scale:string; const I_translation:string; const O_resized_images:string; const A_T:TF_DataType; const A_kernel_type:string; const A_antialias:boolean):string;
    function AddScaleAndTranslateGrad(const I_grads:string; const I_original_image:string; const I_scale:string; const I_translation:string; const O_output:string; const A_T:TF_DataType; const A_kernel_type:string; const A_antialias:boolean):string;
    function AddScanDataset(const I_input_dataset:string; const IL_initial_state:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Tstate:TF_TypeList; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean; const A_use_default_device:boolean):string;
    function AddScatterAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterDiv(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterMax(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterMin(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterMul(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterNd(const I_indices:string; const I_updates:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddScatterNdAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterNdNonAliasingAdd(const I_input:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddScatterNdSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterNdUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddScatterUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSdcaFprint(const I_input:string; const O_output:string):string;
    function AddSdcaOptimizer(const I_example_weights:string; const I_example_labels:string; const I_example_state_data:string; const IL_sparse_example_indices:string; const IL_sparse_feature_indices:string; const IL_sparse_feature_values:string; const IL_dense_features:string; const IL_sparse_indices:string; const IL_sparse_weights:string; const IL_dense_weights:string; const O_out_example_state_data:string; const OL_out_delta_sparse_weights:string; const OL_out_delta_dense_weights:string; const A_loss_type:string; const A_adaptative:boolean; const A_num_sparse_features:cint64; const A_num_sparse_features_with_values:cint64; const A_num_dense_features:cint64; const A_l1:real; const A_l2:real; const A_num_loss_partitions:cint64; const A_num_inner_iterations:cint64):string;
    function AddSdcaOptimizerV2(const I_example_weights:string; const I_example_labels:string; const I_example_state_data:string; const IL_sparse_example_indices:string; const IL_sparse_feature_indices:string; const IL_sparse_feature_values:string; const IL_dense_features:string; const IL_sparse_indices:string; const IL_sparse_weights:string; const IL_dense_weights:string; const O_out_example_state_data:string; const OL_out_delta_sparse_weights:string; const OL_out_delta_dense_weights:string; const A_loss_type:string; const A_adaptive:boolean; const A_num_sparse_features:cint64; const A_num_sparse_features_with_values:cint64; const A_num_dense_features:cint64; const A_l1:real; const A_l2:real; const A_num_loss_partitions:cint64; const A_num_inner_iterations:cint64):string;
    function AddSdcaShrinkL1(const IL_weights:string; const A_num_features:cint64; const A_l1:real; const A_l2:real):string;
    function AddSegmentMax(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentMean(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentMin(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentProd(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSegmentSum(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSelect(const I_condition:string; const I_t:string; const I_e:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSelectV2(const I_condition:string; const I_t:string; const I_e:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
    function AddSelu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddSeluGrad(const I_gradients:string; const I_outputs:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddSend(const I_tensor:string; const A_T:TF_DataType; const A_tensor_name:string; const A_send_device:string; const A_send_device_incarnation:cint64; const A_recv_device:string; const A_client_terminated:boolean):string;
    function AddSendTPUEmbeddingGradients(const IL_inputs:string; const IL_learning_rates:string; const A_N:cint64; const A_NN:cint64; const A_config:string):string;
    function AddSerializeIterator(const I_resource_handle:string; const O_serialized:string; const A_external_state_policy:cint64):string;
    function AddSerializeManySparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddSerializeSparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddSerializeTensor(const I_tensor:string; const O_serialized:string; const A_T:TF_DataType):string;
    function AddSetSize(const I_set_indices:string; const I_set_values:string; const I_set_shape:string; const O_size:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddSetStatsAggregatorDataset(const I_input_dataset:string; const I_stats_aggregator:string; const I_tag:string; const I_counter_prefix:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddShape(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddShapeN(const IL_input:string; const OL_output:string; const A_N:cint64; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddShardDataset(const I_input_dataset:string; const I_num_shards:string; const I_index:string; const O_handle:string; const A_require_non_empty:boolean; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddShardedFilename(const I_basename:string; const I_shard:string; const I_num_shards:string; const O_filename:string):string;
    function AddShardedFilespec(const I_basename:string; const I_num_shards:string; const O_filename:string):string;
    function AddShuffleAndRepeatDataset(const I_input_dataset:string; const I_buffer_size:string; const I_seed:string; const I_seed2:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddShuffleDataset(const I_input_dataset:string; const I_buffer_size:string; const I_seed:string; const I_seed2:string; const O_handle:string; const A_reshuffle_each_iteration:boolean; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddShuffleDatasetV2(const I_input_dataset:string; const I_buffer_size:string; const I_seed_generator:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddShutdownDistributedTPU():string;
    function AddSigmoid(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSigmoidGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSign(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddSkipDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSkipgram(const O_vocab_word:string; const O_vocab_freq:string; const O_words_per_epoch:string; const O_current_epoch:string; const O_total_words_processed:string; const O_examples:string; const O_labels:string; const A_filename:string; const A_batch_size:cint64; const A_window_size:cint64; const A_min_count:cint64; const A_subsample:real):string;
    function AddSleepDataset(const I_input_dataset:string; const I_sleep_microseconds:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSlice(const I_input:string; const I_begin:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType):string;
    function AddSlidingWindowDataset(const I_input_dataset:string; const I_window_size:string; const I_window_shift:string; const I_window_stride:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSnapshot(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSnapshotDataset(const I_input_dataset:string; const I_path:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_compression:string; const A_reader_path_prefix:string; const A_writer_path_prefix:string; const A_shard_size_bytes:cint64; const A_pending_snapshot_expiry_seconds:cint64; const A_num_reader_threads:cint64; const A_reader_buffer_size:cint64; const A_num_writer_threads:cint64; const A_writer_buffer_size:cint64; const A_shuffle_on_read:boolean; const A_seed:cint64; const A_seed2:cint64; const A_mode:string; const A_snapshot_name:string):string;
    function AddSobolSample(const I_dim:string; const I_num_results:string; const I_skip:string; const O_samples:string; const A_dtype:TF_DataType):string;
    function AddSoftmax(const I_logits:string; const O_softmax:string; const A_T:TF_DataType):string;
    function AddSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType):string;
    function AddSoftplus(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddSoftplusGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddSoftsign(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
    function AddSoftsignGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
    function AddSpaceToBatch(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_block_size:cint64):string;
    function AddSpaceToBatchND(const I_input:string; const I_block_shape:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tpaddings:TF_DataType):string;
    function AddSpaceToDepth(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_data_format:string):string;
    function AddSparseAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient_indices:string; const I_gradient_values:string; const I_gradient_shape:string; const A_dtype:TF_DataType; const A_has_known_shape:boolean):string;
    function AddSparseAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_indices:string; const O_values:string; const O_shape:string; const A_dtype:TF_DataType):string;
    function AddSparseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const I_thresh:string; const O_sum_indices:string; const O_sum_values:string; const O_sum_shape:string; const A_T:TF_DataType; const A_Treal:TF_DataType):string;
    function AddSparseAddGrad(const I_backprop_val_grad:string; const I_a_indices:string; const I_b_indices:string; const I_sum_indices:string; const O_a_val_grad:string; const O_b_val_grad:string; const A_T:TF_DataType):string;
    function AddSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
    function AddSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
    function AddSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
    function AddSparseConcat(const IL_indices:string; const IL_values:string; const IL_shapes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_concat_dim:cint64; const A_N:cint64; const A_T:TF_DataType):string;
    function AddSparseConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):string;
    function AddSparseCross(const IL_indices:string; const IL_values:string; const IL_shapes:string; const IL_dense_inputs:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_N:cint64; const A_hashed_output:boolean; const A_num_buckets:cint64; const A_hash_key:cint64; const A_sparse_types:TF_TypeList; const A_dense_types:TF_TypeList; const A_out_type:TF_DataType; const A_internal_type:TF_DataType):string;
    function AddSparseDenseCwiseAdd(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseDenseCwiseDiv(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseDenseCwiseMul(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseFillEmptyRows(const I_indices:string; const I_values:string; const I_dense_shape:string; const I_default_value:string; const O_output_indices:string; const O_output_values:string; const O_empty_row_indicator:string; const O_reverse_index_map:string; const A_T:TF_DataType):string;
    function AddSparseFillEmptyRowsGrad(const I_reverse_index_map:string; const I_grad_values:string; const O_d_values:string; const O_d_default_value:string; const A_T:TF_DataType):string;
    function AddSparseMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const A_Ta:TF_DataType; const A_Tb:TF_DataType):string;
    function AddSparseMatrixAdd(const I_a:string; const I_b:string; const I_alpha:string; const I_beta:string; const O_c:string; const A_T:TF_DataType):string;
    function AddSparseMatrixMatMul(const I_a:string; const I_b:string; const O_output:string; const A_T:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const A_transpose_output:boolean; const A_conjugate_output:boolean):string;
    function AddSparseMatrixMul(const I_a:string; const I_b:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseMatrixNNZ(const I_sparse_matrix:string; const O_nnz:string):string;
    function AddSparseMatrixOrderingAMD(const I_input:string; const O_output:string):string;
    function AddSparseMatrixSoftmax(const I_logits:string; const O_softmax:string; const A_type:TF_DataType):string;
    function AddSparseMatrixSoftmaxGrad(const I_softmax:string; const I_grad_softmax:string; const O_gradient:string; const A_type:TF_DataType):string;
    function AddSparseMatrixSparseCholesky(const I_input:string; const I_permutation:string; const O_output:string; const A_type:TF_DataType):string;
    function AddSparseMatrixSparseMatMul(const I_a:string; const I_b:string; const O_c:string; const A_type:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean):string;
    function AddSparseMatrixTranspose(const I_input:string; const O_output:string; const A_conjugate:boolean; const A_type:TF_DataType):string;
    function AddSparseMatrixZeros(const I_dense_shape:string; const O_sparse_matrix:string; const A_type:TF_DataType):string;
    function AddSparseReduceMax(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReduceMaxSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReduceSum(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReduceSumSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
    function AddSparseReorder(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
    function AddSparseReshape(const I_input_indices:string; const I_input_shape:string; const I_new_shape:string; const O_output_indices:string; const O_output_shape:string):string;
    function AddSparseSegmentMean(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentMeanGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentMeanWithNumSegments(const I_data:string; const I_indices:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddSparseSegmentSqrtN(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentSqrtNGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentSqrtNWithNumSegments(const I_data:string; const I_indices:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddSparseSegmentSum(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSparseSegmentSumWithNumSegments(const I_data:string; const I_indices:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddSparseSlice(const I_indices:string; const I_values:string; const I_shape:string; const I_start:string; const I_size:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_T:TF_DataType):string;
    function AddSparseSliceGrad(const I_backprop_val_grad:string; const I_input_indices:string; const I_input_start:string; const I_output_indices:string; const O_val_grad:string; const A_T:TF_DataType):string;
    function AddSparseSoftmax(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const O_output:string; const A_T:TF_DataType):string;
    function AddSparseSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType; const A_Tlabels:TF_DataType):string;
    function AddSparseSparseMaximum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
    function AddSparseSparseMinimum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
    function AddSparseSplit(const I_split_dim:string; const I_indices:string; const I_values:string; const I_shape:string; const OL_output_indices:string; const OL_output_values:string; const OL_output_shape:string; const A_num_split:cint64; const A_T:TF_DataType):string;
    function AddSparseTensorDenseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSparseTensorDenseMatMul(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_product:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_adjoint_a:boolean; const A_adjoint_b:boolean):string;
    function AddSparseTensorSliceDataset(const I_indices:string; const I_values:string; const I_dense_shape:string; const O_handle:string; const A_Tvalues:TF_DataType):string;
    function AddSparseTensorToCSRSparseMatrix(const I_indices:string; const I_values:string; const I_dense_shape:string; const O_sparse_matrix:string; const A_T:TF_DataType):string;
    function AddSparseToDense(const I_sparse_indices:string; const I_output_shape:string; const I_sparse_values:string; const I_default_value:string; const O_dense:string; const A_validate_indices:boolean; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddSparseToSparseSetOperation(const I_set1_indices:string; const I_set1_values:string; const I_set1_shape:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
    function AddSpence(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSplit(const I_split_dim:string; const I_value:string; const OL_output:string; const A_num_split:cint64; const A_T:TF_DataType):string;
    function AddSplitV(const I_value:string; const I_size_splits:string; const I_split_dim:string; const OL_output:string; const A_num_split:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
    function AddSqlDataset(const I_driver_name:string; const I_data_source_name:string; const I_query:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddSqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSqrtGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSquare(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddSquaredDifference(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSqueeze(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_squeeze_dims:TF_IntList):string;
    function AddStack(const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
    function AddStackClose(const I_handle:string):string;
    function AddStackCloseV2(const I_handle:string):string;
    function AddStackPop(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
    function AddStackPopV2(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
    function AddStackPush(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
    function AddStackPushV2(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
    function AddStackV2(const I_max_size:string; const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
    function AddStage(const IL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStageClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStagePeek(const I_index:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStageSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddStatefulPartitionedCall(const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function; const A_config:string; const A_config_proto:string; const A_executor_type:string):string;
    function AddStatefulRandomBinomial(const I_resource:string; const I_algorithm:string; const I_shape:string; const I_counts:string; const I_probs:string; const O_output:string; const A_S:TF_DataType; const A_T:TF_DataType; const A_dtype:TF_DataType):string;
    function AddStatefulStandardNormal(const I_resource:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddStatefulStandardNormalV2(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddStatefulTruncatedNormal(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddStatefulUniform(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddStatefulUniformFullInt(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddStatefulUniformInt(const I_resource:string; const I_algorithm:string; const I_shape:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
    function AddStatelessIf(const I_cond:string; const IL_input:string; const OL_output:string; const A_Tcond:TF_DataType; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_then_branch:TF_Function; const A_else_branch:TF_Function; const A_output_shapes:TF_ShapeList):string;
    function AddStatelessMultinomial(const I_logits:string; const I_num_samples:string; const I_seed:string; const O_output:string; const A_T:TF_DataType; const A_Tseed:TF_DataType; const A_output_dtype:TF_DataType):string;
    function AddStatelessRandomBinomial(const I_shape:string; const I_seed:string; const I_counts:string; const I_probs:string; const O_output:string; const A_S:TF_DataType; const A_Tseed:TF_DataType; const A_T:TF_DataType; const A_dtype:TF_DataType):string;
    function AddStatelessRandomGammaV2(const I_shape:string; const I_seed:string; const I_alpha:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
    function AddStatelessRandomNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
    function AddStatelessRandomPoisson(const I_shape:string; const I_seed:string; const I_lam:string; const O_output:string; const A_Rtype:TF_DataType; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
    function AddStatelessRandomUniform(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
    function AddStatelessRandomUniformInt(const I_shape:string; const I_seed:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
    function AddStatelessTruncatedNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
    function AddStatelessWhile(const IL_input:string; const OL_output:string; const A_T:TF_TypeList; const A_cond:TF_Function; const A_body:TF_Function; const A_output_shapes:TF_ShapeList; const A_parallel_iterations:cint64):string;
    function AddStaticRegexFullMatch(const I_input:string; const O_output:string; const A_pattern:string):string;
    function AddStaticRegexReplace(const I_input:string; const O_output:string; const A_pattern:string; const A_rewrite:string; const A_replace_global:boolean):string;
    function AddStatsAggregatorHandle(const O_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddStatsAggregatorHandleV2(const O_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddStatsAggregatorSetSummaryWriter(const I_stats_aggregator:string; const I_summary:string):string;
    function AddStatsAggregatorSummary(const I_iterator:string; const O_summary:string):string;
    function AddStopGradient(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddStridedSlice(const I_input:string; const I_begin:string; const I_end:string; const I_strides:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddStridedSliceGrad(const I_shape:string; const I_begin:string; const I_end:string; const I_strides:string; const I_dy:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddStringFormat(const IL_inputs:string; const O_output:string; const A_T:TF_TypeList; const A_template:string; const A_placeholder:string; const A_summarize:cint64):string;
    function AddStringJoin(const IL_inputs:string; const O_output:string; const A_N:cint64; const A_separator:string):string;
    function AddStringLength(const I_input:string; const O_output:string; const A_unit:string):string;
    function AddStringLower(const I_input:string; const O_output:string; const A_encoding:string):string;
    function AddStringNGrams(const I_data:string; const I_data_splits:string; const O_ngrams:string; const O_ngrams_splits:string; const A_separator:string; const A_ngram_widths:TF_IntList; const A_left_pad:string; const A_right_pad:string; const A_pad_width:cint64; const A_preserve_short_sequences:boolean; const A_Tsplits:TF_DataType):string;
    function AddStringSplit(const I_input:string; const I_delimiter:string; const O_indices:string; const O_values:string; const O_shape:string; const A_skip_empty:boolean):string;
    function AddStringSplitV2(const I_input:string; const I_sep:string; const O_indices:string; const O_values:string; const O_shape:string; const A_maxsplit:cint64):string;
    function AddStringStrip(const I_input:string; const O_output:string):string;
    function AddStringToHashBucket(const I_string_tensor:string; const O_output:string; const A_num_buckets:cint64):string;
    function AddStringToHashBucketFast(const I_input:string; const O_output:string; const A_num_buckets:cint64):string;
    function AddStringToHashBucketStrong(const I_input:string; const O_output:string; const A_num_buckets:cint64; const A_key:TF_IntList):string;
    function AddStringToNumber(const I_string_tensor:string; const O_output:string; const A_out_type:TF_DataType):string;
    function AddStringUpper(const I_input:string; const O_output:string; const A_encoding:string):string;
    function AddSub(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddSubstr(const I_input:string; const I_pos:string; const I_len:string; const O_output:string; const A_T:TF_DataType; const A_unit:string):string;
    function AddSum(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
    function AddSummaryWriter(const O_writer:string; const A_shared_name:string; const A_container:string):string;
    function AddSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
    function AddSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
    function AddSymbolicGradient(const IL_input:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function):string;
    function AddTFRecordDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const O_handle:string):string;
    function AddTFRecordReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
    function AddTFRecordReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
    function AddTPUCompilationResult(const O_output:string):string;
    function AddTPUEmbeddingActivations(const I_embedding_variable:string; const I_sliced_activations:string; const O_output:string; const A_table_id:cint64; const A_lookup_id:cint64):string;
    function AddTPUOrdinalSelector(const O_device_ordinals:string):string;
    function AddTPUPartitionedCall(const I_device_ordinal:string; const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function; const A_autotuner_thresh:cint64):string;
    function AddTPUReplicateMetadata(const A_num_replicas:cint64; const A_num_cores_per_replica:cint64; const A_topology:string; const A_use_tpu:boolean; const A_device_assignment:TF_IntList; const A_computation_shape:TF_IntList; const A_host_compute_core:TF_StringList; const A_padding_map:TF_StringList; const A_step_marker_location:string; const A_allow_soft_placement:boolean):string;
    function AddTPUReplicatedInput(const IL_inputs:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_is_mirrored_variable:boolean; const A_index:cint64):string;
    function AddTPUReplicatedOutput(const I_input:string; const OL_outputs:string; const A_num_replicas:cint64; const A_T:TF_DataType):string;
    function AddTakeDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTakeManySparseFromTensorsMap(const I_sparse_handles:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddTakeWhileDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddTanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddTanhGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
    function AddTemporaryVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):string;
    function AddTensorArray(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape):string;
    function AddTensorArrayClose(const I_handle:string):string;
    function AddTensorArrayCloseV2(const I_handle:string):string;
    function AddTensorArrayCloseV3(const I_handle:string):string;
    function AddTensorArrayConcat(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
    function AddTensorArrayConcatV2(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
    function AddTensorArrayConcatV3(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
    function AddTensorArrayGather(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayGatherV2(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayGatherV3(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayGrad(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
    function AddTensorArrayGradV2(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
    function AddTensorArrayGradV3(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const O_flow_out:string; const A_source:string):string;
    function AddTensorArrayGradWithShape(const I_handle:string; const I_flow_in:string; const I_shape_to_prepend:string; const O_grad_handle:string; const O_flow_out:string; const A_source:string):string;
    function AddTensorArrayPack(const I_handle:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorArrayRead(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddTensorArrayReadV2(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddTensorArrayReadV3(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
    function AddTensorArrayScatter(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayScatterV2(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayScatterV3(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArraySize(const I_handle:string; const I_flow_in:string; const O_size:string):string;
    function AddTensorArraySizeV2(const I_handle:string; const I_flow_in:string; const O_size:string):string;
    function AddTensorArraySizeV3(const I_handle:string; const I_flow_in:string; const O_size:string):string;
    function AddTensorArraySplit(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArraySplitV2(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArraySplitV3(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayUnpack(const I_handle:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayV2(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string):string;
    function AddTensorArrayV3(const I_size:string; const O_handle:string; const O_flow:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_identical_element_shapes:boolean; const A_tensor_array_name:string):string;
    function AddTensorArrayWrite(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayWriteV2(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorArrayWriteV3(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
    function AddTensorDataset(const IL_components:string; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTensorForestCreateTreeVariable(const I_tree_handle:string; const I_tree_config:string):string;
    function AddTensorForestTreeDeserialize(const I_tree_handle:string; const I_tree_config:string):string;
    function AddTensorForestTreeIsInitializedOp(const I_tree_handle:string; const O_is_initialized:string):string;
    function AddTensorForestTreePredict(const I_tree_handle:string; const I_dense_features:string; const O_logits:string; const A_logits_dimension:cint64):string;
    function AddTensorForestTreeResourceHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string):string;
    function AddTensorForestTreeSerialize(const I_tree_handle:string; const O_tree_config:string):string;
    function AddTensorForestTreeSize(const I_tree_handle:string; const O_tree_size:string):string;
    function AddTensorListConcat(const I_input_handle:string; const O_tensor:string; const O_lengths:string; const A_element_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
    function AddTensorListConcatLists(const I_input_a:string; const I_input_b:string; const O_output:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListConcatV2(const I_input_handle:string; const I_element_shape:string; const I_leading_dims:string; const O_tensor:string; const O_lengths:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddTensorListElementShape(const I_input_handle:string; const O_element_shape:string; const A_shape_type:TF_DataType):string;
    function AddTensorListFromTensor(const I_tensor:string; const I_element_shape:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddTensorListGather(const I_input_handle:string; const I_indices:string; const I_element_shape:string; const O_values:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListGetItem(const I_input_handle:string; const I_index:string; const I_element_shape:string; const O_item:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListLength(const I_input_handle:string; const O_length:string):string;
    function AddTensorListPopBack(const I_input_handle:string; const I_element_shape:string; const O_output_handle:string; const O_tensor:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListPushBack(const I_input_handle:string; const I_tensor:string; const O_output_handle:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListPushBackBatch(const I_input_handles:string; const I_tensor:string; const O_output_handles:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListReserve(const I_element_shape:string; const I_num_elements:string; const O_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddTensorListResize(const I_input_handle:string; const I_size:string; const O_output_handle:string):string;
    function AddTensorListScatter(const I_tensor:string; const I_indices:string; const I_element_shape:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddTensorListScatterIntoExistingList(const I_input_handle:string; const I_tensor:string; const I_indices:string; const O_output_handle:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListScatterV2(const I_tensor:string; const I_indices:string; const I_element_shape:string; const I_num_elements:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddTensorListSetItem(const I_input_handle:string; const I_index:string; const I_item:string; const O_output_handle:string; const A_element_dtype:TF_DataType):string;
    function AddTensorListSplit(const I_tensor:string; const I_element_shape:string; const I_lengths:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
    function AddTensorListStack(const I_input_handle:string; const I_element_shape:string; const O_tensor:string; const A_element_dtype:TF_DataType; const A_num_elements:cint64):string;
    function AddTensorScatterAdd(const I_tensor:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddTensorScatterSub(const I_tensor:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddTensorScatterUpdate(const I_tensor:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
    function AddTensorSliceDataset(const IL_components:string; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddTensorStridedSliceUpdate(const I_input:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
    function AddTensorSummary(const I_tensor:string; const O_summary:string; const A_T:TF_DataType; const A_description:string; const A_labels:TF_StringList; const A_display_name:string):string;
    function AddTensorSummaryV2(const I_tag:string; const I_tensor:string; const I_serialized_summary_metadata:string; const O_summary:string; const A_T:TF_DataType):string;
    function AddTextLineDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const O_handle:string):string;
    function AddTextLineReader(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
    function AddTextLineReaderV2(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
    function AddThreadPoolDataset(const I_input_dataset:string; const I_thread_pool:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddThreadPoolHandle(const O_handle:string; const A_num_threads:cint64; const A_max_intra_op_parallelism:cint64; const A_display_name:string; const A_container:string; const A_shared_name:string):string;
    function AddThreadUnsafeUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddTile(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType; const A_Tmultiples:TF_DataType):string;
    function AddTileGrad(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType):string;
    function AddTimestamp(const O_ts:string):string;
    function AddToBool(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
    function AddTopK(const I_input:string; const O_values:string; const O_indices:string; const A_k:cint64; const A_sorted:boolean; const A_T:TF_DataType):string;
    function AddTopKV2(const I_input:string; const I_k:string; const O_values:string; const O_indices:string; const A_sorted:boolean; const A_T:TF_DataType):string;
    function AddTranspose(const I_x:string; const I_perm:string; const O_y:string; const A_T:TF_DataType; const A_Tperm:TF_DataType):string;
    function AddTridiagonalMatMul(const I_superdiag:string; const I_maindiag:string; const I_subdiag:string; const I_rhs:string; const O_output:string; const A_T:TF_DataType):string;
    function AddTridiagonalSolve(const I_diagonals:string; const I_rhs:string; const O_output:string; const A_partial_pivoting:boolean; const A_T:TF_DataType):string;
    function AddTruncateDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddTruncateMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddTruncatedNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
    function AddTryRpc(const I_address:string; const I_method:string; const I_request:string; const O_response:string; const O_status_code:string; const O_status_message:string; const A_protocol:string; const A_fail_fast:boolean; const A_timeout_in_ms:cint64):string;
    function AddUnbatch(const I_batched_tensor:string; const I_batch_index:string; const I_id:string; const O_unbatched_tensor:string; const A_timeout_micros:cint64; const A_container:string; const A_shared_name:string; const A_T:TF_DataType):string;
    function AddUnbatchDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddUnbatchGrad(const I_original_input:string; const I_batch_index:string; const I_grad:string; const I_id:string; const O_batched_grad:string; const A_container:string; const A_shared_name:string; const A_T:TF_DataType):string;
    function AddUnicodeDecode(const I_input:string; const O_row_splits:string; const O_char_values:string; const A_input_encoding:string; const A_errors:string; const A_replacement_char:cint64; const A_replace_control_characters:boolean; const A_Tsplits:TF_DataType):string;
    function AddUnicodeDecodeWithOffsets(const I_input:string; const O_row_splits:string; const O_char_values:string; const O_char_to_byte_starts:string; const A_input_encoding:string; const A_errors:string; const A_replacement_char:cint64; const A_replace_control_characters:boolean; const A_Tsplits:TF_DataType):string;
    function AddUnicodeEncode(const I_input_values:string; const I_input_splits:string; const O_output:string; const A_errors:string; const A_output_encoding:string; const A_replacement_char:cint64; const A_Tsplits:TF_DataType):string;
    function AddUnicodeScript(const I_input:string; const O_output:string):string;
    function AddUnicodeTranscode(const I_input:string; const O_output:string; const A_input_encoding:string; const A_output_encoding:string; const A_errors:string; const A_replacement_char:cint64; const A_replace_control_characters:boolean):string;
    function AddUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
    function AddUnique(const I_x:string; const O_y:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddUniqueDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddUniqueV2(const I_x:string; const I_axis:string; const O_y:string; const O_idx:string; const A_T:TF_DataType; const A_Taxis:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddUniqueWithCounts(const I_x:string; const O_y:string; const O_idx:string; const O_count:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddUniqueWithCountsV2(const I_x:string; const I_axis:string; const O_y:string; const O_idx:string; const O_count:string; const A_T:TF_DataType; const A_Taxis:TF_DataType; const A_out_idx:TF_DataType):string;
    function AddUnpack(const I_value:string; const OL_output:string; const A_num:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
    function AddUnravelIndex(const I_indices:string; const I_dims:string; const O_output:string; const A_Tidx:TF_DataType):string;
    function AddUnsortedSegmentJoin(const I_inputs:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_separator:string; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddUnsortedSegmentMax(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddUnsortedSegmentMin(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddUnsortedSegmentProd(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddUnsortedSegmentSum(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
    function AddUnstage(const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
    function AddUnwrapDatasetVariant(const I_input_handle:string; const O_output_handle:string):string;
    function AddUpperBound(const I_sorted_inputs:string; const I_values:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
    function AddVarHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
    function AddVarIsInitializedOp(const I_resource:string; const O_is_initialized:string):string;
    function AddVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddVariableShape(const I_input:string; const O_output:string; const A_out_type:TF_DataType):string;
    function AddVariableV2(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
    function AddWhere(const I_input:string; const O_index:string; const A_T:TF_DataType):string;
    function AddWhile(const IL_input:string; const OL_output:string; const A_T:TF_TypeList; const A_cond:TF_Function; const A_body:TF_Function; const A_output_shapes:TF_ShapeList; const A_parallel_iterations:cint64):string;
    function AddWholeFileReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddWholeFileReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
    function AddWindowDataset(const I_input_dataset:string; const I_size:string; const I_shift:string; const I_stride:string; const I_drop_remainder:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
    function AddWorkerHeartbeat(const I_request:string; const O_response:string):string;
    function AddWrapDatasetVariant(const I_input_handle:string; const O_output_handle:string):string;
    function AddWriteAudioSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_tensor:string; const I_sample_rate:string; const A_max_outputs:cint64):string;
    function AddWriteFile(const I_filename:string; const I_contents:string):string;
    function AddWriteGraphSummary(const I_writer:string; const I_step:string; const I_tensor:string):string;
    function AddWriteHistogramSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_values:string; const A_T:TF_DataType):string;
    function AddWriteImageSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_tensor:string; const I_bad_color:string; const A_max_images:cint64; const A_T:TF_DataType):string;
    function AddWriteRawProtoSummary(const I_writer:string; const I_step:string; const I_tensor:string):string;
    function AddWriteScalarSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_value:string; const A_T:TF_DataType):string;
    function AddWriteSummary(const I_writer:string; const I_step:string; const I_tensor:string; const I_tag:string; const I_summary_metadata:string; const A_T:TF_DataType):string;
    function AddXdivy(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddXlog1py(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddXlogy(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
    function AddZerosLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
    function AddZeta(const I_x:string; const I_q:string; const O_z:string; const A_T:TF_DataType):string;
    function AddZipDataset(const IL_input_datasets:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
    end;


// The new Exec<oper> functions, built on top of the short version of ExecOper function, specified in tf_operations

function ExecAbs(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAccumulatorNumAccumulated(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecAccumulatorTakeGradient(const I_handle:TF_TensorPtr; const I_num_required:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_num_required:boolean=false):TF_TensorPtr;
function ExecAcos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAcosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAdd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecAddManySparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecAddSparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecAddV2(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecAdjustContrast(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const I_min_value:TF_TensorPtr; const I_max_value:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false; const D_min_value:boolean=false; const D_max_value:boolean=false):TF_TensorPtr;
function ExecAdjustContrastv2(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false):TF_TensorPtr;
function ExecAdjustHue(const I_images:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_images:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecAdjustSaturation(const I_images:TF_TensorPtr; const I_scale:TF_TensorPtr; const D_images:boolean=false; const D_scale:boolean=false):TF_TensorPtr;
function ExecAll(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecAllToAll(const I_input:TF_TensorPtr; const I_group_assignment:TF_TensorPtr; const A_concat_dimension:integer; const A_split_dimension:integer; const A_split_count:integer; const D_input:boolean=false; const D_group_assignment:boolean=false):TF_TensorPtr;
function ExecAngle(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecAnonymousIterator(const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
function ExecAny(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecApplyAdaMax(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta1_power:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_beta1:TF_TensorPtr; const I_beta2:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta1_power:boolean=false; const D_lr:boolean=false; const D_beta1:boolean=false; const D_beta2:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
function ExecApplyAdagradV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAdam(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta1_power:TF_TensorPtr; const I_beta2_power:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_beta1:TF_TensorPtr; const I_beta2:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta1_power:boolean=false; const D_beta2_power:boolean=false; const D_lr:boolean=false; const D_beta1:boolean=false; const D_beta2:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyAddSign(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_sign_decay:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_lr:boolean=false; const D_alpha:boolean=false; const D_sign_decay:boolean=false; const D_beta:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecApplyGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
function ExecApplyPowerSign(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_logbase:TF_TensorPtr; const I_sign_decay:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_lr:boolean=false; const D_logbase:boolean=false; const D_sign_decay:boolean=false; const D_beta:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecApproximateEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_tolerance:real; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecArgMax(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
function ExecArgMin(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
function ExecAsString(const I_input:TF_TensorPtr; const A_precision:integer; const A_scientific:boolean; const A_shortest:boolean; const A_width:integer; const A_fill:string; const D_input:boolean=false):TF_TensorPtr;
function ExecAsin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAsinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAssertNextDataset(const I_input_dataset:TF_TensorPtr; const I_transformations:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_transformations:boolean=false):TF_TensorPtr;
function ExecAssign(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_validate_shape:boolean; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecAssignAdd(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecAssignSub(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecAtan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAtan2(const I_y:TF_TensorPtr; const I_x:TF_TensorPtr; const D_y:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecAtanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecAudioSpectrogram(const I_input:TF_TensorPtr; const A_window_size:integer; const A_stride:integer; const A_magnitude_squared:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecAudioSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_sample_rate:real; const A_max_outputs:integer; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
function ExecAudioSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_max_outputs:integer; const D_tag:boolean=false; const D_tensor:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
function ExecAutoShardDataset(const I_input_dataset:TF_TensorPtr; const I_num_workers:TF_TensorPtr; const I_index:TF_TensorPtr; const A_auto_shard_policy:integer; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_workers:boolean=false; const D_index:boolean=false):TF_TensorPtr;
function ExecAvgPool(const I_value:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_value:boolean=false):TF_TensorPtr;
function ExecAvgPool3D(const I_input:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecAvgPool3DGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecAvgPoolGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecBarrier(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecBarrierIncompleteSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecBarrierReadySize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecBatchCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false):TF_TensorPtr;
function ExecBatchDatasetV2(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_drop_remainder:TF_TensorPtr; const A_parallel_copy:boolean; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_drop_remainder:boolean=false):TF_TensorPtr;
function ExecBatchFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_adj_x:boolean; const A_adj_y:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBatchMatMulV2(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_adj_x:boolean; const A_adj_y:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBatchMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
function ExecBatchMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecBatchMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecBatchMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecBatchMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
function ExecBatchMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecBatchNormWithGlobalNormalization(const I_t:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_gamma:TF_TensorPtr; const A_variance_epsilon:real; const A_scale_after_normalization:boolean; const D_t:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta:boolean=false; const D_gamma:boolean=false):TF_TensorPtr;
function ExecBatchSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecBatchToSpace(const I_input:TF_TensorPtr; const I_crops:TF_TensorPtr; const A_block_size:integer; const D_input:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
function ExecBatchToSpaceND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_crops:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
function ExecBesselI0e(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecBesselI1e(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecBetainc(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecBiasAdd(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const A_data_format:string; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
function ExecBiasAddGrad(const I_out_backprop:TF_TensorPtr; const A_data_format:string; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecBiasAddV1(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
function ExecBincount(const I_arr:TF_TensorPtr; const I_size:TF_TensorPtr; const I_weights:TF_TensorPtr; const D_arr:boolean=false; const D_size:boolean=false; const D_weights:boolean=false):TF_TensorPtr;
function ExecBitcast(const I_input:TF_TensorPtr; const A_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecBitwiseAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBitwiseOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBitwiseXor(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecBoostedTreesAggregateStats(const I_node_ids:TF_TensorPtr; const I_gradients:TF_TensorPtr; const I_hessians:TF_TensorPtr; const I_feature:TF_TensorPtr; const A_max_splits:integer; const A_num_buckets:integer; const D_node_ids:boolean=false; const D_gradients:boolean=false; const D_hessians:boolean=false; const D_feature:boolean=false):TF_TensorPtr;
function ExecBoostedTreesCenterBias(const I_tree_ensemble_handle:TF_TensorPtr; const I_mean_gradients:TF_TensorPtr; const I_mean_hessians:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const D_tree_ensemble_handle:boolean=false; const D_mean_gradients:boolean=false; const D_mean_hessians:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false):TF_TensorPtr;
function ExecBoostedTreesEnsembleResourceHandleOp(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecBoostedTreesQuantileStreamResourceHandleOp(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecBroadcastArgs(const I_s0:TF_TensorPtr; const I_s1:TF_TensorPtr; const D_s0:boolean=false; const D_s1:boolean=false):TF_TensorPtr;
function ExecBroadcastTo(const I_input:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_input:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecBucketize(const I_input:TF_TensorPtr; const A_boundaries:array of real; const D_input:boolean=false):TF_TensorPtr;
function ExecBytesProducedStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
function ExecCSRSparseMatrixToDense(const I_sparse_input:TF_TensorPtr; const A_type:TF_DataType; const D_sparse_input:boolean=false):TF_TensorPtr;
function ExecCacheDataset(const I_input_dataset:TF_TensorPtr; const I_filename:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_filename:boolean=false):TF_TensorPtr;
function ExecCacheDatasetV2(const I_input_dataset:TF_TensorPtr; const I_filename:TF_TensorPtr; const I_cache:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_filename:boolean=false; const D_cache:boolean=false):TF_TensorPtr;
function ExecCast(const I_x:TF_TensorPtr; const A_DstT:TF_DataType; const A_Truncate:boolean; const D_x:boolean=false):TF_TensorPtr;
function ExecCeil(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecCheckNumerics(const I_tensor:TF_TensorPtr; const A_message:string; const D_tensor:boolean=false):TF_TensorPtr;
function ExecCheckNumericsV2(const I_tensor:TF_TensorPtr; const A_message:string; const D_tensor:boolean=false):TF_TensorPtr;
function ExecCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecClipByValue(const I_t:TF_TensorPtr; const I_clip_value_min:TF_TensorPtr; const I_clip_value_max:TF_TensorPtr; const D_t:boolean=false; const D_clip_value_min:boolean=false; const D_clip_value_max:boolean=false):TF_TensorPtr;
function ExecCollectiveBcastRecv(const A_T:TF_DataType; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_shape:TF_Shape; const A_communication_hint:string):TF_TensorPtr;
function ExecCollectiveBcastSend(const I_input:TF_TensorPtr; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_shape:TF_Shape; const A_communication_hint:string; const D_input:boolean=false):TF_TensorPtr;
function ExecCollectiveGather(const I_input:TF_TensorPtr; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_shape:TF_Shape; const A_communication_hint:string; const D_input:boolean=false):TF_TensorPtr;
function ExecCollectivePermute(const I_input:TF_TensorPtr; const I_source_target_pairs:TF_TensorPtr; const D_input:boolean=false; const D_source_target_pairs:boolean=false):TF_TensorPtr;
function ExecCollectiveReduce(const I_input:TF_TensorPtr; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_merge_op:string; const A_final_op:string; const A_subdiv_offsets:array of integer; const A_wait_for:array of integer; const A_communication_hint:string; const D_input:boolean=false):TF_TensorPtr;
function ExecCompareAndBitpack(const I_input:TF_TensorPtr; const I_threshold:TF_TensorPtr; const D_input:boolean=false; const D_threshold:boolean=false):TF_TensorPtr;
function ExecComplex(const I_real:TF_TensorPtr; const I_imag:TF_TensorPtr; const A_Tout:TF_DataType; const D_real:boolean=false; const D_imag:boolean=false):TF_TensorPtr;
function ExecComplexAbs(const I_x:TF_TensorPtr; const A_Tout:TF_DataType; const D_x:boolean=false):TF_TensorPtr;
function ExecConcatenateDataset(const I_input_dataset:TF_TensorPtr; const I_another_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_another_dataset:boolean=false):TF_TensorPtr;
function ExecConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):TF_TensorPtr;
function ExecConfigureDistributedTPU(const A_embedding_config:string; const A_tpu_embedding_config:string; const A_is_global_init:boolean; const A_enable_whole_mesh_compilations:boolean; const A_compilation_failure_closes_chips:boolean):TF_TensorPtr;
function ExecConj(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecConjugateTranspose(const I_x:TF_TensorPtr; const I_perm:TF_TensorPtr; const D_x:boolean=false; const D_perm:boolean=false):TF_TensorPtr;
function ExecConst(const A_value:TF_TensorPtr; const A_dtype:TF_DataType):TF_TensorPtr;
function ExecConv2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:array of integer; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecConv2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:array of integer; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv2DBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:array of integer; const A_data_format:string; const A_dilations:array of integer; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropFilterV2(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecConv3DBackpropInputV2(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecCopy(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:array of string; const D_input:boolean=false):TF_TensorPtr;
function ExecCopyHost(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:array of string; const D_input:boolean=false):TF_TensorPtr;
function ExecCos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecCosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecCountUpTo(const I_ref:TF_TensorPtr; const A_limit:integer; const D_ref:boolean=false):TF_TensorPtr;
function ExecCropAndResize(const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_crop_size:TF_TensorPtr; const A_method:string; const A_extrapolation_value:real; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_crop_size:boolean=false):TF_TensorPtr;
function ExecCropAndResizeGradBoxes(const I_grads:TF_TensorPtr; const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const A_method:string; const D_grads:boolean=false; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false):TF_TensorPtr;
function ExecCropAndResizeGradImage(const I_grads:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_image_size:TF_TensorPtr; const A_T:TF_DataType; const A_method:string; const D_grads:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_image_size:boolean=false):TF_TensorPtr;
function ExecCross(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecCrossReplicaSum(const I_input:TF_TensorPtr; const I_group_assignment:TF_TensorPtr; const D_input:boolean=false; const D_group_assignment:boolean=false):TF_TensorPtr;
function ExecCudnnRNNParamsSize(const I_num_layers:TF_TensorPtr; const I_num_units:TF_TensorPtr; const I_input_size:TF_TensorPtr; const A_T:TF_DataType; const A_S:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:integer; const A_seed2:integer; const A_num_proj:integer; const D_num_layers:boolean=false; const D_num_units:boolean=false; const D_input_size:boolean=false):TF_TensorPtr;
function ExecCumprod(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecCumsum(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecCumulativeLogsumexp(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecDataFormatDimMap(const I_x:TF_TensorPtr; const A_src_format:string; const A_dst_format:string; const D_x:boolean=false):TF_TensorPtr;
function ExecDataFormatVecPermute(const I_x:TF_TensorPtr; const A_src_format:string; const A_dst_format:string; const D_x:boolean=false):TF_TensorPtr;
function ExecDatasetCardinality(const I_input_dataset:TF_TensorPtr; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecDatasetFromGraph(const I_graph_def:TF_TensorPtr; const D_graph_def:boolean=false):TF_TensorPtr;
function ExecDatasetToGraph(const I_input_dataset:TF_TensorPtr; const A_stateful_whitelist:array of string; const A_allow_stateful:boolean; const A_strip_device_assignment:boolean; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecDatasetToGraphV2(const I_input_dataset:TF_TensorPtr; const A_external_state_policy:integer; const A_strip_device_assignment:boolean; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecDawsn(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecDebugGradientIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugGradientRefIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugIdentity(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:array of string; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugIdentityV2(const I_input:TF_TensorPtr; const A_tfdbg_context_id:string; const A_op_name:string; const A_output_slot:integer; const A_tensor_debug_mode:integer; const A_debug_urls:array of string; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugNanCount(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:array of string; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugNumericSummary(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:array of string; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecDebugNumericSummaryV2(const I_input:TF_TensorPtr; const A_output_dtype:TF_DataType; const A_tensor_debug_mode:integer; const A_tensor_id:integer; const D_input:boolean=false):TF_TensorPtr;
function ExecDecodeAndCropJpeg(const I_contents:TF_TensorPtr; const I_crop_window:TF_TensorPtr; const A_channels:integer; const A_ratio:integer; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string; const D_contents:boolean=false; const D_crop_window:boolean=false):TF_TensorPtr;
function ExecDecodeBase64(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecDecodeBmp(const I_contents:TF_TensorPtr; const A_channels:integer; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodeCompressed(const I_bytes:TF_TensorPtr; const A_compression_type:string; const D_bytes:boolean=false):TF_TensorPtr;
function ExecDecodeGif(const I_contents:TF_TensorPtr; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodeJSONExample(const I_json_examples:TF_TensorPtr; const D_json_examples:boolean=false):TF_TensorPtr;
function ExecDecodeJpeg(const I_contents:TF_TensorPtr; const A_channels:integer; const A_ratio:integer; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodePaddedRaw(const I_input_bytes:TF_TensorPtr; const I_fixed_length:TF_TensorPtr; const A_out_type:TF_DataType; const A_little_endian:boolean; const D_input_bytes:boolean=false; const D_fixed_length:boolean=false):TF_TensorPtr;
function ExecDecodePng(const I_contents:TF_TensorPtr; const A_channels:integer; const A_dtype:TF_DataType; const D_contents:boolean=false):TF_TensorPtr;
function ExecDecodeRaw(const I_bytes:TF_TensorPtr; const A_out_type:TF_DataType; const A_little_endian:boolean; const D_bytes:boolean=false):TF_TensorPtr;
function ExecDeepCopy(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecDenseToCSRSparseMatrix(const I_dense_input:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_dense_input:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecDenseToSparseBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_row_shape:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_row_shape:boolean=false):TF_TensorPtr;
function ExecDepthToSpace(const I_input:TF_TensorPtr; const A_block_size:integer; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecDepthwiseConv2dNative(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecDepthwiseConv2dNativeBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDepthwiseConv2dNativeBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDequantize(const I_input:TF_TensorPtr; const I_min_range:TF_TensorPtr; const I_max_range:TF_TensorPtr; const A_mode:string; const A_narrow_range:boolean; const A_axis:integer; const A_dtype:TF_DataType; const D_input:boolean=false; const D_min_range:boolean=false; const D_max_range:boolean=false):TF_TensorPtr;
function ExecDestroyTemporaryVariable(const I_ref:TF_TensorPtr; const A_var_name:string; const D_ref:boolean=false):TF_TensorPtr;
function ExecDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecDigamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecDilation2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecDilation2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDilation2DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
function ExecDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecDivNoNan(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecDrawBoundingBoxes(const I_images:TF_TensorPtr; const I_boxes:TF_TensorPtr; const D_images:boolean=false; const D_boxes:boolean=false):TF_TensorPtr;
function ExecDrawBoundingBoxesV2(const I_images:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_colors:TF_TensorPtr; const D_images:boolean=false; const D_boxes:boolean=false; const D_colors:boolean=false):TF_TensorPtr;
function ExecEditDistance(const I_hypothesis_indices:TF_TensorPtr; const I_hypothesis_values:TF_TensorPtr; const I_hypothesis_shape:TF_TensorPtr; const I_truth_indices:TF_TensorPtr; const I_truth_values:TF_TensorPtr; const I_truth_shape:TF_TensorPtr; const A_normalize:boolean; const D_hypothesis_indices:boolean=false; const D_hypothesis_values:boolean=false; const D_hypothesis_shape:boolean=false; const D_truth_indices:boolean=false; const D_truth_values:boolean=false; const D_truth_shape:boolean=false):TF_TensorPtr;
function ExecElu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecEluGrad(const I_gradients:TF_TensorPtr; const I_outputs:TF_TensorPtr; const D_gradients:boolean=false; const D_outputs:boolean=false):TF_TensorPtr;
function ExecEmpty(const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const A_init:boolean; const D_shape:boolean=false):TF_TensorPtr;
function ExecEmptyTensorList(const I_element_shape:TF_TensorPtr; const I_max_num_elements:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_element_shape:boolean=false; const D_max_num_elements:boolean=false):TF_TensorPtr;
function ExecEncodeBase64(const I_input:TF_TensorPtr; const A_pad:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecEncodeJpeg(const I_image:TF_TensorPtr; const A_format:string; const A_quality:integer; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:integer; const A_y_density:integer; const A_xmp_metadata:string; const D_image:boolean=false):TF_TensorPtr;
function ExecEncodeJpegVariableQuality(const I_images:TF_TensorPtr; const I_quality:TF_TensorPtr; const D_images:boolean=false; const D_quality:boolean=false):TF_TensorPtr;
function ExecEncodePng(const I_image:TF_TensorPtr; const A_compression:integer; const D_image:boolean=false):TF_TensorPtr;
function ExecEncodeWav(const I_audio:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const D_audio:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
function ExecEnsureShape(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
function ExecEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:integer; const D_data:boolean=false):TF_TensorPtr;
function ExecEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_incompatible_shape_error:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecErf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecErfc(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecErfinv(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecEuclideanNorm(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecExp(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecExpandDims(const I_input:TF_TensorPtr; const I_dim:TF_TensorPtr; const D_input:boolean=false; const D_dim:boolean=false):TF_TensorPtr;
function ExecExperimentalAssertNextDataset(const I_input_dataset:TF_TensorPtr; const I_transformations:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_transformations:boolean=false):TF_TensorPtr;
function ExecExperimentalAutoShardDataset(const I_input_dataset:TF_TensorPtr; const I_num_workers:TF_TensorPtr; const I_index:TF_TensorPtr; const A_auto_shard_policy:integer; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_workers:boolean=false; const D_index:boolean=false):TF_TensorPtr;
function ExecExperimentalBytesProducedStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
function ExecExperimentalDatasetCardinality(const I_input_dataset:TF_TensorPtr; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecExperimentalDenseToSparseBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_row_shape:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_row_shape:boolean=false):TF_TensorPtr;
function ExecExperimentalIgnoreErrorsDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecExperimentalIteratorGetDevice(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
function ExecExperimentalLMDBDataset(const I_filenames:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_filenames:boolean=false):TF_TensorPtr;
function ExecExperimentalLatencyStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
function ExecExperimentalMatchingFilesDataset(const I_patterns:TF_TensorPtr; const D_patterns:boolean=false):TF_TensorPtr;
function ExecExperimentalMaxIntraOpParallelismDataset(const I_input_dataset:TF_TensorPtr; const I_max_intra_op_parallelism:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_max_intra_op_parallelism:boolean=false):TF_TensorPtr;
function ExecExperimentalNonSerializableDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecExperimentalPrivateThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_num_threads:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_threads:boolean=false):TF_TensorPtr;
function ExecExperimentalRandomDataset(const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
function ExecExperimentalRebatchDataset(const I_input_dataset:TF_TensorPtr; const I_num_replicas:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_use_fallback:boolean; const D_input_dataset:boolean=false; const D_num_replicas:boolean=false):TF_TensorPtr;
function ExecExperimentalSetStatsAggregatorDataset(const I_input_dataset:TF_TensorPtr; const I_stats_aggregator:TF_TensorPtr; const I_tag:TF_TensorPtr; const I_counter_prefix:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_stats_aggregator:boolean=false; const D_tag:boolean=false; const D_counter_prefix:boolean=false):TF_TensorPtr;
function ExecExperimentalSleepDataset(const I_input_dataset:TF_TensorPtr; const I_sleep_microseconds:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_sleep_microseconds:boolean=false):TF_TensorPtr;
function ExecExperimentalSlidingWindowDataset(const I_input_dataset:TF_TensorPtr; const I_window_size:TF_TensorPtr; const I_window_shift:TF_TensorPtr; const I_window_stride:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_window_size:boolean=false; const D_window_shift:boolean=false; const D_window_stride:boolean=false):TF_TensorPtr;
function ExecExperimentalSqlDataset(const I_driver_name:TF_TensorPtr; const I_data_source_name:TF_TensorPtr; const I_query:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_driver_name:boolean=false; const D_data_source_name:boolean=false; const D_query:boolean=false):TF_TensorPtr;
function ExecExperimentalStatsAggregatorHandle(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecExperimentalStatsAggregatorSummary(const I_iterator:TF_TensorPtr; const D_iterator:boolean=false):TF_TensorPtr;
function ExecExperimentalThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_thread_pool:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_thread_pool:boolean=false):TF_TensorPtr;
function ExecExperimentalThreadPoolHandle(const A_num_threads:integer; const A_max_intra_op_parallelism:integer; const A_display_name:string; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecExperimentalUnbatchDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecExperimentalUniqueDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecExpint(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecExpm1(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecExtractGlimpse(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_offsets:TF_TensorPtr; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean; const A_noise:string; const D_input:boolean=false; const D_size:boolean=false; const D_offsets:boolean=false):TF_TensorPtr;
function ExecExtractImagePatches(const I_images:TF_TensorPtr; const A_ksizes:array of integer; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_images:boolean=false):TF_TensorPtr;
function ExecExtractJpegShape(const I_contents:TF_TensorPtr; const A_output_type:TF_DataType; const D_contents:boolean=false):TF_TensorPtr;
function ExecExtractVolumePatches(const I_input:TF_TensorPtr; const A_ksizes:array of integer; const A_strides:array of integer; const A_padding:string; const D_input:boolean=false):TF_TensorPtr;
function ExecFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecFIFOQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecFIFOQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecFact():TF_TensorPtr;
function ExecFakeParam(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecFakeQuantWithMinMaxArgs(const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:integer; const A_narrow_range:boolean; const D_inputs:boolean=false):TF_TensorPtr;
function ExecFakeQuantWithMinMaxArgsGradient(const I_gradients:TF_TensorPtr; const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:integer; const A_narrow_range:boolean; const D_gradients:boolean=false; const D_inputs:boolean=false):TF_TensorPtr;
function ExecFakeQuantWithMinMaxVars(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:integer; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
function ExecFakeQuantWithMinMaxVarsPerChannel(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:integer; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
function ExecFakeQueue(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
function ExecFill(const I_dims:TF_TensorPtr; const I_value:TF_TensorPtr; const D_dims:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecFilterByLastComponentDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecFingerprint(const I_data:TF_TensorPtr; const I_method:TF_TensorPtr; const D_data:boolean=false; const D_method:boolean=false):TF_TensorPtr;
function ExecFixedLengthRecordDataset(const I_filenames:TF_TensorPtr; const I_header_bytes:TF_TensorPtr; const I_record_bytes:TF_TensorPtr; const I_footer_bytes:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const D_filenames:boolean=false; const D_header_bytes:boolean=false; const D_record_bytes:boolean=false; const D_footer_bytes:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
function ExecFixedLengthRecordDatasetV2(const I_filenames:TF_TensorPtr; const I_header_bytes:TF_TensorPtr; const I_record_bytes:TF_TensorPtr; const I_footer_bytes:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const D_filenames:boolean=false; const D_header_bytes:boolean=false; const D_record_bytes:boolean=false; const D_footer_bytes:boolean=false; const D_buffer_size:boolean=false; const D_compression_type:boolean=false):TF_TensorPtr;
function ExecFixedLengthRecordReader(const A_header_bytes:integer; const A_record_bytes:integer; const A_footer_bytes:integer; const A_hop_bytes:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecFixedLengthRecordReaderV2(const A_header_bytes:integer; const A_record_bytes:integer; const A_footer_bytes:integer; const A_hop_bytes:integer; const A_container:string; const A_shared_name:string; const A_encoding:string):TF_TensorPtr;
function ExecFloor(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecFloorDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecFloorMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecFractionalAvgPoolGrad(const I_orig_input_tensor_shape:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input_tensor_shape:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
function ExecFractionalMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
function ExecFresnelCos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecFresnelSin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecFusedPadConv2D(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_mode:string; const A_strides:array of integer; const A_padding:string; const D_input:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecFusedResizeAndPadConv2D(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:array of integer; const A_padding:string; const D_input:boolean=false; const D_size:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
function ExecGather(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_validate_indices:boolean; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecGatherNd(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecGatherV2(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_batch_dims:integer; const D_params:boolean=false; const D_indices:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecGetSessionHandle(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
function ExecGetSessionHandleV2(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
function ExecGetSessionTensor(const I_handle:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
function ExecGreater(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecGreaterEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecGuaranteeConst(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecHSVToRGB(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
function ExecHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecHistogramFixedWidth(const I_values:TF_TensorPtr; const I_value_range:TF_TensorPtr; const I_nbins:TF_TensorPtr; const A_dtype:TF_DataType; const D_values:boolean=false; const D_value_range:boolean=false; const D_nbins:boolean=false):TF_TensorPtr;
function ExecHistogramSummary(const I_tag:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tag:boolean=false; const D_values:boolean=false):TF_TensorPtr;
function ExecHostConst(const A_value:TF_TensorPtr; const A_dtype:TF_DataType):TF_TensorPtr;
function ExecIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Treal:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecIRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Treal:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecIRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Treal:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecIdentityReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecIdentityReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecIgamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecIgammaGradA(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecIgammac(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecIgnoreErrorsDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecImag(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecImageProjectiveTransformV2(const I_images:TF_TensorPtr; const I_transforms:TF_TensorPtr; const I_output_shape:TF_TensorPtr; const A_interpolation:string; const D_images:boolean=false; const D_transforms:boolean=false; const D_output_shape:boolean=false):TF_TensorPtr;
function ExecImageSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_max_images:integer; const A_bad_color:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
function ExecImmutableConst(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):TF_TensorPtr;
function ExecInTopK(const I_predictions:TF_TensorPtr; const I_targets:TF_TensorPtr; const A_k:integer; const D_predictions:boolean=false; const D_targets:boolean=false):TF_TensorPtr;
function ExecInTopKV2(const I_predictions:TF_TensorPtr; const I_targets:TF_TensorPtr; const I_k:TF_TensorPtr; const D_predictions:boolean=false; const D_targets:boolean=false; const D_k:boolean=false):TF_TensorPtr;
function ExecInfeedDequeue(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecInplaceAdd(const I_x:TF_TensorPtr; const I_i:TF_TensorPtr; const I_v:TF_TensorPtr; const D_x:boolean=false; const D_i:boolean=false; const D_v:boolean=false):TF_TensorPtr;
function ExecInplaceSub(const I_x:TF_TensorPtr; const I_i:TF_TensorPtr; const I_v:TF_TensorPtr; const D_x:boolean=false; const D_i:boolean=false; const D_v:boolean=false):TF_TensorPtr;
function ExecInplaceUpdate(const I_x:TF_TensorPtr; const I_i:TF_TensorPtr; const I_v:TF_TensorPtr; const D_x:boolean=false; const D_i:boolean=false; const D_v:boolean=false):TF_TensorPtr;
function ExecInv(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecInvGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecInvert(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecInvertPermutation(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsBoostedTreesEnsembleInitialized(const I_tree_ensemble_handle:TF_TensorPtr; const D_tree_ensemble_handle:boolean=false):TF_TensorPtr;
function ExecIsBoostedTreesQuantileStreamResourceInitialized(const I_quantile_stream_resource_handle:TF_TensorPtr; const D_quantile_stream_resource_handle:boolean=false):TF_TensorPtr;
function ExecIsFinite(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsInf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsNan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecIsVariableInitialized(const I_ref:TF_TensorPtr; const D_ref:boolean=false):TF_TensorPtr;
function ExecIterator(const A_shared_name:string; const A_container:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
function ExecIteratorFromStringHandle(const I_string_handle:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_string_handle:boolean=false):TF_TensorPtr;
function ExecIteratorFromStringHandleV2(const I_string_handle:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_string_handle:boolean=false):TF_TensorPtr;
function ExecIteratorGetDevice(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
function ExecIteratorGetNextAsOptional(const I_iterator:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_iterator:boolean=false):TF_TensorPtr;
function ExecIteratorToStringHandle(const I_resource_handle:TF_TensorPtr; const D_resource_handle:boolean=false):TF_TensorPtr;
function ExecIteratorV2(const A_shared_name:string; const A_container:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
function ExecKMC2ChainInitialization(const I_distances:TF_TensorPtr; const I_seed:TF_TensorPtr; const D_distances:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecKmeansPlusPlusInitialization(const I_points:TF_TensorPtr; const I_num_to_sample:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_num_retries_per_sample:TF_TensorPtr; const D_points:boolean=false; const D_num_to_sample:boolean=false; const D_seed:boolean=false; const D_num_retries_per_sample:boolean=false):TF_TensorPtr;
function ExecL2Loss(const I_t:TF_TensorPtr; const D_t:boolean=false):TF_TensorPtr;
function ExecLMDBDataset(const I_filenames:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_filenames:boolean=false):TF_TensorPtr;
function ExecLMDBReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecLRN(const I_input:TF_TensorPtr; const A_depth_radius:integer; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input:boolean=false):TF_TensorPtr;
function ExecLRNGrad(const I_input_grads:TF_TensorPtr; const I_input_image:TF_TensorPtr; const I_output_image:TF_TensorPtr; const A_depth_radius:integer; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input_grads:boolean=false; const D_input_image:boolean=false; const D_output_image:boolean=false):TF_TensorPtr;
function ExecLatencyStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
function ExecLeakyRelu(const I_features:TF_TensorPtr; const A_alpha:real; const D_features:boolean=false):TF_TensorPtr;
function ExecLeakyReluGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const A_alpha:real; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecLeftShift(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLess(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLessEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLgamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLinSpace(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_num:TF_TensorPtr; const D_start:boolean=false; const D_stop:boolean=false; const D_num:boolean=false):TF_TensorPtr;
function ExecLoadAndRemapMatrix(const I_ckpt_path:TF_TensorPtr; const I_old_tensor_name:TF_TensorPtr; const I_row_remapping:TF_TensorPtr; const I_col_remapping:TF_TensorPtr; const I_initializing_values:TF_TensorPtr; const A_num_rows:integer; const A_num_cols:integer; const A_max_rows_in_memory:integer; const D_ckpt_path:boolean=false; const D_old_tensor_name:boolean=false; const D_row_remapping:boolean=false; const D_col_remapping:boolean=false; const D_initializing_values:boolean=false):TF_TensorPtr;
function ExecLog(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLog1p(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLogSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
function ExecLogicalAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLogicalNot(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecLogicalOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecLookupTableFind(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
function ExecLookupTableFindV2(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
function ExecLookupTableSize(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
function ExecLookupTableSizeV2(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
function ExecLoopCond(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecLowerBound(const I_sorted_inputs:TF_TensorPtr; const I_values:TF_TensorPtr; const A_out_type:TF_DataType; const D_sorted_inputs:boolean=false; const D_values:boolean=false):TF_TensorPtr;
function ExecMapIncompleteSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecMapSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecMatchingFiles(const I_pattern:TF_TensorPtr; const D_pattern:boolean=false):TF_TensorPtr;
function ExecMatchingFilesDataset(const I_patterns:TF_TensorPtr; const D_patterns:boolean=false):TF_TensorPtr;
function ExecMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
function ExecMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixDiagPartV2(const I_input:TF_TensorPtr; const I_k:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const D_input:boolean=false; const D_k:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
function ExecMatrixDiagPartV3(const I_input:TF_TensorPtr; const I_k:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const A_align:string; const D_input:boolean=false; const D_k:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
function ExecMatrixDiagV2(const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const I_num_rows:TF_TensorPtr; const I_num_cols:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const D_diagonal:boolean=false; const D_k:boolean=false; const D_num_rows:boolean=false; const D_num_cols:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
function ExecMatrixDiagV3(const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const I_num_rows:TF_TensorPtr; const I_num_cols:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const A_align:string; const D_diagonal:boolean=false; const D_k:boolean=false; const D_num_rows:boolean=false; const D_num_cols:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
function ExecMatrixExponential(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixLogarithm(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
function ExecMatrixSetDiagV2(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false; const D_k:boolean=false):TF_TensorPtr;
function ExecMatrixSetDiagV3(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const A_align:string; const D_input:boolean=false; const D_diagonal:boolean=false; const D_k:boolean=false):TF_TensorPtr;
function ExecMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
function ExecMatrixSquareRoot(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecMax(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecMaxIntraOpParallelismDataset(const I_input_dataset:TF_TensorPtr; const I_max_intra_op_parallelism:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_max_intra_op_parallelism:boolean=false):TF_TensorPtr;
function ExecMaxPool(const I_input:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecMaxPool3D(const I_input:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecMaxPool3DGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPool3DGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradGradV2(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_ksize:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false; const D_ksize:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_include_batch_in_index:boolean; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradV2(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_ksize:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false; const D_ksize:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
function ExecMaxPoolGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_include_batch_in_index:boolean; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
function ExecMaxPoolV2(const I_input:TF_TensorPtr; const I_ksize:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_ksize:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
function ExecMaximum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMean(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecMfcc(const I_spectrogram:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:integer; const A_dct_coefficient_count:integer; const D_spectrogram:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
function ExecMin(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecMinimum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMirrorPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecMirrorPadGrad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecModelDataset(const I_input_dataset:TF_TensorPtr; const A_algorithm:integer; const A_cpu_budget:integer; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMulNoNan(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecMultiDeviceIterator(const A_devices:array of string; const A_shared_name:string; const A_container:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
function ExecMultiDeviceIteratorFromStringHandle(const I_string_handle:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_string_handle:boolean=false):TF_TensorPtr;
function ExecMultiDeviceIteratorInit(const I_dataset:TF_TensorPtr; const I_multi_device_iterator:TF_TensorPtr; const I_max_buffer_size:TF_TensorPtr; const D_dataset:boolean=false; const D_multi_device_iterator:boolean=false; const D_max_buffer_size:boolean=false):TF_TensorPtr;
function ExecMultiDeviceIteratorToStringHandle(const I_multi_device_iterator:TF_TensorPtr; const D_multi_device_iterator:boolean=false):TF_TensorPtr;
function ExecMultinomial(const I_logits:TF_TensorPtr; const I_num_samples:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_output_dtype:TF_DataType; const D_logits:boolean=false; const D_num_samples:boolean=false):TF_TensorPtr;
function ExecMutableDenseHashTable(const I_empty_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:integer; const A_max_load_factor:real; const D_empty_key:boolean=false):TF_TensorPtr;
function ExecMutableDenseHashTableV2(const I_empty_key:TF_TensorPtr; const I_deleted_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:integer; const A_max_load_factor:real; const D_empty_key:boolean=false; const D_deleted_key:boolean=false):TF_TensorPtr;
function ExecMutableHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecMutableHashTableOfTensors(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
function ExecMutableHashTableOfTensorsV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
function ExecMutableHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
function ExecMutexLock(const I_mutex:TF_TensorPtr; const D_mutex:boolean=false):TF_TensorPtr;
function ExecMutexV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecNcclAllReduce(const I_input:TF_TensorPtr; const A_reduction:string; const A_num_devices:integer; const A_shared_name:string; const D_input:boolean=false):TF_TensorPtr;
function ExecNcclBroadcast(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
function ExecNdtri(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecNeg(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecNextAfter(const I_x1:TF_TensorPtr; const I_x2:TF_TensorPtr; const D_x1:boolean=false; const D_x2:boolean=false):TF_TensorPtr;
function ExecNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecNonDeterministicInts(const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecNonMaxSuppression(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const A_iou_threshold:real; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false):TF_TensorPtr;
function ExecNonMaxSuppressionV2(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_iou_threshold:TF_TensorPtr; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_iou_threshold:boolean=false):TF_TensorPtr;
function ExecNonMaxSuppressionV3(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_iou_threshold:TF_TensorPtr; const I_score_threshold:TF_TensorPtr; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_iou_threshold:boolean=false; const D_score_threshold:boolean=false):TF_TensorPtr;
function ExecNonMaxSuppressionWithOverlaps(const I_overlaps:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_overlap_threshold:TF_TensorPtr; const I_score_threshold:TF_TensorPtr; const D_overlaps:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_overlap_threshold:boolean=false; const D_score_threshold:boolean=false):TF_TensorPtr;
function ExecNonSerializableDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecNotEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_incompatible_shape_error:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecNthElement(const I_input:TF_TensorPtr; const I_n:TF_TensorPtr; const A_reverse:boolean; const D_input:boolean=false; const D_n:boolean=false):TF_TensorPtr;
function ExecOneHot(const I_indices:TF_TensorPtr; const I_depth:TF_TensorPtr; const I_on_value:TF_TensorPtr; const I_off_value:TF_TensorPtr; const A_axis:integer; const D_indices:boolean=false; const D_depth:boolean=false; const D_on_value:boolean=false; const D_off_value:boolean=false):TF_TensorPtr;
function ExecOneShotIterator(const A_dataset_factory:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecOnesLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecOptimizeDataset(const I_input_dataset:TF_TensorPtr; const I_optimizations:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_optimization_configs:array of string; const D_input_dataset:boolean=false; const D_optimizations:boolean=false):TF_TensorPtr;
function ExecOptionalHasValue(const I_optional:TF_TensorPtr; const D_optional:boolean=false):TF_TensorPtr;
function ExecOptionalNone():TF_TensorPtr;
function ExecOrderedMapIncompleteSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecOrderedMapSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecOutfeedDequeue(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_device_ordinal:integer):TF_TensorPtr;
function ExecPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecPadV2(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_constant_values:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false; const D_constant_values:boolean=false):TF_TensorPtr;
function ExecPaddingFIFOQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecPaddingFIFOQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecParameterizedTruncatedNormal(const I_shape:TF_TensorPtr; const I_means:TF_TensorPtr; const I_stdevs:TF_TensorPtr; const I_minvals:TF_TensorPtr; const I_maxvals:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_means:boolean=false; const D_stdevs:boolean=false; const D_minvals:boolean=false; const D_maxvals:boolean=false):TF_TensorPtr;
function ExecParseTensor(const I_serialized:TF_TensorPtr; const A_out_type:TF_DataType; const D_serialized:boolean=false):TF_TensorPtr;
function ExecPlaceholder(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecPlaceholderV2(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecPlaceholderWithDefault(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
function ExecPolygamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
function ExecPopulationCount(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecPow(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecPrefetchDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_slack_period:integer; const A_legacy_autotune:boolean; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
function ExecPrelinearize(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const A_layout:array of integer; const D_input:boolean=false):TF_TensorPtr;
function ExecPreventGradient(const I_input:TF_TensorPtr; const A_message:string; const D_input:boolean=false):TF_TensorPtr;
function ExecPriorityQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecPriorityQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecPrivateThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_num_threads:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_threads:boolean=false):TF_TensorPtr;
function ExecProd(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecQuantizeAndDequantize(const I_input:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:integer; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const D_input:boolean=false):TF_TensorPtr;
function ExecQuantizeAndDequantizeV2(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:integer; const A_range_given:boolean; const A_round_mode:string; const A_narrow_range:boolean; const A_axis:integer; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false):TF_TensorPtr;
function ExecQuantizeAndDequantizeV3(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const I_num_bits:TF_TensorPtr; const A_signed_input:boolean; const A_range_given:boolean; const A_narrow_range:boolean; const A_axis:integer; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false; const D_num_bits:boolean=false):TF_TensorPtr;
function ExecQueueIsClosed(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecQueueIsClosedV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecQueueSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecQueueSizeV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Tcomplex:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Tcomplex:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Tcomplex:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
function ExecRGBToHSV(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
function ExecRandomCrop(const I_image:TF_TensorPtr; const I_size:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_image:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecRandomDataset(const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
function ExecRandomGamma(const I_shape:TF_TensorPtr; const I_alpha:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_alpha:boolean=false):TF_TensorPtr;
function ExecRandomGammaGrad(const I_alpha:TF_TensorPtr; const I_sample:TF_TensorPtr; const D_alpha:boolean=false; const D_sample:boolean=false):TF_TensorPtr;
function ExecRandomPoisson(const I_shape:TF_TensorPtr; const I_rate:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_rate:boolean=false):TF_TensorPtr;
function ExecRandomPoissonV2(const I_shape:TF_TensorPtr; const I_rate:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_rate:boolean=false):TF_TensorPtr;
function ExecRandomShuffle(const I_value:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_value:boolean=false):TF_TensorPtr;
function ExecRandomShuffleQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_min_after_dequeue:integer; const A_seed:integer; const A_seed2:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecRandomShuffleQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_min_after_dequeue:integer; const A_seed:integer; const A_seed2:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecRandomStandardNormal(const I_shape:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecRandomUniform(const I_shape:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecRandomUniformInt(const I_shape:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
function ExecRange(const I_start:TF_TensorPtr; const I_limit:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_start:boolean=false; const D_limit:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
function ExecRangeDataset(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_step:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_start:boolean=false; const D_stop:boolean=false; const D_step:boolean=false):TF_TensorPtr;
function ExecRank(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecReadFile(const I_filename:TF_TensorPtr; const D_filename:boolean=false):TF_TensorPtr;
function ExecReadVariableOp(const I_resource:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false):TF_TensorPtr;
function ExecReaderNumRecordsProduced(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderNumRecordsProducedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderNumWorkUnitsCompleted(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderNumWorkUnitsCompletedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderSerializeState(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReaderSerializeStateV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
function ExecReal(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecRealDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecRebatchDataset(const I_input_dataset:TF_TensorPtr; const I_num_replicas:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_use_fallback:boolean; const D_input_dataset:boolean=false; const D_num_replicas:boolean=false):TF_TensorPtr;
function ExecReciprocal(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecReciprocalGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecRecordInput(const A_file_pattern:string; const A_file_random_seed:integer; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:integer; const A_file_parallelism:integer; const A_batch_size:integer; const A_compression_type:string):TF_TensorPtr;
function ExecRecv(const A_tensor_type:TF_DataType; const A_tensor_name:string; const A_send_device:string; const A_send_device_incarnation:integer; const A_recv_device:string; const A_client_terminated:boolean):TF_TensorPtr;
function ExecReduceJoin(const I_inputs:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const A_separator:string; const D_inputs:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecRefEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:integer; const D_data:boolean=false):TF_TensorPtr;
function ExecRefExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecRefIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecRefNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
function ExecRegexFullMatch(const I_input:TF_TensorPtr; const I_pattern:TF_TensorPtr; const D_input:boolean=false; const D_pattern:boolean=false):TF_TensorPtr;
function ExecRegexReplace(const I_input:TF_TensorPtr; const I_pattern:TF_TensorPtr; const I_rewrite:TF_TensorPtr; const A_replace_global:boolean; const D_input:boolean=false; const D_pattern:boolean=false; const D_rewrite:boolean=false):TF_TensorPtr;
function ExecRelu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecRelu6(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecRelu6Grad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecReluGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecRepeatDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecReshape(const I_tensor:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecResizeArea(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeBicubic(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeBicubicGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_grads:boolean=false; const D_original_image:boolean=false):TF_TensorPtr;
function ExecResizeBilinear(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeBilinearGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_grads:boolean=false; const D_original_image:boolean=false):TF_TensorPtr;
function ExecResizeNearestNeighbor(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResizeNearestNeighborGrad(const I_grads:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_grads:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecResourceAccumulatorNumAccumulated(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
function ExecResourceAccumulatorTakeGradient(const I_handle:TF_TensorPtr; const I_num_required:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_num_required:boolean=false):TF_TensorPtr;
function ExecResourceConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):TF_TensorPtr;
function ExecResourceCountUpTo(const I_resource:TF_TensorPtr; const A_limit:integer; const A_T:TF_DataType; const D_resource:boolean=false):TF_TensorPtr;
function ExecResourceGather(const I_resource:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_batch_dims:integer; const A_validate_indices:boolean; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecResourceGatherNd(const I_resource:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecRestore(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:integer; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false):TF_TensorPtr;
function ExecRestoreSlice(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const I_shape_and_slice:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:integer; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false; const D_shape_and_slice:boolean=false):TF_TensorPtr;
function ExecRetrieveTPUEmbeddingStochasticGradientDescentParameters(const A_table_id:integer; const A_table_name:string; const A_num_shards:integer; const A_shard_id:integer; const A_config:string):TF_TensorPtr;
function ExecReverse(const I_tensor:TF_TensorPtr; const I_dims:TF_TensorPtr; const D_tensor:boolean=false; const D_dims:boolean=false):TF_TensorPtr;
function ExecReverseSequence(const I_input:TF_TensorPtr; const I_seq_lengths:TF_TensorPtr; const A_seq_dim:integer; const A_batch_dim:integer; const D_input:boolean=false; const D_seq_lengths:boolean=false):TF_TensorPtr;
function ExecReverseV2(const I_tensor:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_tensor:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecRightShift(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecRint(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecRoll(const I_input:TF_TensorPtr; const I_shift:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_input:boolean=false; const D_shift:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
function ExecRound(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecRpc(const I_address:TF_TensorPtr; const I_method:TF_TensorPtr; const I_request:TF_TensorPtr; const A_protocol:string; const A_fail_fast:boolean; const A_timeout_in_ms:integer; const D_address:boolean=false; const D_method:boolean=false; const D_request:boolean=false):TF_TensorPtr;
function ExecRsqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecRsqrtGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecSamplingDataset(const I_input_dataset:TF_TensorPtr; const I_rate:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_rate:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
function ExecScalarSummary(const I_tags:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tags:boolean=false; const D_values:boolean=false):TF_TensorPtr;
function ExecScaleAndTranslate(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const I_scale:TF_TensorPtr; const I_translation:TF_TensorPtr; const A_kernel_type:string; const A_antialias:boolean; const D_images:boolean=false; const D_size:boolean=false; const D_scale:boolean=false; const D_translation:boolean=false):TF_TensorPtr;
function ExecScaleAndTranslateGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const I_scale:TF_TensorPtr; const I_translation:TF_TensorPtr; const A_kernel_type:string; const A_antialias:boolean; const D_grads:boolean=false; const D_original_image:boolean=false; const D_scale:boolean=false; const D_translation:boolean=false):TF_TensorPtr;
function ExecScatterAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterDiv(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterMax(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterMin(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterMul(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNd(const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_indices:boolean=false; const D_updates:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecScatterNdAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNdNonAliasingAdd(const I_input:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_input:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNdSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterNdUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecScatterUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecSdcaFprint(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentMean(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentMin(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentProd(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSelect(const I_condition:TF_TensorPtr; const I_t:TF_TensorPtr; const I_e:TF_TensorPtr; const D_condition:boolean=false; const D_t:boolean=false; const D_e:boolean=false):TF_TensorPtr;
function ExecSelectV2(const I_condition:TF_TensorPtr; const I_t:TF_TensorPtr; const I_e:TF_TensorPtr; const D_condition:boolean=false; const D_t:boolean=false; const D_e:boolean=false):TF_TensorPtr;
function ExecSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecSelu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecSeluGrad(const I_gradients:TF_TensorPtr; const I_outputs:TF_TensorPtr; const D_gradients:boolean=false; const D_outputs:boolean=false):TF_TensorPtr;
function ExecSerializeIterator(const I_resource_handle:TF_TensorPtr; const A_external_state_policy:integer; const D_resource_handle:boolean=false):TF_TensorPtr;
function ExecSerializeManySparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_out_type:TF_DataType; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecSerializeSparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_out_type:TF_DataType; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
function ExecSerializeTensor(const I_tensor:TF_TensorPtr; const D_tensor:boolean=false):TF_TensorPtr;
function ExecSetSize(const I_set_indices:TF_TensorPtr; const I_set_values:TF_TensorPtr; const I_set_shape:TF_TensorPtr; const A_validate_indices:boolean; const D_set_indices:boolean=false; const D_set_values:boolean=false; const D_set_shape:boolean=false):TF_TensorPtr;
function ExecSetStatsAggregatorDataset(const I_input_dataset:TF_TensorPtr; const I_stats_aggregator:TF_TensorPtr; const I_tag:TF_TensorPtr; const I_counter_prefix:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_stats_aggregator:boolean=false; const D_tag:boolean=false; const D_counter_prefix:boolean=false):TF_TensorPtr;
function ExecShape(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecShardDataset(const I_input_dataset:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const I_index:TF_TensorPtr; const A_require_non_empty:boolean; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_shards:boolean=false; const D_index:boolean=false):TF_TensorPtr;
function ExecShardedFilename(const I_basename:TF_TensorPtr; const I_shard:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_shard:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
function ExecShardedFilespec(const I_basename:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
function ExecShuffleAndRepeatDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecShuffleDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_reshuffle_each_iteration:boolean; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
function ExecShuffleDatasetV2(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed_generator:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed_generator:boolean=false):TF_TensorPtr;
function ExecSigmoid(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSigmoidGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecSign(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSize(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecSkipDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecSleepDataset(const I_input_dataset:TF_TensorPtr; const I_sleep_microseconds:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_sleep_microseconds:boolean=false):TF_TensorPtr;
function ExecSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_size:TF_TensorPtr; const D_input:boolean=false; const D_begin:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecSlidingWindowDataset(const I_input_dataset:TF_TensorPtr; const I_window_size:TF_TensorPtr; const I_window_shift:TF_TensorPtr; const I_window_stride:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_window_size:boolean=false; const D_window_shift:boolean=false; const D_window_stride:boolean=false):TF_TensorPtr;
function ExecSnapshot(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecSnapshotDataset(const I_input_dataset:TF_TensorPtr; const I_path:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_compression:string; const A_reader_path_prefix:string; const A_writer_path_prefix:string; const A_shard_size_bytes:integer; const A_pending_snapshot_expiry_seconds:integer; const A_num_reader_threads:integer; const A_reader_buffer_size:integer; const A_num_writer_threads:integer; const A_writer_buffer_size:integer; const A_shuffle_on_read:boolean; const A_seed:integer; const A_seed2:integer; const A_mode:string; const A_snapshot_name:string; const D_input_dataset:boolean=false; const D_path:boolean=false):TF_TensorPtr;
function ExecSobolSample(const I_dim:TF_TensorPtr; const I_num_results:TF_TensorPtr; const I_skip:TF_TensorPtr; const A_dtype:TF_DataType; const D_dim:boolean=false; const D_num_results:boolean=false; const D_skip:boolean=false):TF_TensorPtr;
function ExecSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
function ExecSoftplus(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecSoftplusGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecSoftsign(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
function ExecSoftsignGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
function ExecSpaceToBatch(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_block_size:integer; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecSpaceToBatchND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
function ExecSpaceToDepth(const I_input:TF_TensorPtr; const A_block_size:integer; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
function ExecSparseApplyAdagradV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecSparseApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
function ExecSparseApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
function ExecSparseApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecSparseConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):TF_TensorPtr;
function ExecSparseDenseCwiseAdd(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
function ExecSparseDenseCwiseDiv(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
function ExecSparseDenseCwiseMul(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
function ExecSparseMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseMatrixAdd(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_beta:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false; const D_alpha:boolean=false; const D_beta:boolean=false):TF_TensorPtr;
function ExecSparseMatrixMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const A_transpose_output:boolean; const A_conjugate_output:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseMatrixMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseMatrixNNZ(const I_sparse_matrix:TF_TensorPtr; const D_sparse_matrix:boolean=false):TF_TensorPtr;
function ExecSparseMatrixOrderingAMD(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecSparseMatrixSoftmax(const I_logits:TF_TensorPtr; const A_type:TF_DataType; const D_logits:boolean=false):TF_TensorPtr;
function ExecSparseMatrixSoftmaxGrad(const I_softmax:TF_TensorPtr; const I_grad_softmax:TF_TensorPtr; const A_type:TF_DataType; const D_softmax:boolean=false; const D_grad_softmax:boolean=false):TF_TensorPtr;
function ExecSparseMatrixSparseCholesky(const I_input:TF_TensorPtr; const I_permutation:TF_TensorPtr; const A_type:TF_DataType; const D_input:boolean=false; const D_permutation:boolean=false):TF_TensorPtr;
function ExecSparseMatrixSparseMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_type:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseMatrixTranspose(const I_input:TF_TensorPtr; const A_conjugate:boolean; const A_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecSparseMatrixZeros(const I_dense_shape:TF_TensorPtr; const A_type:TF_DataType; const D_dense_shape:boolean=false):TF_TensorPtr;
function ExecSparseReduceMax(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
function ExecSparseReduceSum(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
function ExecSparseSegmentMean(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSparseSegmentMeanGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
function ExecSparseSegmentMeanWithNumSegments(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSqrtN(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSqrtNGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSqrtNWithNumSegments(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSum(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
function ExecSparseSegmentSumWithNumSegments(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecSparseSliceGrad(const I_backprop_val_grad:TF_TensorPtr; const I_input_indices:TF_TensorPtr; const I_input_start:TF_TensorPtr; const I_output_indices:TF_TensorPtr; const D_backprop_val_grad:boolean=false; const D_input_indices:boolean=false; const D_input_start:boolean=false; const D_output_indices:boolean=false):TF_TensorPtr;
function ExecSparseSoftmax(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false):TF_TensorPtr;
function ExecSparseTensorDenseAdd(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseTensorDenseMatMul(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
function ExecSparseTensorSliceDataset(const I_indices:TF_TensorPtr; const I_values:TF_TensorPtr; const I_dense_shape:TF_TensorPtr; const D_indices:boolean=false; const D_values:boolean=false; const D_dense_shape:boolean=false):TF_TensorPtr;
function ExecSparseTensorToCSRSparseMatrix(const I_indices:TF_TensorPtr; const I_values:TF_TensorPtr; const I_dense_shape:TF_TensorPtr; const D_indices:boolean=false; const D_values:boolean=false; const D_dense_shape:boolean=false):TF_TensorPtr;
function ExecSparseToDense(const I_sparse_indices:TF_TensorPtr; const I_output_shape:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_default_value:TF_TensorPtr; const A_validate_indices:boolean; const D_sparse_indices:boolean=false; const D_output_shape:boolean=false; const D_sparse_values:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
function ExecSpence(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSqlDataset(const I_driver_name:TF_TensorPtr; const I_data_source_name:TF_TensorPtr; const I_query:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_driver_name:boolean=false; const D_data_source_name:boolean=false; const D_query:boolean=false):TF_TensorPtr;
function ExecSqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSqrtGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecSquare(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecSquaredDifference(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecSqueeze(const I_input:TF_TensorPtr; const A_squeeze_dims:array of integer; const D_input:boolean=false):TF_TensorPtr;
function ExecStack(const A_elem_type:TF_DataType; const A_stack_name:string):TF_TensorPtr;
function ExecStackPop(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
function ExecStackPopV2(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
function ExecStackPush(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
function ExecStackPushV2(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
function ExecStackV2(const I_max_size:TF_TensorPtr; const A_elem_type:TF_DataType; const A_stack_name:string; const D_max_size:boolean=false):TF_TensorPtr;
function ExecStageSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecStatefulRandomBinomial(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const I_counts:TF_TensorPtr; const I_probs:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false; const D_counts:boolean=false; const D_probs:boolean=false):TF_TensorPtr;
function ExecStatefulStandardNormal(const I_resource:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecStatefulStandardNormalV2(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecStatefulTruncatedNormal(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecStatefulUniform(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecStatefulUniformFullInt(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
function ExecStatefulUniformInt(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
function ExecStatelessMultinomial(const I_logits:TF_TensorPtr; const I_num_samples:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_output_dtype:TF_DataType; const D_logits:boolean=false; const D_num_samples:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStatelessRandomBinomial(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_counts:TF_TensorPtr; const I_probs:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false; const D_counts:boolean=false; const D_probs:boolean=false):TF_TensorPtr;
function ExecStatelessRandomGammaV2(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_alpha:TF_TensorPtr; const D_shape:boolean=false; const D_seed:boolean=false; const D_alpha:boolean=false):TF_TensorPtr;
function ExecStatelessRandomNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStatelessRandomPoisson(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_lam:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false; const D_lam:boolean=false):TF_TensorPtr;
function ExecStatelessRandomUniform(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStatelessRandomUniformInt(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const D_shape:boolean=false; const D_seed:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
function ExecStatelessTruncatedNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
function ExecStaticRegexFullMatch(const I_input:TF_TensorPtr; const A_pattern:string; const D_input:boolean=false):TF_TensorPtr;
function ExecStaticRegexReplace(const I_input:TF_TensorPtr; const A_pattern:string; const A_rewrite:string; const A_replace_global:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecStatsAggregatorHandle(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecStatsAggregatorHandleV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecStatsAggregatorSummary(const I_iterator:TF_TensorPtr; const D_iterator:boolean=false):TF_TensorPtr;
function ExecStopGradient(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecStridedSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_input:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
function ExecStridedSliceAssign(const I_ref:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_value:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_ref:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecStridedSliceGrad(const I_shape:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_dy:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_shape:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecStringLength(const I_input:TF_TensorPtr; const A_unit:string; const D_input:boolean=false):TF_TensorPtr;
function ExecStringLower(const I_input:TF_TensorPtr; const A_encoding:string; const D_input:boolean=false):TF_TensorPtr;
function ExecStringStrip(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecStringToHashBucket(const I_string_tensor:TF_TensorPtr; const A_num_buckets:integer; const D_string_tensor:boolean=false):TF_TensorPtr;
function ExecStringToHashBucketFast(const I_input:TF_TensorPtr; const A_num_buckets:integer; const D_input:boolean=false):TF_TensorPtr;
function ExecStringToHashBucketStrong(const I_input:TF_TensorPtr; const A_num_buckets:integer; const A_key:array of integer; const D_input:boolean=false):TF_TensorPtr;
function ExecStringToNumber(const I_string_tensor:TF_TensorPtr; const A_out_type:TF_DataType; const D_string_tensor:boolean=false):TF_TensorPtr;
function ExecStringUpper(const I_input:TF_TensorPtr; const A_encoding:string; const D_input:boolean=false):TF_TensorPtr;
function ExecSub(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecSubstr(const I_input:TF_TensorPtr; const I_pos:TF_TensorPtr; const I_len:TF_TensorPtr; const A_unit:string; const D_input:boolean=false; const D_pos:boolean=false; const D_len:boolean=false):TF_TensorPtr;
function ExecSum(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
function ExecSummaryWriter(const A_shared_name:string; const A_container:string):TF_TensorPtr;
function ExecTFRecordDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
function ExecTFRecordReader(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
function ExecTFRecordReaderV2(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
function ExecTPUCompilationResult():TF_TensorPtr;
function ExecTPUEmbeddingActivations(const I_embedding_variable:TF_TensorPtr; const I_sliced_activations:TF_TensorPtr; const A_table_id:integer; const A_lookup_id:integer; const D_embedding_variable:boolean=false; const D_sliced_activations:boolean=false):TF_TensorPtr;
function ExecTPUOrdinalSelector():TF_TensorPtr;
function ExecTakeDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
function ExecTan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecTanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecTanhGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
function ExecTemporaryVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):TF_TensorPtr;
function ExecTensorArray(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape; const D_size:boolean=false):TF_TensorPtr;
function ExecTensorArrayGather(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGatherV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGatherV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGrad(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayGradV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayPack(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayRead(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayReadV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayReadV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayScatter(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayScatterV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayScatterV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySize(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySizeV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySizeV3(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySplit(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySplitV2(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArraySplitV3(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayUnpack(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayV2(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const D_size:boolean=false):TF_TensorPtr;
function ExecTensorArrayWrite(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayWriteV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorArrayWriteV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
function ExecTensorForestTreeIsInitializedOp(const I_tree_handle:TF_TensorPtr; const D_tree_handle:boolean=false):TF_TensorPtr;
function ExecTensorForestTreePredict(const I_tree_handle:TF_TensorPtr; const I_dense_features:TF_TensorPtr; const A_logits_dimension:integer; const D_tree_handle:boolean=false; const D_dense_features:boolean=false):TF_TensorPtr;
function ExecTensorForestTreeResourceHandleOp(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecTensorForestTreeSerialize(const I_tree_handle:TF_TensorPtr; const D_tree_handle:boolean=false):TF_TensorPtr;
function ExecTensorForestTreeSize(const I_tree_handle:TF_TensorPtr; const D_tree_handle:boolean=false):TF_TensorPtr;
function ExecTensorListConcatLists(const I_input_a:TF_TensorPtr; const I_input_b:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_input_a:boolean=false; const D_input_b:boolean=false):TF_TensorPtr;
function ExecTensorListElementShape(const I_input_handle:TF_TensorPtr; const A_shape_type:TF_DataType; const D_input_handle:boolean=false):TF_TensorPtr;
function ExecTensorListFromTensor(const I_tensor:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
function ExecTensorListGather(const I_input_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_input_handle:boolean=false; const D_indices:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
function ExecTensorListGetItem(const I_input_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_input_handle:boolean=false; const D_index:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
function ExecTensorListLength(const I_input_handle:TF_TensorPtr; const D_input_handle:boolean=false):TF_TensorPtr;
function ExecTensorListPushBack(const I_input_handle:TF_TensorPtr; const I_tensor:TF_TensorPtr; const D_input_handle:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
function ExecTensorListPushBackBatch(const I_input_handles:TF_TensorPtr; const I_tensor:TF_TensorPtr; const D_input_handles:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
function ExecTensorListReserve(const I_element_shape:TF_TensorPtr; const I_num_elements:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_element_shape:boolean=false; const D_num_elements:boolean=false):TF_TensorPtr;
function ExecTensorListResize(const I_input_handle:TF_TensorPtr; const I_size:TF_TensorPtr; const D_input_handle:boolean=false; const D_size:boolean=false):TF_TensorPtr;
function ExecTensorListScatter(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
function ExecTensorListScatterIntoExistingList(const I_input_handle:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_input_handle:boolean=false; const D_tensor:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
function ExecTensorListScatterV2(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const I_num_elements:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_element_shape:boolean=false; const D_num_elements:boolean=false):TF_TensorPtr;
function ExecTensorListSetItem(const I_input_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_item:TF_TensorPtr; const D_input_handle:boolean=false; const D_index:boolean=false; const D_item:boolean=false):TF_TensorPtr;
function ExecTensorListSplit(const I_tensor:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const I_lengths:TF_TensorPtr; const D_tensor:boolean=false; const D_element_shape:boolean=false; const D_lengths:boolean=false):TF_TensorPtr;
function ExecTensorListStack(const I_input_handle:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const A_element_dtype:TF_DataType; const A_num_elements:integer; const D_input_handle:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
function ExecTensorScatterAdd(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecTensorScatterSub(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecTensorScatterUpdate(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
function ExecTensorStridedSliceUpdate(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_value:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_input:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_value:boolean=false):TF_TensorPtr;
function ExecTensorSummary(const I_tensor:TF_TensorPtr; const A_description:string; const A_labels:array of string; const A_display_name:string; const D_tensor:boolean=false):TF_TensorPtr;
function ExecTensorSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_serialized_summary_metadata:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false; const D_serialized_summary_metadata:boolean=false):TF_TensorPtr;
function ExecTextLineDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
function ExecTextLineReader(const A_skip_header_lines:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecTextLineReaderV2(const A_skip_header_lines:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_thread_pool:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_thread_pool:boolean=false):TF_TensorPtr;
function ExecThreadPoolHandle(const A_num_threads:integer; const A_max_intra_op_parallelism:integer; const A_display_name:string; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecTile(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
function ExecTileGrad(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
function ExecTimestamp():TF_TensorPtr;
function ExecToBool(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecTranspose(const I_x:TF_TensorPtr; const I_perm:TF_TensorPtr; const D_x:boolean=false; const D_perm:boolean=false):TF_TensorPtr;
function ExecTridiagonalMatMul(const I_superdiag:TF_TensorPtr; const I_maindiag:TF_TensorPtr; const I_subdiag:TF_TensorPtr; const I_rhs:TF_TensorPtr; const D_superdiag:boolean=false; const D_maindiag:boolean=false; const D_subdiag:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecTridiagonalSolve(const I_diagonals:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_partial_pivoting:boolean; const D_diagonals:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
function ExecTruncateDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecTruncateMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecTruncatedNormal(const I_shape:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
function ExecUnbatch(const I_batched_tensor:TF_TensorPtr; const I_batch_index:TF_TensorPtr; const I_id:TF_TensorPtr; const A_timeout_micros:integer; const A_container:string; const A_shared_name:string; const D_batched_tensor:boolean=false; const D_batch_index:boolean=false; const D_id:boolean=false):TF_TensorPtr;
function ExecUnbatchDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecUnbatchGrad(const I_original_input:TF_TensorPtr; const I_batch_index:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_id:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_original_input:boolean=false; const D_batch_index:boolean=false; const D_grad:boolean=false; const D_id:boolean=false):TF_TensorPtr;
function ExecUnicodeEncode(const I_input_values:TF_TensorPtr; const I_input_splits:TF_TensorPtr; const A_errors:string; const A_output_encoding:string; const A_replacement_char:integer; const D_input_values:boolean=false; const D_input_splits:boolean=false):TF_TensorPtr;
function ExecUnicodeScript(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecUnicodeTranscode(const I_input:TF_TensorPtr; const A_input_encoding:string; const A_output_encoding:string; const A_errors:string; const A_replacement_char:integer; const A_replace_control_characters:boolean; const D_input:boolean=false):TF_TensorPtr;
function ExecUniqueDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
function ExecUnravelIndex(const I_indices:TF_TensorPtr; const I_dims:TF_TensorPtr; const D_indices:boolean=false; const D_dims:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentJoin(const I_inputs:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const A_separator:string; const D_inputs:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentMin(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentProd(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecUnsortedSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
function ExecUnwrapDatasetVariant(const I_input_handle:TF_TensorPtr; const D_input_handle:boolean=false):TF_TensorPtr;
function ExecUpperBound(const I_sorted_inputs:TF_TensorPtr; const I_values:TF_TensorPtr; const A_out_type:TF_DataType; const D_sorted_inputs:boolean=false; const D_values:boolean=false):TF_TensorPtr;
function ExecVarHandleOp(const A_container:string; const A_shared_name:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
function ExecVarIsInitializedOp(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
function ExecVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecVariableShape(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
function ExecVariableV2(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecWhere(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
function ExecWholeFileReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecWholeFileReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
function ExecWindowDataset(const I_input_dataset:TF_TensorPtr; const I_size:TF_TensorPtr; const I_shift:TF_TensorPtr; const I_stride:TF_TensorPtr; const I_drop_remainder:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_size:boolean=false; const D_shift:boolean=false; const D_stride:boolean=false; const D_drop_remainder:boolean=false):TF_TensorPtr;
function ExecWorkerHeartbeat(const I_request:TF_TensorPtr; const D_request:boolean=false):TF_TensorPtr;
function ExecWrapDatasetVariant(const I_input_handle:TF_TensorPtr; const D_input_handle:boolean=false):TF_TensorPtr;
function ExecXdivy(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecXlog1py(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecXlogy(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
function ExecZerosLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
function ExecZeta(const I_x:TF_TensorPtr; const I_q:TF_TensorPtr; const D_x:boolean=false; const D_q:boolean=false):TF_TensorPtr;


implementation

//  The TGraphExt methods
function TGraphExt.AddAbort(const A_error_msg:string; const A_exit_without_error:boolean):string;
  begin
  result:=AddOper('Abort',[],[],[],[],['error_msg','exit_without_error'],['string','bool'],[@A_error_msg,@A_exit_without_error])
  end;
function TGraphExt.AddAbs(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Abs',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAccumulateNV2(const IL_inputs:string; const O_sum:string; const A_N:cint64; const A_T:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('AccumulateNV2',[],[IL_inputs],[A_N],[O_sum],['N','T','shape'],['int','type','shape'],[@A_N,@A_T,@A_shape])
  end;
function TGraphExt.AddAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AccumulatorApplyGradient',[I_handle,I_local_step,I_gradient],[],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAccumulatorNumAccumulated(const I_handle:string; const O_num_accumulated:string):string;
  begin
  result:=AddOper('AccumulatorNumAccumulated',[I_handle],[],[],[O_num_accumulated],[],[],[])
  end;
function TGraphExt.AddAccumulatorSetGlobalStep(const I_handle:string; const I_new_global_step:string):string;
  begin
  result:=AddOper('AccumulatorSetGlobalStep',[I_handle,I_new_global_step],[],[],[],[],[],[])
  end;
function TGraphExt.AddAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_average:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AccumulatorTakeGradient',[I_handle,I_num_required],[],[],[O_average],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAcos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Acos',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAcosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Acosh',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Add',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAddManySparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handles:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('AddManySparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[],[O_sparse_handles],['T','container','shared_name'],['type','string','string'],[@A_T,@A_container,@A_shared_name])
  end;
function TGraphExt.AddAddN(const IL_inputs:string; const O_sum:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AddN',[],[IL_inputs],[A_N],[O_sum],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddAddSparseToTensorsMap(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_sparse_handle:string; const A_T:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('AddSparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[],[O_sparse_handle],['T','container','shared_name'],['type','string','string'],[@A_T,@A_container,@A_shared_name])
  end;
function TGraphExt.AddAddV2(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AddV2',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdjustContrast(const I_images:string; const I_contrast_factor:string; const I_min_value:string; const I_max_value:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AdjustContrast',[I_images,I_contrast_factor,I_min_value,I_max_value],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdjustContrastv2(const I_images:string; const I_contrast_factor:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AdjustContrastv2',[I_images,I_contrast_factor],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdjustHue(const I_images:string; const I_delta:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AdjustHue',[I_images,I_delta],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAdjustSaturation(const I_images:string; const I_scale:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AdjustSaturation',[I_images,I_scale],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAll(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('All',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@A_Tidx])
  end;
function TGraphExt.AddAllCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('AllCandidateSampler',[I_true_classes],[],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','seed','seed2'],['int','int','bool','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_seed,@A_seed2])
  end;
function TGraphExt.AddAllToAll(const I_input:string; const I_group_assignment:string; const O_output:string; const A_T:TF_DataType; const A_concat_dimension:cint64; const A_split_dimension:cint64; const A_split_count:cint64):string;
  begin
  result:=AddOper('AllToAll',[I_input,I_group_assignment],[],[],[O_output],['T','concat_dimension','split_dimension','split_count'],['type','int','int','int'],[@A_T,@A_concat_dimension,@A_split_dimension,@A_split_count])
  end;
function TGraphExt.AddAngle(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Angle',[I_input],[],[],[O_output],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddAnonymousIterator(const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('AnonymousIterator',[],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddAnonymousIteratorV2(const O_handle:string; const O_deleter:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('AnonymousIteratorV2',[],[],[],[O_handle,O_deleter],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddAnonymousMemoryCache(const O_handle:string; const O_deleter:string):string;
  begin
  result:=AddOper('AnonymousMemoryCache',[],[],[],[O_handle,O_deleter],[],[],[])
  end;
function TGraphExt.AddAnonymousMultiDeviceIterator(const O_handle:string; const O_deleter:string; const A_devices:TF_StringList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('AnonymousMultiDeviceIterator',[],[],[],[O_handle,O_deleter],['devices','output_types','output_shapes'],['list(string)','list(type)','list(shape)'],[@A_devices,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddAnonymousRandomSeedGenerator(const I_seed:string; const I_seed2:string; const O_handle:string; const O_deleter:string):string;
  begin
  result:=AddOper('AnonymousRandomSeedGenerator',[I_seed,I_seed2],[],[],[O_handle,O_deleter],[],[],[])
  end;
function TGraphExt.AddAny(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Any',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@A_Tidx])
  end;
function TGraphExt.AddApplyAdaMax(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAdaMax',[I_var,I_m,I_v,I_beta1_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('ApplyAdagrad',[I_var,I_accum,I_lr,I_grad],[],[],[O_out],['T','use_locking','update_slots'],['type','bool','bool'],[@A_T,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_lr,I_l1,I_l2,I_global_step],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('ApplyAdagradV2',[I_var,I_accum,I_lr,I_epsilon,I_grad],[],[],[O_out],['T','use_locking','update_slots'],['type','bool','bool'],[@A_T,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ApplyAdam',[I_var,I_m,I_v,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[],[O_out],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddApplyAddSign(const I_var:string; const I_m:string; const I_lr:string; const I_alpha:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyAddSign',[I_var,I_m,I_lr,I_alpha,I_sign_decay,I_beta,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_lr_power],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyGradientDescent',[I_var,I_alpha,I_delta],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],[],[],[O_out],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddApplyPowerSign(const I_var:string; const I_m:string; const I_lr:string; const I_logbase:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyPowerSign',[I_var,I_m,I_lr,I_logbase,I_sign_decay,I_beta,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_delta],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const O_out:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[],[O_out],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddApproximateEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_tolerance:real):string;
  begin
  result:=AddOper('ApproximateEqual',[I_x,I_y],[],[],[O_z],['T','tolerance'],['type','float'],[@A_T,@A_tolerance])
  end;
function TGraphExt.AddArgMax(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
  begin
  result:=AddOper('ArgMax',[I_input,I_dimension],[],[],[O_output],['T','Tidx','output_type'],['type','type','type'],[@A_T,@A_Tidx,@A_output_type])
  end;
function TGraphExt.AddArgMin(const I_input:string; const I_dimension:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_output_type:TF_DataType):string;
  begin
  result:=AddOper('ArgMin',[I_input,I_dimension],[],[],[O_output],['T','Tidx','output_type'],['type','type','type'],[@A_T,@A_Tidx,@A_output_type])
  end;
function TGraphExt.AddAsString(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_precision:cint64; const A_scientific:boolean; const A_shortest:boolean; const A_width:cint64; const A_fill:string):string;
  begin
  result:=AddOper('AsString',[I_input],[],[],[O_output],['T','precision','scientific','shortest','width','fill'],['type','int','bool','bool','int','string'],[@A_T,@A_precision,@A_scientific,@A_shortest,@A_width,@A_fill])
  end;
function TGraphExt.AddAsin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Asin',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAsinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Asinh',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAssert(const I_condition:string; const IL_data:string; const A_T:TF_TypeList; const A_summarize:cint64):string;
  begin
  result:=AddOper('Assert',[I_condition],[IL_data],[Length(A_T)],[],['T','summarize'],['list(type)','int'],[@A_T,@A_summarize])
  end;
function TGraphExt.AddAssertNextDataset(const I_input_dataset:string; const I_transformations:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('AssertNextDataset',[I_input_dataset,I_transformations],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddAssign(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_validate_shape:boolean; const A_use_locking:boolean):string;
  begin
  result:=AddOper('Assign',[I_ref,I_value],[],[],[O_output_ref],['T','validate_shape','use_locking'],['type','bool','bool'],[@A_T,@A_validate_shape,@A_use_locking])
  end;
function TGraphExt.AddAssignAdd(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('AssignAdd',[I_ref,I_value],[],[],[O_output_ref],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddAssignAddVariableOp(const I_resource:string; const I_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AssignAddVariableOp',[I_resource,I_value],[],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAssignSub(const I_ref:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('AssignSub',[I_ref,I_value],[],[],[O_output_ref],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddAssignSubVariableOp(const I_resource:string; const I_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AssignSubVariableOp',[I_resource,I_value],[],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAssignVariableOp(const I_resource:string; const I_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('AssignVariableOp',[I_resource,I_value],[],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddAtan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Atan',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAtan2(const I_y:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Atan2',[I_y,I_x],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAtanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Atanh',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddAudioSpectrogram(const I_input:string; const O_spectrogram:string; const A_window_size:cint64; const A_stride:cint64; const A_magnitude_squared:boolean):string;
  begin
  result:=AddOper('AudioSpectrogram',[I_input],[],[],[O_spectrogram],['window_size','stride','magnitude_squared'],['int','int','bool'],[@A_window_size,@A_stride,@A_magnitude_squared])
  end;
function TGraphExt.AddAudioSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_sample_rate:real; const A_max_outputs:cint64):string;
  begin
  result:=AddOper('AudioSummary',[I_tag,I_tensor],[],[],[O_summary],['sample_rate','max_outputs'],['float','int'],[@A_sample_rate,@A_max_outputs])
  end;
function TGraphExt.AddAudioSummaryV2(const I_tag:string; const I_tensor:string; const I_sample_rate:string; const O_summary:string; const A_max_outputs:cint64):string;
  begin
  result:=AddOper('AudioSummaryV2',[I_tag,I_tensor,I_sample_rate],[],[],[O_summary],['max_outputs'],['int'],[@A_max_outputs])
  end;
function TGraphExt.AddAutoShardDataset(const I_input_dataset:string; const I_num_workers:string; const I_index:string; const O_handle:string; const A_auto_shard_policy:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('AutoShardDataset',[I_input_dataset,I_num_workers,I_index],[],[],[O_handle],['auto_shard_policy','output_types','output_shapes'],['int','list(type)','list(shape)'],[@A_auto_shard_policy,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddAvgPool(const I_value:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPool',[I_value],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddAvgPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPool3D',[I_input],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddAvgPool3DGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPool3DGrad',[I_orig_input_shape,I_grad],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddAvgPoolGrad(const I_orig_input_shape:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('AvgPoolGrad',[I_orig_input_shape,I_grad],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddBarrier(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Barrier',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddBarrierClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
  begin
  result:=AddOper('BarrierClose',[I_handle],[],[],[],['cancel_pending_enqueues'],['bool'],[@A_cancel_pending_enqueues])
  end;
function TGraphExt.AddBarrierIncompleteSize(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('BarrierIncompleteSize',[I_handle],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddBarrierInsertMany(const I_handle:string; const I_keys:string; const I_values:string; const A_T:TF_DataType; const A_component_index:cint64):string;
  begin
  result:=AddOper('BarrierInsertMany',[I_handle,I_keys,I_values],[],[],[],['T','component_index'],['type','int'],[@A_T,@A_component_index])
  end;
function TGraphExt.AddBarrierReadySize(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('BarrierReadySize',[I_handle],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddBarrierTakeMany(const I_handle:string; const I_num_elements:string; const O_indices:string; const O_keys:string; const OL_values:string; const A_component_types:TF_TypeList; const A_allow_small_batch:boolean; const A_wait_for_incomplete:boolean; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('BarrierTakeMany',[I_handle,I_num_elements],[],[],[O_indices,O_keys,OL_values],['component_types','allow_small_batch','wait_for_incomplete','timeout_ms'],['list(type)','bool','bool','int'],[@A_component_types,@A_allow_small_batch,@A_wait_for_incomplete,@A_timeout_ms])
  end;
function TGraphExt.AddBatch(const IL_in_tensors:string; const O_batch_index:string; const O_id:string; const OL_batched_tensors:string; const A_num_batch_threads:cint64; const A_max_batch_size:cint64; const A_max_enqueued_batches:cint64; const A_batch_timeout_micros:cint64; const A_allowed_batch_sizes:TF_IntList; const A_grad_timeout_micros:cint64; const A_container:string; const A_shared_name:string; const A_batching_queue:string; const A_T:TF_TypeList):string;
  begin
  result:=AddOper('Batch',[],[IL_in_tensors],[Length(A_T)],[O_batch_index,O_id,OL_batched_tensors],['num_batch_threads','max_batch_size','max_enqueued_batches','batch_timeout_micros','allowed_batch_sizes','grad_timeout_micros','container','shared_name','batching_queue','T'],['int','int','int','int','list(int)','int','string','string','string','list(type)'],[@A_num_batch_threads,@A_max_batch_size,@A_max_enqueued_batches,@A_batch_timeout_micros,@A_allowed_batch_sizes,@A_grad_timeout_micros,@A_container,@A_shared_name,@A_batching_queue,@A_T])
  end;
function TGraphExt.AddBatchCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchCholesky',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchCholeskyGrad',[I_l,I_grad],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchDataset(const I_input_dataset:string; const I_batch_size:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('BatchDataset',[I_input_dataset,I_batch_size],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddBatchDatasetV2(const I_input_dataset:string; const I_batch_size:string; const I_drop_remainder:string; const O_handle:string; const A_parallel_copy:boolean; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('BatchDatasetV2',[I_input_dataset,I_batch_size,I_drop_remainder],[],[],[O_handle],['parallel_copy','output_types','output_shapes'],['bool','list(type)','list(shape)'],[@A_parallel_copy,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddBatchFFT(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchFFT',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchFFT2D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchFFT2D',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchFFT3D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchFFT3D',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchFunction(const IL_in_tensors:string; const IL_captured_tensors:string; const OL_out_tensors:string; const A_f:TF_Function; const A_num_batch_threads:cint64; const A_max_batch_size:cint64; const A_batch_timeout_micros:cint64; const A_max_enqueued_batches:cint64; const A_allowed_batch_sizes:TF_IntList; const A_container:string; const A_shared_name:string; const A_batching_queue:string; const A_Tin:TF_TypeList; const A_Tcaptured:TF_TypeList; const A_Tout:TF_TypeList):string;
  begin
  result:=AddOper('BatchFunction',[],[IL_in_tensors,IL_captured_tensors],[Length(A_Tin),Length(A_Tcaptured)],[OL_out_tensors],['f','num_batch_threads','max_batch_size','batch_timeout_micros','max_enqueued_batches','allowed_batch_sizes','container','shared_name','batching_queue','Tin','Tcaptured','Tout'],['func','int','int','int','int','list(int)','string','string','string','list(type)','list(type)','list(type)'],[@A_f,@A_num_batch_threads,@A_max_batch_size,@A_batch_timeout_micros,@A_max_enqueued_batches,@A_allowed_batch_sizes,@A_container,@A_shared_name,@A_batching_queue,@A_Tin,@A_Tcaptured,@A_Tout])
  end;
function TGraphExt.AddBatchIFFT(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchIFFT',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchIFFT2D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchIFFT2D',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchIFFT3D(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('BatchIFFT3D',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddBatchMatMul(const I_x:string; const I_y:string; const O_output:string; const A_T:TF_DataType; const A_adj_x:boolean; const A_adj_y:boolean):string;
  begin
  result:=AddOper('BatchMatMul',[I_x,I_y],[],[],[O_output],['T','adj_x','adj_y'],['type','bool','bool'],[@A_T,@A_adj_x,@A_adj_y])
  end;
function TGraphExt.AddBatchMatMulV2(const I_x:string; const I_y:string; const O_output:string; const A_T:TF_DataType; const A_adj_x:boolean; const A_adj_y:boolean):string;
  begin
  result:=AddOper('BatchMatMulV2',[I_x,I_y],[],[],[O_output],['T','adj_x','adj_y'],['type','bool','bool'],[@A_T,@A_adj_x,@A_adj_y])
  end;
function TGraphExt.AddBatchMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixBandPart',[I_input,I_num_lower,I_num_upper],[],[],[O_band],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixDeterminant',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixDiag',[I_diagonal],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixDiagPart',[I_input],[],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixInverse',[I_input],[],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddBatchMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixSetDiag',[I_input,I_diagonal],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixSolve',[I_matrix,I_rhs],[],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddBatchMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
  begin
  result:=AddOper('BatchMatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],[],[],[O_output],['T','fast'],['type','bool'],[@A_T,@A_fast])
  end;
function TGraphExt.AddBatchMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchMatrixTriangularSolve',[I_matrix,I_rhs],[],[],[O_output],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@A_T])
  end;
function TGraphExt.AddBatchNormWithGlobalNormalization(const I_t:string; const I_m:string; const I_v:string; const I_beta:string; const I_gamma:string; const O_result:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
  begin
  result:=AddOper('BatchNormWithGlobalNormalization',[I_t,I_m,I_v,I_beta,I_gamma],[],[],[O_result],['T','variance_epsilon','scale_after_normalization'],['type','float','bool'],[@A_T,@A_variance_epsilon,@A_scale_after_normalization])
  end;
function TGraphExt.AddBatchNormWithGlobalNormalizationGrad(const I_t:string; const I_m:string; const I_v:string; const I_gamma:string; const I_backprop:string; const O_dx:string; const O_dm:string; const O_dv:string; const O_db:string; const O_dg:string; const A_T:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
  begin
  result:=AddOper('BatchNormWithGlobalNormalizationGrad',[I_t,I_m,I_v,I_gamma,I_backprop],[],[],[O_dx,O_dm,O_dv,O_db,O_dg],['T','variance_epsilon','scale_after_normalization'],['type','float','bool'],[@A_T,@A_variance_epsilon,@A_scale_after_normalization])
  end;
function TGraphExt.AddBatchSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchSelfAdjointEig',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBatchSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchSelfAdjointEigV2',[I_input],[],[],[O_e,O_v],['compute_v','T'],['bool','type'],[@A_compute_v,@A_T])
  end;
function TGraphExt.AddBatchSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BatchSvd',[I_input],[],[],[O_s,O_u,O_v],['compute_uv','full_matrices','T'],['bool','bool','type'],[@A_compute_uv,@A_full_matrices,@A_T])
  end;
function TGraphExt.AddBatchToSpace(const I_input:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('BatchToSpace',[I_input,I_crops],[],[],[O_output],['T','block_size','Tidx'],['type','int','type'],[@A_T,@A_block_size,@A_Tidx])
  end;
function TGraphExt.AddBatchToSpaceND(const I_input:string; const I_block_shape:string; const I_crops:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tcrops:TF_DataType):string;
  begin
  result:=AddOper('BatchToSpaceND',[I_input,I_block_shape,I_crops],[],[],[O_output],['T','Tblock_shape','Tcrops'],['type','type','type'],[@A_T,@A_Tblock_shape,@A_Tcrops])
  end;
function TGraphExt.AddBesselI0e(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BesselI0e',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBesselI1e(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BesselI1e',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBetainc(const I_a:string; const I_b:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Betainc',[I_a,I_b,I_x],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBiasAdd(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
  begin
  result:=AddOper('BiasAdd',[I_value,I_bias],[],[],[O_output],['T','data_format'],['type','string'],[@A_T,@A_data_format])
  end;
function TGraphExt.AddBiasAddGrad(const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_data_format:string):string;
  begin
  result:=AddOper('BiasAddGrad',[I_out_backprop],[],[],[O_output],['T','data_format'],['type','string'],[@A_T,@A_data_format])
  end;
function TGraphExt.AddBiasAddV1(const I_value:string; const I_bias:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BiasAddV1',[I_value,I_bias],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBincount(const I_arr:string; const I_size:string; const I_weights:string; const O_bins:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Bincount',[I_arr,I_size,I_weights],[],[],[O_bins],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBitcast(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_type:TF_DataType):string;
  begin
  result:=AddOper('Bitcast',[I_input],[],[],[O_output],['T','type'],['type','type'],[@A_T,@A_type])
  end;
function TGraphExt.AddBitwiseAnd(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BitwiseAnd',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBitwiseOr(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BitwiseOr',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBitwiseXor(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BitwiseXor',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBlockLSTM(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const O_i:string; const O_cs:string; const O_f:string; const O_o:string; const O_ci:string; const O_co:string; const O_h:string; const A_forget_bias:real; const A_cell_clip:real; const A_use_peephole:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BlockLSTM',[I_seq_len_max,I_x,I_cs_prev,I_h_prev,I_w,I_wci,I_wcf,I_wco,I_b],[],[],[O_i,O_cs,O_f,O_o,O_ci,O_co,O_h],['forget_bias','cell_clip','use_peephole','T'],['float','float','bool','type'],[@A_forget_bias,@A_cell_clip,@A_use_peephole,@A_T])
  end;
function TGraphExt.AddBlockLSTMGrad(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const I_i:string; const I_cs:string; const I_f:string; const I_o:string; const I_ci:string; const I_co:string; const I_h:string; const I_cs_grad:string; const I_h_grad:string; const O_x_grad:string; const O_cs_prev_grad:string; const O_h_prev_grad:string; const O_w_grad:string; const O_wci_grad:string; const O_wcf_grad:string; const O_wco_grad:string; const O_b_grad:string; const A_use_peephole:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BlockLSTMGrad',[I_seq_len_max,I_x,I_cs_prev,I_h_prev,I_w,I_wci,I_wcf,I_wco,I_b,I_i,I_cs,I_f,I_o,I_ci,I_co,I_h,I_cs_grad,I_h_grad],[],[],[O_x_grad,O_cs_prev_grad,O_h_prev_grad,O_w_grad,O_wci_grad,O_wcf_grad,O_wco_grad,O_b_grad],['use_peephole','T'],['bool','type'],[@A_use_peephole,@A_T])
  end;
function TGraphExt.AddBlockLSTMGradV2(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const I_i:string; const I_cs:string; const I_f:string; const I_o:string; const I_ci:string; const I_co:string; const I_h:string; const I_cs_grad:string; const I_h_grad:string; const O_x_grad:string; const O_cs_prev_grad:string; const O_h_prev_grad:string; const O_w_grad:string; const O_wci_grad:string; const O_wcf_grad:string; const O_wco_grad:string; const O_b_grad:string; const A_use_peephole:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BlockLSTMGradV2',[I_seq_len_max,I_x,I_cs_prev,I_h_prev,I_w,I_wci,I_wcf,I_wco,I_b,I_i,I_cs,I_f,I_o,I_ci,I_co,I_h,I_cs_grad,I_h_grad],[],[],[O_x_grad,O_cs_prev_grad,O_h_prev_grad,O_w_grad,O_wci_grad,O_wcf_grad,O_wco_grad,O_b_grad],['use_peephole','T'],['bool','type'],[@A_use_peephole,@A_T])
  end;
function TGraphExt.AddBlockLSTMV2(const I_seq_len_max:string; const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const O_i:string; const O_cs:string; const O_f:string; const O_o:string; const O_ci:string; const O_co:string; const O_h:string; const A_cell_clip:real; const A_use_peephole:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BlockLSTMV2',[I_seq_len_max,I_x,I_cs_prev,I_h_prev,I_w,I_wci,I_wcf,I_wco,I_b],[],[],[O_i,O_cs,O_f,O_o,O_ci,O_co,O_h],['cell_clip','use_peephole','T'],['float','bool','type'],[@A_cell_clip,@A_use_peephole,@A_T])
  end;
function TGraphExt.AddBoostedTreesAggregateStats(const I_node_ids:string; const I_gradients:string; const I_hessians:string; const I_feature:string; const O_stats_summary:string; const A_max_splits:cint64; const A_num_buckets:cint64):string;
  begin
  result:=AddOper('BoostedTreesAggregateStats',[I_node_ids,I_gradients,I_hessians,I_feature],[],[],[O_stats_summary],['max_splits','num_buckets'],['int','int'],[@A_max_splits,@A_num_buckets])
  end;
function TGraphExt.AddBoostedTreesBucketize(const IL_float_values:string; const IL_bucket_boundaries:string; const OL_buckets:string; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesBucketize',[],[IL_float_values,IL_bucket_boundaries],[A_num_features,A_num_features],[OL_buckets],['num_features'],['int'],[@A_num_features])
  end;
function TGraphExt.AddBoostedTreesCalculateBestFeatureSplit(const I_node_id_range:string; const I_stats_summary:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const O_node_ids:string; const O_gains:string; const O_feature_dimensions:string; const O_thresholds:string; const O_left_node_contribs:string; const O_right_node_contribs:string; const O_split_with_default_directions:string; const A_logits_dimension:cint64; const A_split_type:string):string;
  begin
  result:=AddOper('BoostedTreesCalculateBestFeatureSplit',[I_node_id_range,I_stats_summary,I_l1,I_l2,I_tree_complexity,I_min_node_weight],[],[],[O_node_ids,O_gains,O_feature_dimensions,O_thresholds,O_left_node_contribs,O_right_node_contribs,O_split_with_default_directions],['logits_dimension','split_type'],['int','string'],[@A_logits_dimension,@A_split_type])
  end;
function TGraphExt.AddBoostedTreesCalculateBestFeatureSplitV2(const I_node_id_range:string; const I_split_types:string; const I_candidate_feature_ids:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const IL_stats_summaries_list:string; const O_node_ids:string; const O_gains:string; const O_feature_ids:string; const O_feature_dimensions:string; const O_thresholds:string; const O_left_node_contribs:string; const O_right_node_contribs:string; const O_split_with_default_directions:string; const A_num_features:cint64; const A_logits_dimension:cint64):string;
  begin
  result:=AddOper('BoostedTreesCalculateBestFeatureSplitV2',[I_node_id_range,I_split_types,I_candidate_feature_ids,I_l1,I_l2,I_tree_complexity,I_min_node_weight],[IL_stats_summaries_list],[A_num_features],[O_node_ids,O_gains,O_feature_ids,O_feature_dimensions,O_thresholds,O_left_node_contribs,O_right_node_contribs,O_split_with_default_directions],['num_features','logits_dimension'],['int','int'],[@A_num_features,@A_logits_dimension])
  end;
function TGraphExt.AddBoostedTreesCalculateBestGainsPerFeature(const I_node_id_range:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const IL_stats_summary_list:string; const OL_node_ids_list:string; const OL_gains_list:string; const OL_thresholds_list:string; const OL_left_node_contribs_list:string; const OL_right_node_contribs_list:string; const A_max_splits:cint64; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesCalculateBestGainsPerFeature',[I_node_id_range,I_l1,I_l2,I_tree_complexity,I_min_node_weight],[IL_stats_summary_list],[A_num_features],[OL_node_ids_list,OL_gains_list,OL_thresholds_list,OL_left_node_contribs_list,OL_right_node_contribs_list],['max_splits','num_features'],['int','int'],[@A_max_splits,@A_num_features])
  end;
function TGraphExt.AddBoostedTreesCenterBias(const I_tree_ensemble_handle:string; const I_mean_gradients:string; const I_mean_hessians:string; const I_l1:string; const I_l2:string; const O_continue_centering:string):string;
  begin
  result:=AddOper('BoostedTreesCenterBias',[I_tree_ensemble_handle,I_mean_gradients,I_mean_hessians,I_l1,I_l2],[],[],[O_continue_centering],[],[],[])
  end;
function TGraphExt.AddBoostedTreesCreateEnsemble(const I_tree_ensemble_handle:string; const I_stamp_token:string; const I_tree_ensemble_serialized:string):string;
  begin
  result:=AddOper('BoostedTreesCreateEnsemble',[I_tree_ensemble_handle,I_stamp_token,I_tree_ensemble_serialized],[],[],[],[],[],[])
  end;
function TGraphExt.AddBoostedTreesCreateQuantileStreamResource(const I_quantile_stream_resource_handle:string; const I_epsilon:string; const I_num_streams:string; const A_max_elements:cint64):string;
  begin
  result:=AddOper('BoostedTreesCreateQuantileStreamResource',[I_quantile_stream_resource_handle,I_epsilon,I_num_streams],[],[],[],['max_elements'],['int'],[@A_max_elements])
  end;
function TGraphExt.AddBoostedTreesDeserializeEnsemble(const I_tree_ensemble_handle:string; const I_stamp_token:string; const I_tree_ensemble_serialized:string):string;
  begin
  result:=AddOper('BoostedTreesDeserializeEnsemble',[I_tree_ensemble_handle,I_stamp_token,I_tree_ensemble_serialized],[],[],[],[],[],[])
  end;
function TGraphExt.AddBoostedTreesEnsembleResourceHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('BoostedTreesEnsembleResourceHandleOp',[],[],[],[O_resource],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddBoostedTreesExampleDebugOutputs(const I_tree_ensemble_handle:string; const IL_bucketized_features:string; const O_examples_debug_outputs_serialized:string; const A_num_bucketized_features:cint64; const A_logits_dimension:cint64):string;
  begin
  result:=AddOper('BoostedTreesExampleDebugOutputs',[I_tree_ensemble_handle],[IL_bucketized_features],[A_num_bucketized_features],[O_examples_debug_outputs_serialized],['num_bucketized_features','logits_dimension'],['int','int'],[@A_num_bucketized_features,@A_logits_dimension])
  end;
function TGraphExt.AddBoostedTreesFlushQuantileSummaries(const I_quantile_stream_resource_handle:string; const OL_summaries:string; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesFlushQuantileSummaries',[I_quantile_stream_resource_handle],[],[],[OL_summaries],['num_features'],['int'],[@A_num_features])
  end;
function TGraphExt.AddBoostedTreesGetEnsembleStates(const I_tree_ensemble_handle:string; const O_stamp_token:string; const O_num_trees:string; const O_num_finalized_trees:string; const O_num_attempted_layers:string; const O_last_layer_nodes_range:string):string;
  begin
  result:=AddOper('BoostedTreesGetEnsembleStates',[I_tree_ensemble_handle],[],[],[O_stamp_token,O_num_trees,O_num_finalized_trees,O_num_attempted_layers,O_last_layer_nodes_range],[],[],[])
  end;
function TGraphExt.AddBoostedTreesMakeQuantileSummaries(const I_example_weights:string; const I_epsilon:string; const IL_float_values:string; const OL_summaries:string; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesMakeQuantileSummaries',[I_example_weights,I_epsilon],[IL_float_values],[A_num_features],[OL_summaries],['num_features'],['int'],[@A_num_features])
  end;
function TGraphExt.AddBoostedTreesMakeStatsSummary(const I_node_ids:string; const I_gradients:string; const I_hessians:string; const IL_bucketized_features_list:string; const O_stats_summary:string; const A_max_splits:cint64; const A_num_buckets:cint64; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesMakeStatsSummary',[I_node_ids,I_gradients,I_hessians],[IL_bucketized_features_list],[A_num_features],[O_stats_summary],['max_splits','num_buckets','num_features'],['int','int','int'],[@A_max_splits,@A_num_buckets,@A_num_features])
  end;
function TGraphExt.AddBoostedTreesPredict(const I_tree_ensemble_handle:string; const IL_bucketized_features:string; const O_logits:string; const A_num_bucketized_features:cint64; const A_logits_dimension:cint64):string;
  begin
  result:=AddOper('BoostedTreesPredict',[I_tree_ensemble_handle],[IL_bucketized_features],[A_num_bucketized_features],[O_logits],['num_bucketized_features','logits_dimension'],['int','int'],[@A_num_bucketized_features,@A_logits_dimension])
  end;
function TGraphExt.AddBoostedTreesQuantileStreamResourceAddSummaries(const I_quantile_stream_resource_handle:string; const IL_summaries:string; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesQuantileStreamResourceAddSummaries',[I_quantile_stream_resource_handle],[IL_summaries],[A_num_features],[],['num_features'],['int'],[@A_num_features])
  end;
function TGraphExt.AddBoostedTreesQuantileStreamResourceDeserialize(const I_quantile_stream_resource_handle:string; const IL_bucket_boundaries:string; const A_num_streams:cint64):string;
  begin
  result:=AddOper('BoostedTreesQuantileStreamResourceDeserialize',[I_quantile_stream_resource_handle],[IL_bucket_boundaries],[A_num_streams],[],['num_streams'],['int'],[@A_num_streams])
  end;
function TGraphExt.AddBoostedTreesQuantileStreamResourceFlush(const I_quantile_stream_resource_handle:string; const I_num_buckets:string; const A_generate_quantiles:boolean):string;
  begin
  result:=AddOper('BoostedTreesQuantileStreamResourceFlush',[I_quantile_stream_resource_handle,I_num_buckets],[],[],[],['generate_quantiles'],['bool'],[@A_generate_quantiles])
  end;
function TGraphExt.AddBoostedTreesQuantileStreamResourceGetBucketBoundaries(const I_quantile_stream_resource_handle:string; const OL_bucket_boundaries:string; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesQuantileStreamResourceGetBucketBoundaries',[I_quantile_stream_resource_handle],[],[],[OL_bucket_boundaries],['num_features'],['int'],[@A_num_features])
  end;
function TGraphExt.AddBoostedTreesQuantileStreamResourceHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('BoostedTreesQuantileStreamResourceHandleOp',[],[],[],[O_resource],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddBoostedTreesSerializeEnsemble(const I_tree_ensemble_handle:string; const O_stamp_token:string; const O_tree_ensemble_serialized:string):string;
  begin
  result:=AddOper('BoostedTreesSerializeEnsemble',[I_tree_ensemble_handle],[],[],[O_stamp_token,O_tree_ensemble_serialized],[],[],[])
  end;
function TGraphExt.AddBoostedTreesSparseAggregateStats(const I_node_ids:string; const I_gradients:string; const I_hessians:string; const I_feature_indices:string; const I_feature_values:string; const I_feature_shape:string; const O_stats_summary_indices:string; const O_stats_summary_values:string; const O_stats_summary_shape:string; const A_max_splits:cint64; const A_num_buckets:cint64):string;
  begin
  result:=AddOper('BoostedTreesSparseAggregateStats',[I_node_ids,I_gradients,I_hessians,I_feature_indices,I_feature_values,I_feature_shape],[],[],[O_stats_summary_indices,O_stats_summary_values,O_stats_summary_shape],['max_splits','num_buckets'],['int','int'],[@A_max_splits,@A_num_buckets])
  end;
function TGraphExt.AddBoostedTreesSparseCalculateBestFeatureSplit(const I_node_id_range:string; const I_stats_summary_indices:string; const I_stats_summary_values:string; const I_stats_summary_shape:string; const I_l1:string; const I_l2:string; const I_tree_complexity:string; const I_min_node_weight:string; const O_node_ids:string; const O_gains:string; const O_feature_dimensions:string; const O_thresholds:string; const O_left_node_contribs:string; const O_right_node_contribs:string; const O_split_with_default_directions:string; const A_logits_dimension:cint64; const A_split_type:string):string;
  begin
  result:=AddOper('BoostedTreesSparseCalculateBestFeatureSplit',[I_node_id_range,I_stats_summary_indices,I_stats_summary_values,I_stats_summary_shape,I_l1,I_l2,I_tree_complexity,I_min_node_weight],[],[],[O_node_ids,O_gains,O_feature_dimensions,O_thresholds,O_left_node_contribs,O_right_node_contribs,O_split_with_default_directions],['logits_dimension','split_type'],['int','string'],[@A_logits_dimension,@A_split_type])
  end;
function TGraphExt.AddBoostedTreesTrainingPredict(const I_tree_ensemble_handle:string; const I_cached_tree_ids:string; const I_cached_node_ids:string; const IL_bucketized_features:string; const O_partial_logits:string; const O_tree_ids:string; const O_node_ids:string; const A_num_bucketized_features:cint64; const A_logits_dimension:cint64):string;
  begin
  result:=AddOper('BoostedTreesTrainingPredict',[I_tree_ensemble_handle,I_cached_tree_ids,I_cached_node_ids],[IL_bucketized_features],[A_num_bucketized_features],[O_partial_logits,O_tree_ids,O_node_ids],['num_bucketized_features','logits_dimension'],['int','int'],[@A_num_bucketized_features,@A_logits_dimension])
  end;
function TGraphExt.AddBoostedTreesUpdateEnsemble(const I_tree_ensemble_handle:string; const I_feature_ids:string; const I_max_depth:string; const I_learning_rate:string; const IL_node_ids:string; const IL_gains:string; const IL_thresholds:string; const IL_left_node_contribs:string; const IL_right_node_contribs:string; const A_pruning_mode:cint64; const A_num_features:cint64):string;
  begin
  result:=AddOper('BoostedTreesUpdateEnsemble',[I_tree_ensemble_handle,I_feature_ids,I_max_depth,I_learning_rate],[IL_node_ids,IL_gains,IL_thresholds,IL_left_node_contribs,IL_right_node_contribs],[A_num_features,A_num_features,A_num_features,A_num_features,A_num_features],[],['pruning_mode','num_features'],['int','int'],[@A_pruning_mode,@A_num_features])
  end;
function TGraphExt.AddBoostedTreesUpdateEnsembleV2(const I_tree_ensemble_handle:string; const I_max_depth:string; const I_learning_rate:string; const I_pruning_mode:string; const IL_feature_ids:string; const IL_dimension_ids:string; const IL_node_ids:string; const IL_gains:string; const IL_thresholds:string; const IL_left_node_contribs:string; const IL_right_node_contribs:string; const IL_split_types:string; const A_num_features:cint64; const A_logits_dimension:cint64; const A_num_groups:cint64):string;
  begin
  result:=AddOper('BoostedTreesUpdateEnsembleV2',[I_tree_ensemble_handle,I_max_depth,I_learning_rate,I_pruning_mode],[IL_feature_ids,IL_dimension_ids,IL_node_ids,IL_gains,IL_thresholds,IL_left_node_contribs,IL_right_node_contribs,IL_split_types],[A_num_groups,A_num_features,A_num_features,A_num_features,A_num_features,A_num_features,A_num_features,A_num_features],[],['num_features','logits_dimension','num_groups'],['int','int','int'],[@A_num_features,@A_logits_dimension,@A_num_groups])
  end;
function TGraphExt.AddBroadcastArgs(const I_s0:string; const I_s1:string; const O_r0:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BroadcastArgs',[I_s0,I_s1],[],[],[O_r0],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBroadcastGradientArgs(const I_s0:string; const I_s1:string; const O_r0:string; const O_r1:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('BroadcastGradientArgs',[I_s0,I_s1],[],[],[O_r0,O_r1],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddBroadcastTo(const I_input:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('BroadcastTo',[I_input,I_shape],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddBucketize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_boundaries:TF_FloatList):string;
  begin
  result:=AddOper('Bucketize',[I_input],[],[],[O_output],['T','boundaries'],['type','list(float)'],[@A_T,@A_boundaries])
  end;
function TGraphExt.AddBytesProducedStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('BytesProducedStatsDataset',[I_input_dataset,I_tag],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddCSRSparseMatrixComponents(const I_csr_sparse_matrix:string; const I_index:string; const O_row_ptrs:string; const O_col_inds:string; const O_values:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('CSRSparseMatrixComponents',[I_csr_sparse_matrix,I_index],[],[],[O_row_ptrs,O_col_inds,O_values],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddCSRSparseMatrixToDense(const I_sparse_input:string; const O_dense_output:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('CSRSparseMatrixToDense',[I_sparse_input],[],[],[O_dense_output],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddCSRSparseMatrixToSparseTensor(const I_sparse_matrix:string; const O_indices:string; const O_values:string; const O_dense_shape:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('CSRSparseMatrixToSparseTensor',[I_sparse_matrix],[],[],[O_indices,O_values,O_dense_shape],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddCSVDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const I_header:string; const I_field_delim:string; const I_use_quote_delim:string; const I_na_value:string; const I_select_cols:string; const IL_record_defaults:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('CSVDataset',[I_filenames,I_compression_type,I_buffer_size,I_header,I_field_delim,I_use_quote_delim,I_na_value,I_select_cols],[IL_record_defaults],[Length(A_output_types)],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddCTCBeamSearchDecoder(const I_inputs:string; const I_sequence_length:string; const O_log_probability:string; const OL_decoded_indices:string; const OL_decoded_values:string; const OL_decoded_shape:string; const A_beam_width:cint64; const A_top_paths:cint64; const A_merge_repeated:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CTCBeamSearchDecoder',[I_inputs,I_sequence_length],[],[],[O_log_probability,OL_decoded_indices,OL_decoded_values,OL_decoded_shape],['beam_width','top_paths','merge_repeated','T'],['int','int','bool','type'],[@A_beam_width,@A_top_paths,@A_merge_repeated,@A_T])
  end;
function TGraphExt.AddCTCGreedyDecoder(const I_inputs:string; const I_sequence_length:string; const O_decoded_indices:string; const O_decoded_values:string; const O_decoded_shape:string; const O_log_probability:string; const A_merge_repeated:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CTCGreedyDecoder',[I_inputs,I_sequence_length],[],[],[O_decoded_indices,O_decoded_values,O_decoded_shape,O_log_probability],['merge_repeated','T'],['bool','type'],[@A_merge_repeated,@A_T])
  end;
function TGraphExt.AddCTCLoss(const I_inputs:string; const I_labels_indices:string; const I_labels_values:string; const I_sequence_length:string; const O_loss:string; const O_gradient:string; const A_preprocess_collapse_repeated:boolean; const A_ctc_merge_repeated:boolean; const A_ignore_longer_outputs_than_inputs:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CTCLoss',[I_inputs,I_labels_indices,I_labels_values,I_sequence_length],[],[],[O_loss,O_gradient],['preprocess_collapse_repeated','ctc_merge_repeated','ignore_longer_outputs_than_inputs','T'],['bool','bool','bool','type'],[@A_preprocess_collapse_repeated,@A_ctc_merge_repeated,@A_ignore_longer_outputs_than_inputs,@A_T])
  end;
function TGraphExt.AddCTCLossV2(const I_inputs:string; const I_labels_indices:string; const I_labels_values:string; const I_sequence_length:string; const O_loss:string; const O_gradient:string; const A_preprocess_collapse_repeated:boolean; const A_ctc_merge_repeated:boolean; const A_ignore_longer_outputs_than_inputs:boolean):string;
  begin
  result:=AddOper('CTCLossV2',[I_inputs,I_labels_indices,I_labels_values,I_sequence_length],[],[],[O_loss,O_gradient],['preprocess_collapse_repeated','ctc_merge_repeated','ignore_longer_outputs_than_inputs'],['bool','bool','bool'],[@A_preprocess_collapse_repeated,@A_ctc_merge_repeated,@A_ignore_longer_outputs_than_inputs])
  end;
function TGraphExt.AddCacheDataset(const I_input_dataset:string; const I_filename:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('CacheDataset',[I_input_dataset,I_filename],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddCacheDatasetV2(const I_input_dataset:string; const I_filename:string; const I_cache:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('CacheDatasetV2',[I_input_dataset,I_filename,I_cache],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddCase(const I_branch_index:string; const IL_input:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_branches:TF_FuncnameList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('Case',[I_branch_index],[IL_input],[Length(A_Tin)],[OL_output],['Tin','Tout','branches','output_shapes'],['list(type)','list(type)','list(func)','list(shape)'],[@A_Tin,@A_Tout,@A_branches,@A_output_shapes])
  end;
function TGraphExt.AddCast(const I_x:string; const O_y:string; const A_SrcT:TF_DataType; const A_DstT:TF_DataType; const A_Truncate:boolean):string;
  begin
  result:=AddOper('Cast',[I_x],[],[],[O_y],['SrcT','DstT','Truncate'],['type','type','bool'],[@A_SrcT,@A_DstT,@A_Truncate])
  end;
function TGraphExt.AddCeil(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Ceil',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCheckNumerics(const I_tensor:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
  begin
  result:=AddOper('CheckNumerics',[I_tensor],[],[],[O_output],['T','message'],['type','string'],[@A_T,@A_message])
  end;
function TGraphExt.AddCheckNumericsV2(const I_tensor:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
  begin
  result:=AddOper('CheckNumericsV2',[I_tensor],[],[],[O_output],['T','message'],['type','string'],[@A_T,@A_message])
  end;
function TGraphExt.AddCholesky(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cholesky',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCholeskyGrad(const I_l:string; const I_grad:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CholeskyGrad',[I_l,I_grad],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddChooseFastestBranchDataset(const I_input_dataset:string; const I_ratio_numerator:string; const I_ratio_denominator:string; const IL_other_arguments:string; const O_handle:string; const A_Targuments:TF_TypeList; const A_num_elements_per_branch:cint64; const A_branches:TF_FuncnameList; const A_other_arguments_lengths:TF_IntList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ChooseFastestBranchDataset',[I_input_dataset,I_ratio_numerator,I_ratio_denominator],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['Targuments','num_elements_per_branch','branches','other_arguments_lengths','output_types','output_shapes'],['list(type)','int','list(func)','list(int)','list(type)','list(shape)'],[@A_Targuments,@A_num_elements_per_branch,@A_branches,@A_other_arguments_lengths,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddChooseFastestDataset(const IL_input_datasets:string; const O_handle:string; const A_N:cint64; const A_num_experiments:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ChooseFastestDataset',[],[IL_input_datasets],[A_N],[O_handle],['N','num_experiments','output_types','output_shapes'],['int','int','list(type)','list(shape)'],[@A_N,@A_num_experiments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddClipByValue(const I_t:string; const I_clip_value_min:string; const I_clip_value_max:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ClipByValue',[I_t,I_clip_value_min,I_clip_value_max],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCloseSummaryWriter(const I_writer:string):string;
  begin
  result:=AddOper('CloseSummaryWriter',[I_writer],[],[],[],[],[],[])
  end;
function TGraphExt.AddCollectiveBcastRecv(const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_shape:TF_Shape; const A_communication_hint:string):string;
  begin
  result:=AddOper('CollectiveBcastRecv',[],[],[],[O_data],['T','group_size','group_key','instance_key','shape','communication_hint'],['type','int','int','int','shape','string'],[@A_T,@A_group_size,@A_group_key,@A_instance_key,@A_shape,@A_communication_hint])
  end;
function TGraphExt.AddCollectiveBcastSend(const I_input:string; const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_shape:TF_Shape; const A_communication_hint:string):string;
  begin
  result:=AddOper('CollectiveBcastSend',[I_input],[],[],[O_data],['T','group_size','group_key','instance_key','shape','communication_hint'],['type','int','int','int','shape','string'],[@A_T,@A_group_size,@A_group_key,@A_instance_key,@A_shape,@A_communication_hint])
  end;
function TGraphExt.AddCollectiveGather(const I_input:string; const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_shape:TF_Shape; const A_communication_hint:string):string;
  begin
  result:=AddOper('CollectiveGather',[I_input],[],[],[O_data],['T','group_size','group_key','instance_key','shape','communication_hint'],['type','int','int','int','shape','string'],[@A_T,@A_group_size,@A_group_key,@A_instance_key,@A_shape,@A_communication_hint])
  end;
function TGraphExt.AddCollectivePermute(const I_input:string; const I_source_target_pairs:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CollectivePermute',[I_input,I_source_target_pairs],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCollectiveReduce(const I_input:string; const O_data:string; const A_T:TF_DataType; const A_group_size:cint64; const A_group_key:cint64; const A_instance_key:cint64; const A_merge_op:string; const A_final_op:string; const A_subdiv_offsets:TF_IntList; const A_wait_for:TF_IntList; const A_communication_hint:string):string;
  begin
  result:=AddOper('CollectiveReduce',[I_input],[],[],[O_data],['T','group_size','group_key','instance_key','merge_op','final_op','subdiv_offsets','wait_for','communication_hint'],['type','int','int','int','string','string','list(int)','list(int)','string'],[@A_T,@A_group_size,@A_group_key,@A_instance_key,@A_merge_op,@A_final_op,@A_subdiv_offsets,@A_wait_for,@A_communication_hint])
  end;
function TGraphExt.AddCombinedNonMaxSuppression(const I_boxes:string; const I_scores:string; const I_max_output_size_per_class:string; const I_max_total_size:string; const I_iou_threshold:string; const I_score_threshold:string; const O_nmsed_boxes:string; const O_nmsed_scores:string; const O_nmsed_classes:string; const O_valid_detections:string; const A_pad_per_class:boolean; const A_clip_boxes:boolean):string;
  begin
  result:=AddOper('CombinedNonMaxSuppression',[I_boxes,I_scores,I_max_output_size_per_class,I_max_total_size,I_iou_threshold,I_score_threshold],[],[],[O_nmsed_boxes,O_nmsed_scores,O_nmsed_classes,O_valid_detections],['pad_per_class','clip_boxes'],['bool','bool'],[@A_pad_per_class,@A_clip_boxes])
  end;
function TGraphExt.AddCompareAndBitpack(const I_input:string; const I_threshold:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CompareAndBitpack',[I_input,I_threshold],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddComplex(const I_real:string; const I_imag:string; const O_out:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Complex',[I_real,I_imag],[],[],[O_out],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddComplexAbs(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('ComplexAbs',[I_x],[],[],[O_y],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddComputeAccidentalHits(const I_true_classes:string; const I_sampled_candidates:string; const O_indices:string; const O_ids:string; const O_weights:string; const A_num_true:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('ComputeAccidentalHits',[I_true_classes,I_sampled_candidates],[],[],[O_indices,O_ids,O_weights],['num_true','seed','seed2'],['int','int','int'],[@A_num_true,@A_seed,@A_seed2])
  end;
function TGraphExt.AddConcat(const I_concat_dim:string; const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Concat',[I_concat_dim],[IL_values],[A_N],[O_output],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddConcatOffset(const I_concat_dim:string; const IL_shape:string; const OL_offset:string; const A_N:cint64):string;
  begin
  result:=AddOper('ConcatOffset',[I_concat_dim],[IL_shape],[A_N],[OL_offset],['N'],['int'],[@A_N])
  end;
function TGraphExt.AddConcatV2(const I_axis:string; const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('ConcatV2',[I_axis],[IL_values],[A_N],[O_output],['N','T','Tidx'],['int','type','type'],[@A_N,@A_T,@A_Tidx])
  end;
function TGraphExt.AddConcatenateDataset(const I_input_dataset:string; const I_another_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ConcatenateDataset',[I_input_dataset,I_another_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):string;
  begin
  result:=AddOper('ConditionalAccumulator',[],[],[],[O_handle],['dtype','shape','container','shared_name','reduction_type'],['type','shape','string','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name,@A_reduction_type])
  end;
function TGraphExt.AddConfigureDistributedTPU(const O_topology:string; const A_embedding_config:string; const A_tpu_embedding_config:string; const A_is_global_init:boolean; const A_enable_whole_mesh_compilations:boolean; const A_compilation_failure_closes_chips:boolean):string;
  begin
  result:=AddOper('ConfigureDistributedTPU',[],[],[],[O_topology],['embedding_config','tpu_embedding_config','is_global_init','enable_whole_mesh_compilations','compilation_failure_closes_chips'],['string','string','bool','bool','bool'],[@A_embedding_config,@A_tpu_embedding_config,@A_is_global_init,@A_enable_whole_mesh_compilations,@A_compilation_failure_closes_chips])
  end;
function TGraphExt.AddConfigureTPUEmbedding(const A_config:string):string;
  begin
  result:=AddOper('ConfigureTPUEmbedding',[],[],[],[],['config'],['string'],[@A_config])
  end;
function TGraphExt.AddConj(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Conj',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddConjugateTranspose(const I_x:string; const I_perm:string; const O_y:string; const A_T:TF_DataType; const A_Tperm:TF_DataType):string;
  begin
  result:=AddOper('ConjugateTranspose',[I_x,I_perm],[],[],[O_y],['T','Tperm'],['type','type'],[@A_T,@A_Tperm])
  end;
function TGraphExt.AddConst(const O_output:string; const A_value:TF_TensorPtr; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('Const',[],[],[],[O_output],['value','dtype'],['tensor','type'],[@A_value,@A_dtype])
  end;
function TGraphExt.AddConsumeMutexLock(const I_mutex_lock:string):string;
  begin
  result:=AddOper('ConsumeMutexLock',[I_mutex_lock],[],[],[],[],[],[])
  end;
function TGraphExt.AddControlTrigger():string;
  begin
  result:=AddOper('ControlTrigger',[],[],[],[],[],[],[])
  end;
function TGraphExt.AddConv2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:TF_IntList; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv2D',[I_input,I_filter],[],[],[O_output],['T','strides','use_cudnn_on_gpu','padding','explicit_paddings','data_format','dilations'],['type','list(int)','bool','string','list(int)','string','list(int)'],[@A_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_explicit_paddings,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddConv2DBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:TF_IntList; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv2DBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],[],[],[O_output],['T','strides','use_cudnn_on_gpu','padding','explicit_paddings','data_format','dilations'],['type','list(int)','bool','string','list(int)','string','list(int)'],[@A_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_explicit_paddings,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddConv2DBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:TF_IntList; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv2DBackpropInput',[I_input_sizes,I_filter,I_out_backprop],[],[],[O_output],['T','strides','use_cudnn_on_gpu','padding','explicit_paddings','data_format','dilations'],['type','list(int)','bool','string','list(int)','string','list(int)'],[@A_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_explicit_paddings,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddConv3D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv3D',[I_input,I_filter],[],[],[O_output],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddConv3DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv3DBackpropFilter',[I_input,I_filter,I_out_backprop],[],[],[O_output],['T','strides','padding','dilations'],['type','list(int)','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_dilations])
  end;
function TGraphExt.AddConv3DBackpropFilterV2(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv3DBackpropFilterV2',[I_input,I_filter_sizes,I_out_backprop],[],[],[O_output],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddConv3DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('Conv3DBackpropInput',[I_input,I_filter,I_out_backprop],[],[],[O_output],['T','strides','padding','dilations'],['type','list(int)','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_dilations])
  end;
function TGraphExt.AddConv3DBackpropInputV2(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList; const A_Tshape:TF_DataType):string;
  begin
  result:=AddOper('Conv3DBackpropInputV2',[I_input_sizes,I_filter,I_out_backprop],[],[],[O_output],['T','strides','padding','data_format','dilations','Tshape'],['type','list(int)','string','string','list(int)','type'],[@A_T,@A_strides,@A_padding,@A_data_format,@A_dilations,@A_Tshape])
  end;
function TGraphExt.AddCopy(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
  begin
  result:=AddOper('Copy',[I_input],[],[],[O_output],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@A_T,@A_tensor_name,@A_debug_ops_spec])
  end;
function TGraphExt.AddCopyHost(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tensor_name:string; const A_debug_ops_spec:TF_StringList):string;
  begin
  result:=AddOper('CopyHost',[I_input],[],[],[O_output],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@A_T,@A_tensor_name,@A_debug_ops_spec])
  end;
function TGraphExt.AddCos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cos',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCosh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cosh',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCountUpTo(const I_ref:string; const O_output:string; const A_limit:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CountUpTo',[I_ref],[],[],[O_output],['limit','T'],['int','type'],[@A_limit,@A_T])
  end;
function TGraphExt.AddCreateSummaryDbWriter(const I_writer:string; const I_db_uri:string; const I_experiment_name:string; const I_run_name:string; const I_user_name:string):string;
  begin
  result:=AddOper('CreateSummaryDbWriter',[I_writer,I_db_uri,I_experiment_name,I_run_name,I_user_name],[],[],[],[],[],[])
  end;
function TGraphExt.AddCreateSummaryFileWriter(const I_writer:string; const I_logdir:string; const I_max_queue:string; const I_flush_millis:string; const I_filename_suffix:string):string;
  begin
  result:=AddOper('CreateSummaryFileWriter',[I_writer,I_logdir,I_max_queue,I_flush_millis,I_filename_suffix],[],[],[],[],[],[])
  end;
function TGraphExt.AddCropAndResize(const I_image:string; const I_boxes:string; const I_box_ind:string; const I_crop_size:string; const O_crops:string; const A_T:TF_DataType; const A_method:string; const A_extrapolation_value:real):string;
  begin
  result:=AddOper('CropAndResize',[I_image,I_boxes,I_box_ind,I_crop_size],[],[],[O_crops],['T','method','extrapolation_value'],['type','string','float'],[@A_T,@A_method,@A_extrapolation_value])
  end;
function TGraphExt.AddCropAndResizeGradBoxes(const I_grads:string; const I_image:string; const I_boxes:string; const I_box_ind:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
  begin
  result:=AddOper('CropAndResizeGradBoxes',[I_grads,I_image,I_boxes,I_box_ind],[],[],[O_output],['T','method'],['type','string'],[@A_T,@A_method])
  end;
function TGraphExt.AddCropAndResizeGradImage(const I_grads:string; const I_boxes:string; const I_box_ind:string; const I_image_size:string; const O_output:string; const A_T:TF_DataType; const A_method:string):string;
  begin
  result:=AddOper('CropAndResizeGradImage',[I_grads,I_boxes,I_box_ind,I_image_size],[],[],[O_output],['T','method'],['type','string'],[@A_T,@A_method])
  end;
function TGraphExt.AddCross(const I_a:string; const I_b:string; const O_product:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Cross',[I_a,I_b],[],[],[O_product],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCrossReplicaSum(const I_input:string; const I_group_assignment:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('CrossReplicaSum',[I_input,I_group_assignment],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddCudnnRNN(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const O_output:string; const O_output_h:string; const O_output_c:string; const O_reserve_space:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_is_training:boolean):string;
  begin
  result:=AddOper('CudnnRNN',[I_input,I_input_h,I_input_c,I_params],[],[],[O_output,O_output_h,O_output_c,O_reserve_space],['T','rnn_mode','input_mode','direction','dropout','seed','seed2','is_training'],['type','string','string','string','float','int','int','bool'],[@A_T,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_is_training])
  end;
function TGraphExt.AddCudnnRNNBackprop(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_output:string; const I_output_h:string; const I_output_c:string; const I_output_backprop:string; const I_output_h_backprop:string; const I_output_c_backprop:string; const I_reserve_space:string; const O_input_backprop:string; const O_input_h_backprop:string; const O_input_c_backprop:string; const O_params_backprop:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('CudnnRNNBackprop',[I_input,I_input_h,I_input_c,I_params,I_output,I_output_h,I_output_c,I_output_backprop,I_output_h_backprop,I_output_c_backprop,I_reserve_space],[],[],[O_input_backprop,O_input_h_backprop,O_input_c_backprop,O_params_backprop],['T','rnn_mode','input_mode','direction','dropout','seed','seed2'],['type','string','string','string','float','int','int'],[@A_T,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2])
  end;
function TGraphExt.AddCudnnRNNBackpropV2(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_output:string; const I_output_h:string; const I_output_c:string; const I_output_backprop:string; const I_output_h_backprop:string; const I_output_c_backprop:string; const I_reserve_space:string; const I_host_reserved:string; const O_input_backprop:string; const O_input_h_backprop:string; const O_input_c_backprop:string; const O_params_backprop:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('CudnnRNNBackpropV2',[I_input,I_input_h,I_input_c,I_params,I_output,I_output_h,I_output_c,I_output_backprop,I_output_h_backprop,I_output_c_backprop,I_reserve_space,I_host_reserved],[],[],[O_input_backprop,O_input_h_backprop,O_input_c_backprop,O_params_backprop],['T','rnn_mode','input_mode','direction','dropout','seed','seed2'],['type','string','string','string','float','int','int'],[@A_T,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2])
  end;
function TGraphExt.AddCudnnRNNBackpropV3(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_sequence_lengths:string; const I_output:string; const I_output_h:string; const I_output_c:string; const I_output_backprop:string; const I_output_h_backprop:string; const I_output_c_backprop:string; const I_reserve_space:string; const I_host_reserved:string; const O_input_backprop:string; const O_input_h_backprop:string; const O_input_c_backprop:string; const O_params_backprop:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64; const A_time_major:boolean):string;
  begin
  result:=AddOper('CudnnRNNBackpropV3',[I_input,I_input_h,I_input_c,I_params,I_sequence_lengths,I_output,I_output_h,I_output_c,I_output_backprop,I_output_h_backprop,I_output_c_backprop,I_reserve_space,I_host_reserved],[],[],[O_input_backprop,O_input_h_backprop,O_input_c_backprop,O_params_backprop],['T','rnn_mode','input_mode','direction','dropout','seed','seed2','num_proj','time_major'],['type','string','string','string','float','int','int','int','bool'],[@A_T,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_num_proj,@A_time_major])
  end;
function TGraphExt.AddCudnnRNNCanonicalToParams(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const IL_weights:string; const IL_biases:string; const O_params:string; const A_T:TF_DataType; const A_num_params:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('CudnnRNNCanonicalToParams',[I_num_layers,I_num_units,I_input_size],[IL_weights,IL_biases],[A_num_params,A_num_params],[O_params],['T','num_params','rnn_mode','input_mode','direction','dropout','seed','seed2'],['type','int','string','string','string','float','int','int'],[@A_T,@A_num_params,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2])
  end;
function TGraphExt.AddCudnnRNNCanonicalToParamsV2(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const IL_weights:string; const IL_biases:string; const O_params:string; const A_T:TF_DataType; const A_num_params_weights:cint64; const A_num_params_biases:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64):string;
  begin
  result:=AddOper('CudnnRNNCanonicalToParamsV2',[I_num_layers,I_num_units,I_input_size],[IL_weights,IL_biases],[A_num_params_weights,A_num_params_biases],[O_params],['T','num_params_weights','num_params_biases','rnn_mode','input_mode','direction','dropout','seed','seed2','num_proj'],['type','int','int','string','string','string','float','int','int','int'],[@A_T,@A_num_params_weights,@A_num_params_biases,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_num_proj])
  end;
function TGraphExt.AddCudnnRNNParamsSize(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const O_params_size:string; const A_T:TF_DataType; const A_S:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64):string;
  begin
  result:=AddOper('CudnnRNNParamsSize',[I_num_layers,I_num_units,I_input_size],[],[],[O_params_size],['T','S','rnn_mode','input_mode','direction','dropout','seed','seed2','num_proj'],['type','type','string','string','string','float','int','int','int'],[@A_T,@A_S,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_num_proj])
  end;
function TGraphExt.AddCudnnRNNParamsToCanonical(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const I_params:string; const OL_weights:string; const OL_biases:string; const A_T:TF_DataType; const A_num_params:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('CudnnRNNParamsToCanonical',[I_num_layers,I_num_units,I_input_size,I_params],[],[],[OL_weights,OL_biases],['T','num_params','rnn_mode','input_mode','direction','dropout','seed','seed2'],['type','int','string','string','string','float','int','int'],[@A_T,@A_num_params,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2])
  end;
function TGraphExt.AddCudnnRNNParamsToCanonicalV2(const I_num_layers:string; const I_num_units:string; const I_input_size:string; const I_params:string; const OL_weights:string; const OL_biases:string; const A_T:TF_DataType; const A_num_params_weights:cint64; const A_num_params_biases:cint64; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64):string;
  begin
  result:=AddOper('CudnnRNNParamsToCanonicalV2',[I_num_layers,I_num_units,I_input_size,I_params],[],[],[OL_weights,OL_biases],['T','num_params_weights','num_params_biases','rnn_mode','input_mode','direction','dropout','seed','seed2','num_proj'],['type','int','int','string','string','string','float','int','int','int'],[@A_T,@A_num_params_weights,@A_num_params_biases,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_num_proj])
  end;
function TGraphExt.AddCudnnRNNV2(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const O_output:string; const O_output_h:string; const O_output_c:string; const O_reserve_space:string; const O_host_reserved:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_is_training:boolean):string;
  begin
  result:=AddOper('CudnnRNNV2',[I_input,I_input_h,I_input_c,I_params],[],[],[O_output,O_output_h,O_output_c,O_reserve_space,O_host_reserved],['T','rnn_mode','input_mode','direction','dropout','seed','seed2','is_training'],['type','string','string','string','float','int','int','bool'],[@A_T,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_is_training])
  end;
function TGraphExt.AddCudnnRNNV3(const I_input:string; const I_input_h:string; const I_input_c:string; const I_params:string; const I_sequence_lengths:string; const O_output:string; const O_output_h:string; const O_output_c:string; const O_reserve_space:string; const O_host_reserved:string; const A_T:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:cint64; const A_seed2:cint64; const A_num_proj:cint64; const A_is_training:boolean; const A_time_major:boolean):string;
  begin
  result:=AddOper('CudnnRNNV3',[I_input,I_input_h,I_input_c,I_params,I_sequence_lengths],[],[],[O_output,O_output_h,O_output_c,O_reserve_space,O_host_reserved],['T','rnn_mode','input_mode','direction','dropout','seed','seed2','num_proj','is_training','time_major'],['type','string','string','string','float','int','int','int','bool','bool'],[@A_T,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_num_proj,@A_is_training,@A_time_major])
  end;
function TGraphExt.AddCumprod(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Cumprod',[I_x,I_axis],[],[],[O_out],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@A_T,@A_Tidx])
  end;
function TGraphExt.AddCumsum(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Cumsum',[I_x,I_axis],[],[],[O_out],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@A_T,@A_Tidx])
  end;
function TGraphExt.AddCumulativeLogsumexp(const I_x:string; const I_axis:string; const O_out:string; const A_exclusive:boolean; const A_reverse:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('CumulativeLogsumexp',[I_x,I_axis],[],[],[O_out],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@A_T,@A_Tidx])
  end;
function TGraphExt.AddDataFormatDimMap(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_src_format:string; const A_dst_format:string):string;
  begin
  result:=AddOper('DataFormatDimMap',[I_x],[],[],[O_y],['T','src_format','dst_format'],['type','string','string'],[@A_T,@A_src_format,@A_dst_format])
  end;
function TGraphExt.AddDataFormatVecPermute(const I_x:string; const O_y:string; const A_T:TF_DataType; const A_src_format:string; const A_dst_format:string):string;
  begin
  result:=AddOper('DataFormatVecPermute',[I_x],[],[],[O_y],['T','src_format','dst_format'],['type','string','string'],[@A_T,@A_src_format,@A_dst_format])
  end;
function TGraphExt.AddDatasetCardinality(const I_input_dataset:string; const O_cardinality:string):string;
  begin
  result:=AddOper('DatasetCardinality',[I_input_dataset],[],[],[O_cardinality],[],[],[])
  end;
function TGraphExt.AddDatasetFromGraph(const I_graph_def:string; const O_handle:string):string;
  begin
  result:=AddOper('DatasetFromGraph',[I_graph_def],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddDatasetToGraph(const I_input_dataset:string; const O_graph:string; const A_stateful_whitelist:TF_StringList; const A_allow_stateful:boolean; const A_strip_device_assignment:boolean):string;
  begin
  result:=AddOper('DatasetToGraph',[I_input_dataset],[],[],[O_graph],['stateful_whitelist','allow_stateful','strip_device_assignment'],['list(string)','bool','bool'],[@A_stateful_whitelist,@A_allow_stateful,@A_strip_device_assignment])
  end;
function TGraphExt.AddDatasetToGraphV2(const I_input_dataset:string; const O_graph:string; const A_external_state_policy:cint64; const A_strip_device_assignment:boolean):string;
  begin
  result:=AddOper('DatasetToGraphV2',[I_input_dataset],[],[],[O_graph],['external_state_policy','strip_device_assignment'],['int','bool'],[@A_external_state_policy,@A_strip_device_assignment])
  end;
function TGraphExt.AddDatasetToSingleElement(const I_dataset:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('DatasetToSingleElement',[I_dataset],[],[],[OL_components],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddDatasetToTFRecord(const I_input_dataset:string; const I_filename:string; const I_compression_type:string):string;
  begin
  result:=AddOper('DatasetToTFRecord',[I_input_dataset,I_filename,I_compression_type],[],[],[],[],[],[])
  end;
function TGraphExt.AddDawsn(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Dawsn',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDebugGradientIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DebugGradientIdentity',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDebugGradientRefIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DebugGradientRefIdentity',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDebugIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
  begin
  result:=AddOper('DebugIdentity',[I_input],[],[],[O_output],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@A_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc])
  end;
function TGraphExt.AddDebugIdentityV2(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_tfdbg_context_id:string; const A_op_name:string; const A_output_slot:cint64; const A_tensor_debug_mode:cint64; const A_debug_urls:TF_StringList):string;
  begin
  result:=AddOper('DebugIdentityV2',[I_input],[],[],[O_output],['T','tfdbg_context_id','op_name','output_slot','tensor_debug_mode','debug_urls'],['type','string','string','int','int','list(string)'],[@A_T,@A_tfdbg_context_id,@A_op_name,@A_output_slot,@A_tensor_debug_mode,@A_debug_urls])
  end;
function TGraphExt.AddDebugNanCount(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_gated_grpc:boolean):string;
  begin
  result:=AddOper('DebugNanCount',[I_input],[],[],[O_output],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@A_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc])
  end;
function TGraphExt.AddDebugNumericSummary(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:TF_StringList; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean):string;
  begin
  result:=AddOper('DebugNumericSummary',[I_input],[],[],[O_output],['T','device_name','tensor_name','debug_urls','lower_bound','upper_bound','mute_if_healthy','gated_grpc'],['type','string','string','list(string)','float','float','bool','bool'],[@A_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_lower_bound,@A_upper_bound,@A_mute_if_healthy,@A_gated_grpc])
  end;
function TGraphExt.AddDebugNumericSummaryV2(const I_input:string; const O_output:string; const A_output_dtype:TF_DataType; const A_T:TF_DataType; const A_tensor_debug_mode:cint64; const A_tensor_id:cint64):string;
  begin
  result:=AddOper('DebugNumericSummaryV2',[I_input],[],[],[O_output],['output_dtype','T','tensor_debug_mode','tensor_id'],['type','type','int','int'],[@A_output_dtype,@A_T,@A_tensor_debug_mode,@A_tensor_id])
  end;
function TGraphExt.AddDecodeAndCropJpeg(const I_contents:string; const I_crop_window:string; const O_image:string; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string):string;
  begin
  result:=AddOper('DecodeAndCropJpeg',[I_contents,I_crop_window],[],[],[O_image],['channels','ratio','fancy_upscaling','try_recover_truncated','acceptable_fraction','dct_method'],['int','int','bool','bool','float','string'],[@A_channels,@A_ratio,@A_fancy_upscaling,@A_try_recover_truncated,@A_acceptable_fraction,@A_dct_method])
  end;
function TGraphExt.AddDecodeBase64(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('DecodeBase64',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddDecodeBmp(const I_contents:string; const O_image:string; const A_channels:cint64):string;
  begin
  result:=AddOper('DecodeBmp',[I_contents],[],[],[O_image],['channels'],['int'],[@A_channels])
  end;
function TGraphExt.AddDecodeCSV(const I_records:string; const IL_record_defaults:string; const OL_output:string; const A_OUT_TYPE:TF_TypeList; const A_field_delim:string; const A_use_quote_delim:boolean; const A_na_value:string; const A_select_cols:TF_IntList):string;
  begin
  result:=AddOper('DecodeCSV',[I_records],[IL_record_defaults],[Length(A_OUT_TYPE)],[OL_output],['OUT_TYPE','field_delim','use_quote_delim','na_value','select_cols'],['list(type)','string','bool','string','list(int)'],[@A_OUT_TYPE,@A_field_delim,@A_use_quote_delim,@A_na_value,@A_select_cols])
  end;
function TGraphExt.AddDecodeCompressed(const I_bytes:string; const O_output:string; const A_compression_type:string):string;
  begin
  result:=AddOper('DecodeCompressed',[I_bytes],[],[],[O_output],['compression_type'],['string'],[@A_compression_type])
  end;
function TGraphExt.AddDecodeGif(const I_contents:string; const O_image:string):string;
  begin
  result:=AddOper('DecodeGif',[I_contents],[],[],[O_image],[],[],[])
  end;
function TGraphExt.AddDecodeJSONExample(const I_json_examples:string; const O_binary_examples:string):string;
  begin
  result:=AddOper('DecodeJSONExample',[I_json_examples],[],[],[O_binary_examples],[],[],[])
  end;
function TGraphExt.AddDecodeJpeg(const I_contents:string; const O_image:string; const A_channels:cint64; const A_ratio:cint64; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string):string;
  begin
  result:=AddOper('DecodeJpeg',[I_contents],[],[],[O_image],['channels','ratio','fancy_upscaling','try_recover_truncated','acceptable_fraction','dct_method'],['int','int','bool','bool','float','string'],[@A_channels,@A_ratio,@A_fancy_upscaling,@A_try_recover_truncated,@A_acceptable_fraction,@A_dct_method])
  end;
function TGraphExt.AddDecodePaddedRaw(const I_input_bytes:string; const I_fixed_length:string; const O_output:string; const A_out_type:TF_DataType; const A_little_endian:boolean):string;
  begin
  result:=AddOper('DecodePaddedRaw',[I_input_bytes,I_fixed_length],[],[],[O_output],['out_type','little_endian'],['type','bool'],[@A_out_type,@A_little_endian])
  end;
function TGraphExt.AddDecodePng(const I_contents:string; const O_image:string; const A_channels:cint64; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('DecodePng',[I_contents],[],[],[O_image],['channels','dtype'],['int','type'],[@A_channels,@A_dtype])
  end;
function TGraphExt.AddDecodeProtoV2(const I_bytes:string; const O_sizes:string; const OL_values:string; const A_message_type:string; const A_field_names:TF_StringList; const A_output_types:TF_TypeList; const A_descriptor_source:string; const A_message_format:string; const A_sanitize:boolean):string;
  begin
  result:=AddOper('DecodeProtoV2',[I_bytes],[],[],[O_sizes,OL_values],['message_type','field_names','output_types','descriptor_source','message_format','sanitize'],['string','list(string)','list(type)','string','string','bool'],[@A_message_type,@A_field_names,@A_output_types,@A_descriptor_source,@A_message_format,@A_sanitize])
  end;
function TGraphExt.AddDecodeRaw(const I_bytes:string; const O_output:string; const A_out_type:TF_DataType; const A_little_endian:boolean):string;
  begin
  result:=AddOper('DecodeRaw',[I_bytes],[],[],[O_output],['out_type','little_endian'],['type','bool'],[@A_out_type,@A_little_endian])
  end;
function TGraphExt.AddDecodeWav(const I_contents:string; const O_audio:string; const O_sample_rate:string; const A_desired_channels:cint64; const A_desired_samples:cint64):string;
  begin
  result:=AddOper('DecodeWav',[I_contents],[],[],[O_audio,O_sample_rate],['desired_channels','desired_samples'],['int','int'],[@A_desired_channels,@A_desired_samples])
  end;
function TGraphExt.AddDeepCopy(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DeepCopy',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDeleteIterator(const I_handle:string; const I_deleter:string):string;
  begin
  result:=AddOper('DeleteIterator',[I_handle,I_deleter],[],[],[],[],[],[])
  end;
function TGraphExt.AddDeleteMemoryCache(const I_handle:string; const I_deleter:string):string;
  begin
  result:=AddOper('DeleteMemoryCache',[I_handle,I_deleter],[],[],[],[],[],[])
  end;
function TGraphExt.AddDeleteMultiDeviceIterator(const I_multi_device_iterator:string; const I_deleter:string; const IL_iterators:string; const A_N:cint64):string;
  begin
  result:=AddOper('DeleteMultiDeviceIterator',[I_multi_device_iterator,I_deleter],[IL_iterators],[A_N],[],['N'],['int'],[@A_N])
  end;
function TGraphExt.AddDeleteRandomSeedGenerator(const I_handle:string; const I_deleter:string):string;
  begin
  result:=AddOper('DeleteRandomSeedGenerator',[I_handle,I_deleter],[],[],[],[],[],[])
  end;
function TGraphExt.AddDeleteSessionTensor(const I_handle:string):string;
  begin
  result:=AddOper('DeleteSessionTensor',[I_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddDenseToCSRSparseMatrix(const I_dense_input:string; const I_indices:string; const O_sparse_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DenseToCSRSparseMatrix',[I_dense_input,I_indices],[],[],[O_sparse_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDenseToDenseSetOperation(const I_set1:string; const I_set2:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DenseToDenseSetOperation',[I_set1,I_set2],[],[],[O_result_indices,O_result_values,O_result_shape],['set_operation','validate_indices','T'],['string','bool','type'],[@A_set_operation,@A_validate_indices,@A_T])
  end;
function TGraphExt.AddDenseToSparseBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_row_shape:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('DenseToSparseBatchDataset',[I_input_dataset,I_batch_size,I_row_shape],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddDenseToSparseSetOperation(const I_set1:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DenseToSparseSetOperation',[I_set1,I_set2_indices,I_set2_values,I_set2_shape],[],[],[O_result_indices,O_result_values,O_result_shape],['set_operation','validate_indices','T'],['string','bool','type'],[@A_set_operation,@A_validate_indices,@A_T])
  end;
function TGraphExt.AddDepthToSpace(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_data_format:string):string;
  begin
  result:=AddOper('DepthToSpace',[I_input],[],[],[O_output],['T','block_size','data_format'],['type','int','string'],[@A_T,@A_block_size,@A_data_format])
  end;
function TGraphExt.AddDepthwiseConv2dNative(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('DepthwiseConv2dNative',[I_input,I_filter],[],[],[O_output],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddDepthwiseConv2dNativeBackpropFilter(const I_input:string; const I_filter_sizes:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('DepthwiseConv2dNativeBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],[],[],[O_output],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddDepthwiseConv2dNativeBackpropInput(const I_input_sizes:string; const I_filter:string; const I_out_backprop:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('DepthwiseConv2dNativeBackpropInput',[I_input_sizes,I_filter,I_out_backprop],[],[],[O_output],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@A_T,@A_strides,@A_padding,@A_data_format,@A_dilations])
  end;
function TGraphExt.AddDequantize(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const A_T:TF_DataType; const A_mode:string; const A_narrow_range:boolean; const A_axis:cint64; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('Dequantize',[I_input,I_min_range,I_max_range],[],[],[O_output],['T','mode','narrow_range','axis','dtype'],['type','string','bool','int','type'],[@A_T,@A_mode,@A_narrow_range,@A_axis,@A_dtype])
  end;
function TGraphExt.AddDeserializeIterator(const I_resource_handle:string; const I_serialized:string):string;
  begin
  result:=AddOper('DeserializeIterator',[I_resource_handle,I_serialized],[],[],[],[],[],[])
  end;
function TGraphExt.AddDeserializeManySparse(const I_serialized_sparse:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('DeserializeManySparse',[I_serialized_sparse],[],[],[O_sparse_indices,O_sparse_values,O_sparse_shape],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddDeserializeSparse(const I_serialized_sparse:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType; const A_Tserialized:TF_DataType):string;
  begin
  result:=AddOper('DeserializeSparse',[I_serialized_sparse],[],[],[O_sparse_indices,O_sparse_values,O_sparse_shape],['dtype','Tserialized'],['type','type'],[@A_dtype,@A_Tserialized])
  end;
function TGraphExt.AddDestroyResourceOp(const I_resource:string; const A_ignore_lookup_error:boolean):string;
  begin
  result:=AddOper('DestroyResourceOp',[I_resource],[],[],[],['ignore_lookup_error'],['bool'],[@A_ignore_lookup_error])
  end;
function TGraphExt.AddDestroyTemporaryVariable(const I_ref:string; const O_value:string; const A_T:TF_DataType; const A_var_name:string):string;
  begin
  result:=AddOper('DestroyTemporaryVariable',[I_ref],[],[],[O_value],['T','var_name'],['type','string'],[@A_T,@A_var_name])
  end;
function TGraphExt.AddDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Diag',[I_diagonal],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DiagPart',[I_input],[],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDigamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Digamma',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDilation2D(const I_input:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Dilation2D',[I_input,I_filter],[],[],[O_output],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_strides,@A_rates,@A_padding])
  end;
function TGraphExt.AddDilation2DBackpropFilter(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_filter_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Dilation2DBackpropFilter',[I_input,I_filter,I_out_backprop],[],[],[O_filter_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_strides,@A_rates,@A_padding])
  end;
function TGraphExt.AddDilation2DBackpropInput(const I_input:string; const I_filter:string; const I_out_backprop:string; const O_in_backprop:string; const A_T:TF_DataType; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('Dilation2DBackpropInput',[I_input,I_filter,I_out_backprop],[],[],[O_in_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_strides,@A_rates,@A_padding])
  end;
function TGraphExt.AddDirectedInterleaveDataset(const I_selector_input_dataset:string; const IL_data_input_datasets:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('DirectedInterleaveDataset',[I_selector_input_dataset],[IL_data_input_datasets],[A_N],[O_handle],['output_types','output_shapes','N'],['list(type)','list(shape)','int'],[@A_output_types,@A_output_shapes,@A_N])
  end;
function TGraphExt.AddDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Div',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDivNoNan(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DivNoNan',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDrawBoundingBoxes(const I_images:string; const I_boxes:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DrawBoundingBoxes',[I_images,I_boxes],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDrawBoundingBoxesV2(const I_images:string; const I_boxes:string; const I_colors:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DrawBoundingBoxesV2',[I_images,I_boxes,I_colors],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddDynamicPartition(const I_data:string; const I_partitions:string; const OL_outputs:string; const A_num_partitions:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DynamicPartition',[I_data,I_partitions],[],[],[OL_outputs],['num_partitions','T'],['int','type'],[@A_num_partitions,@A_T])
  end;
function TGraphExt.AddDynamicStitch(const IL_indices:string; const IL_data:string; const O_merged:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('DynamicStitch',[],[IL_indices,IL_data],[A_N,A_N],[O_merged],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddEagerPyFunc(const IL_input:string; const OL_output:string; const A_token:string; const A_is_async:boolean; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
  begin
  result:=AddOper('EagerPyFunc',[],[IL_input],[Length(A_Tin)],[OL_output],['token','is_async','Tin','Tout'],['string','bool','list(type)','list(type)'],[@A_token,@A_is_async,@A_Tin,@A_Tout])
  end;
function TGraphExt.AddEditDistance(const I_hypothesis_indices:string; const I_hypothesis_values:string; const I_hypothesis_shape:string; const I_truth_indices:string; const I_truth_values:string; const I_truth_shape:string; const O_output:string; const A_normalize:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EditDistance',[I_hypothesis_indices,I_hypothesis_values,I_hypothesis_shape,I_truth_indices,I_truth_values,I_truth_shape],[],[],[O_output],['normalize','T'],['bool','type'],[@A_normalize,@A_T])
  end;
function TGraphExt.AddEig(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Eig',[I_input],[],[],[O_e,O_v],['compute_v','T','Tout'],['bool','type','type'],[@A_compute_v,@A_T,@A_Tout])
  end;
function TGraphExt.AddEinsum(const IL_inputs:string; const O_output:string; const A_equation:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Einsum',[],[IL_inputs],[A_N],[O_output],['equation','N','T'],['string','int','type'],[@A_equation,@A_N,@A_T])
  end;
function TGraphExt.AddElu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Elu',[I_features],[],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddEluGrad(const I_gradients:string; const I_outputs:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EluGrad',[I_gradients,I_outputs],[],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddEmpty(const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_init:boolean):string;
  begin
  result:=AddOper('Empty',[I_shape],[],[],[O_output],['dtype','init'],['type','bool'],[@A_dtype,@A_init])
  end;
function TGraphExt.AddEmptyTensorList(const I_element_shape:string; const I_max_num_elements:string; const O_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('EmptyTensorList',[I_element_shape,I_max_num_elements],[],[],[O_handle],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddEncodeBase64(const I_input:string; const O_output:string; const A_pad:boolean):string;
  begin
  result:=AddOper('EncodeBase64',[I_input],[],[],[O_output],['pad'],['bool'],[@A_pad])
  end;
function TGraphExt.AddEncodeJpeg(const I_image:string; const O_contents:string; const A_format:string; const A_quality:cint64; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:cint64; const A_y_density:cint64; const A_xmp_metadata:string):string;
  begin
  result:=AddOper('EncodeJpeg',[I_image],[],[],[O_contents],['format','quality','progressive','optimize_size','chroma_downsampling','density_unit','x_density','y_density','xmp_metadata'],['string','int','bool','bool','bool','string','int','int','string'],[@A_format,@A_quality,@A_progressive,@A_optimize_size,@A_chroma_downsampling,@A_density_unit,@A_x_density,@A_y_density,@A_xmp_metadata])
  end;
function TGraphExt.AddEncodeJpegVariableQuality(const I_images:string; const I_quality:string; const O_contents:string):string;
  begin
  result:=AddOper('EncodeJpegVariableQuality',[I_images,I_quality],[],[],[O_contents],[],[],[])
  end;
function TGraphExt.AddEncodePng(const I_image:string; const O_contents:string; const A_compression:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EncodePng',[I_image],[],[],[O_contents],['compression','T'],['int','type'],[@A_compression,@A_T])
  end;
function TGraphExt.AddEncodeProto(const I_sizes:string; const IL_values:string; const O_bytes:string; const A_field_names:TF_StringList; const A_message_type:string; const A_descriptor_source:string; const A_Tinput_types:TF_TypeList):string;
  begin
  result:=AddOper('EncodeProto',[I_sizes],[IL_values],[Length(A_Tinput_types)],[O_bytes],['field_names','message_type','descriptor_source','Tinput_types'],['list(string)','string','string','list(type)'],[@A_field_names,@A_message_type,@A_descriptor_source,@A_Tinput_types])
  end;
function TGraphExt.AddEncodeWav(const I_audio:string; const I_sample_rate:string; const O_contents:string):string;
  begin
  result:=AddOper('EncodeWav',[I_audio,I_sample_rate],[],[],[O_contents],[],[],[])
  end;
function TGraphExt.AddEnqueueTPUEmbeddingIntegerBatch(const I_mode_override:string; const IL_batch:string; const A_N:cint64; const A_device_ordinal:cint64):string;
  begin
  result:=AddOper('EnqueueTPUEmbeddingIntegerBatch',[I_mode_override],[IL_batch],[A_N],[],['N','device_ordinal'],['int','int'],[@A_N,@A_device_ordinal])
  end;
function TGraphExt.AddEnqueueTPUEmbeddingSparseBatch(const I_mode_override:string; const IL_sample_indices:string; const IL_embedding_indices:string; const IL_aggregation_weights:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_T3:TF_DataType; const A_N:cint64; const A_device_ordinal:cint64; const A_combiners:TF_StringList):string;
  begin
  result:=AddOper('EnqueueTPUEmbeddingSparseBatch',[I_mode_override],[IL_sample_indices,IL_embedding_indices,IL_aggregation_weights],[A_N,A_N,A_N],[],['T1','T2','T3','N','device_ordinal','combiners'],['type','type','type','int','int','list(string)'],[@A_T1,@A_T2,@A_T3,@A_N,@A_device_ordinal,@A_combiners])
  end;
function TGraphExt.AddEnqueueTPUEmbeddingSparseTensorBatch(const I_mode_override:string; const IL_sample_indices:string; const IL_embedding_indices:string; const IL_aggregation_weights:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_T3:TF_DataType; const A_N:cint64; const A_device_ordinal:cint64; const A_combiners:TF_StringList; const A_table_ids:TF_IntList; const A_max_sequence_lengths:TF_IntList):string;
  begin
  result:=AddOper('EnqueueTPUEmbeddingSparseTensorBatch',[I_mode_override],[IL_sample_indices,IL_embedding_indices,IL_aggregation_weights],[A_N,A_N,A_N],[],['T1','T2','T3','N','device_ordinal','combiners','table_ids','max_sequence_lengths'],['type','type','type','int','int','list(string)','list(int)','list(int)'],[@A_T1,@A_T2,@A_T3,@A_N,@A_device_ordinal,@A_combiners,@A_table_ids,@A_max_sequence_lengths])
  end;
function TGraphExt.AddEnsureShape(const I_input:string; const O_output:string; const A_shape:TF_Shape; const A_T:TF_DataType):string;
  begin
  result:=AddOper('EnsureShape',[I_input],[],[],[O_output],['shape','T'],['shape','type'],[@A_shape,@A_T])
  end;
function TGraphExt.AddEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
  begin
  result:=AddOper('Enter',[I_data],[],[],[O_output],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@A_T,@A_frame_name,@A_is_constant,@A_parallel_iterations])
  end;
function TGraphExt.AddEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_incompatible_shape_error:boolean):string;
  begin
  result:=AddOper('Equal',[I_x,I_y],[],[],[O_z],['T','incompatible_shape_error'],['type','bool'],[@A_T,@A_incompatible_shape_error])
  end;
function TGraphExt.AddErf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Erf',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddErfc(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Erfc',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddErfinv(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Erfinv',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddEuclideanNorm(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('EuclideanNorm',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Exit',[I_data],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExp(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Exp',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExpandDims(const I_input:string; const I_dim:string; const O_output:string; const A_T:TF_DataType; const A_Tdim:TF_DataType):string;
  begin
  result:=AddOper('ExpandDims',[I_input,I_dim],[],[],[O_output],['T','Tdim'],['type','type'],[@A_T,@A_Tdim])
  end;
function TGraphExt.AddExperimentalAssertNextDataset(const I_input_dataset:string; const I_transformations:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalAssertNextDataset',[I_input_dataset,I_transformations],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalAutoShardDataset(const I_input_dataset:string; const I_num_workers:string; const I_index:string; const O_handle:string; const A_auto_shard_policy:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalAutoShardDataset',[I_input_dataset,I_num_workers,I_index],[],[],[O_handle],['auto_shard_policy','output_types','output_shapes'],['int','list(type)','list(shape)'],[@A_auto_shard_policy,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalBytesProducedStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalBytesProducedStatsDataset',[I_input_dataset,I_tag],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalCSVDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const I_header:string; const I_field_delim:string; const I_use_quote_delim:string; const I_na_value:string; const I_select_cols:string; const IL_record_defaults:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalCSVDataset',[I_filenames,I_compression_type,I_buffer_size,I_header,I_field_delim,I_use_quote_delim,I_na_value,I_select_cols],[IL_record_defaults],[Length(A_output_types)],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalChooseFastestDataset(const IL_input_datasets:string; const O_handle:string; const A_N:cint64; const A_num_experiments:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalChooseFastestDataset',[],[IL_input_datasets],[A_N],[O_handle],['N','num_experiments','output_types','output_shapes'],['int','int','list(type)','list(shape)'],[@A_N,@A_num_experiments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalDatasetCardinality(const I_input_dataset:string; const O_cardinality:string):string;
  begin
  result:=AddOper('ExperimentalDatasetCardinality',[I_input_dataset],[],[],[O_cardinality],[],[],[])
  end;
function TGraphExt.AddExperimentalDatasetToTFRecord(const I_input_dataset:string; const I_filename:string; const I_compression_type:string):string;
  begin
  result:=AddOper('ExperimentalDatasetToTFRecord',[I_input_dataset,I_filename,I_compression_type],[],[],[],[],[],[])
  end;
function TGraphExt.AddExperimentalDenseToSparseBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_row_shape:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalDenseToSparseBatchDataset',[I_input_dataset,I_batch_size,I_row_shape],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalDirectedInterleaveDataset(const I_selector_input_dataset:string; const IL_data_input_datasets:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('ExperimentalDirectedInterleaveDataset',[I_selector_input_dataset],[IL_data_input_datasets],[A_N],[O_handle],['output_types','output_shapes','N'],['list(type)','list(shape)','int'],[@A_output_types,@A_output_shapes,@A_N])
  end;
function TGraphExt.AddExperimentalGroupByReducerDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_init_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_finalize_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_init_func:TF_Function; const A_reduce_func:TF_Function; const A_finalize_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Tinit_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Tfinalize_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalGroupByReducerDataset',[I_input_dataset],[IL_key_func_other_arguments,IL_init_func_other_arguments,IL_reduce_func_other_arguments,IL_finalize_func_other_arguments],[Length(A_Tkey_func_other_arguments),Length(A_Tinit_func_other_arguments),Length(A_Treduce_func_other_arguments),Length(A_Tfinalize_func_other_arguments)],[O_handle],['key_func','init_func','reduce_func','finalize_func','Tkey_func_other_arguments','Tinit_func_other_arguments','Treduce_func_other_arguments','Tfinalize_func_other_arguments','output_types','output_shapes'],['func','func','func','func','list(type)','list(type)','list(type)','list(type)','list(type)','list(shape)'],[@A_key_func,@A_init_func,@A_reduce_func,@A_finalize_func,@A_Tkey_func_other_arguments,@A_Tinit_func_other_arguments,@A_Treduce_func_other_arguments,@A_Tfinalize_func_other_arguments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalGroupByWindowDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_window_size_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_reduce_func:TF_Function; const A_window_size_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Twindow_size_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalGroupByWindowDataset',[I_input_dataset],[IL_key_func_other_arguments,IL_reduce_func_other_arguments,IL_window_size_func_other_arguments],[Length(A_Tkey_func_other_arguments),Length(A_Treduce_func_other_arguments),Length(A_Twindow_size_func_other_arguments)],[O_handle],['key_func','reduce_func','window_size_func','Tkey_func_other_arguments','Treduce_func_other_arguments','Twindow_size_func_other_arguments','output_types','output_shapes'],['func','func','func','list(type)','list(type)','list(type)','list(type)','list(shape)'],[@A_key_func,@A_reduce_func,@A_window_size_func,@A_Tkey_func_other_arguments,@A_Treduce_func_other_arguments,@A_Twindow_size_func_other_arguments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalIgnoreErrorsDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalIgnoreErrorsDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalIteratorGetDevice(const I_resource:string; const O_device:string):string;
  begin
  result:=AddOper('ExperimentalIteratorGetDevice',[I_resource],[],[],[O_device],[],[],[])
  end;
function TGraphExt.AddExperimentalLMDBDataset(const I_filenames:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalLMDBDataset',[I_filenames],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalLatencyStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalLatencyStatsDataset',[I_input_dataset,I_tag],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalMapAndBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_num_parallel_calls:string; const I_drop_remainder:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean):string;
  begin
  result:=AddOper('ExperimentalMapAndBatchDataset',[I_input_dataset,I_batch_size,I_num_parallel_calls,I_drop_remainder],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes','preserve_cardinality'],['func','list(type)','list(type)','list(shape)','bool'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes,@A_preserve_cardinality])
  end;
function TGraphExt.AddExperimentalMapDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean; const A_preserve_cardinality:boolean):string;
  begin
  result:=AddOper('ExperimentalMapDataset',[I_input_dataset],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes','use_inter_op_parallelism','preserve_cardinality'],['func','list(type)','list(type)','list(shape)','bool','bool'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes,@A_use_inter_op_parallelism,@A_preserve_cardinality])
  end;
function TGraphExt.AddExperimentalMatchingFilesDataset(const I_patterns:string; const O_handle:string):string;
  begin
  result:=AddOper('ExperimentalMatchingFilesDataset',[I_patterns],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddExperimentalMaxIntraOpParallelismDataset(const I_input_dataset:string; const I_max_intra_op_parallelism:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalMaxIntraOpParallelismDataset',[I_input_dataset,I_max_intra_op_parallelism],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalNonSerializableDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalNonSerializableDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalParallelInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_sloppy:string; const I_buffer_output_elements:string; const I_prefetch_input_elements:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalParallelInterleaveDataset',[I_input_dataset,I_cycle_length,I_block_length,I_sloppy,I_buffer_output_elements,I_prefetch_input_elements],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalParseExampleDataset(const I_input_dataset:string; const I_num_parallel_calls:string; const IL_dense_defaults:string; const O_handle:string; const A_sparse_keys:TF_StringList; const A_dense_keys:TF_StringList; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_sloppy:boolean):string;
  begin
  result:=AddOper('ExperimentalParseExampleDataset',[I_input_dataset,I_num_parallel_calls],[IL_dense_defaults],[Length(A_Tdense)],[O_handle],['sparse_keys','dense_keys','sparse_types','Tdense','dense_shapes','output_types','output_shapes','sloppy'],['list(string)','list(string)','list(type)','list(type)','list(shape)','list(type)','list(shape)','bool'],[@A_sparse_keys,@A_dense_keys,@A_sparse_types,@A_Tdense,@A_dense_shapes,@A_output_types,@A_output_shapes,@A_sloppy])
  end;
function TGraphExt.AddExperimentalPrivateThreadPoolDataset(const I_input_dataset:string; const I_num_threads:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalPrivateThreadPoolDataset',[I_input_dataset,I_num_threads],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalRandomDataset(const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalRandomDataset',[I_seed,I_seed2],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalRebatchDataset(const I_input_dataset:string; const I_num_replicas:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_fallback:boolean):string;
  begin
  result:=AddOper('ExperimentalRebatchDataset',[I_input_dataset,I_num_replicas],[],[],[O_handle],['output_types','output_shapes','use_fallback'],['list(type)','list(shape)','bool'],[@A_output_types,@A_output_shapes,@A_use_fallback])
  end;
function TGraphExt.AddExperimentalScanDataset(const I_input_dataset:string; const IL_initial_state:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Tstate:TF_TypeList; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean):string;
  begin
  result:=AddOper('ExperimentalScanDataset',[I_input_dataset],[IL_initial_state,IL_other_arguments],[Length(A_Tstate),Length(A_Targuments)],[O_handle],['f','Tstate','Targuments','output_types','output_shapes','preserve_cardinality'],['func','list(type)','list(type)','list(type)','list(shape)','bool'],[@A_f,@A_Tstate,@A_Targuments,@A_output_types,@A_output_shapes,@A_preserve_cardinality])
  end;
function TGraphExt.AddExperimentalSetStatsAggregatorDataset(const I_input_dataset:string; const I_stats_aggregator:string; const I_tag:string; const I_counter_prefix:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalSetStatsAggregatorDataset',[I_input_dataset,I_stats_aggregator,I_tag,I_counter_prefix],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalSleepDataset(const I_input_dataset:string; const I_sleep_microseconds:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalSleepDataset',[I_input_dataset,I_sleep_microseconds],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalSlidingWindowDataset(const I_input_dataset:string; const I_window_size:string; const I_window_shift:string; const I_window_stride:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalSlidingWindowDataset',[I_input_dataset,I_window_size,I_window_shift,I_window_stride],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalSqlDataset(const I_driver_name:string; const I_data_source_name:string; const I_query:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalSqlDataset',[I_driver_name,I_data_source_name,I_query],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalStatsAggregatorHandle(const O_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('ExperimentalStatsAggregatorHandle',[],[],[],[O_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddExperimentalStatsAggregatorSummary(const I_iterator:string; const O_summary:string):string;
  begin
  result:=AddOper('ExperimentalStatsAggregatorSummary',[I_iterator],[],[],[O_summary],[],[],[])
  end;
function TGraphExt.AddExperimentalTakeWhileDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalTakeWhileDataset',[I_input_dataset],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['predicate','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_predicate,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalThreadPoolDataset(const I_input_dataset:string; const I_thread_pool:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalThreadPoolDataset',[I_input_dataset,I_thread_pool],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalThreadPoolHandle(const O_handle:string; const A_num_threads:cint64; const A_max_intra_op_parallelism:cint64; const A_display_name:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('ExperimentalThreadPoolHandle',[],[],[],[O_handle],['num_threads','max_intra_op_parallelism','display_name','container','shared_name'],['int','int','string','string','string'],[@A_num_threads,@A_max_intra_op_parallelism,@A_display_name,@A_container,@A_shared_name])
  end;
function TGraphExt.AddExperimentalUnbatchDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalUnbatchDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExperimentalUniqueDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ExperimentalUniqueDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddExpint(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Expint',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExpm1(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Expm1',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddExtractGlimpse(const I_input:string; const I_size:string; const I_offsets:string; const O_glimpse:string; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean; const A_noise:string):string;
  begin
  result:=AddOper('ExtractGlimpse',[I_input,I_size,I_offsets],[],[],[O_glimpse],['centered','normalized','uniform_noise','noise'],['bool','bool','bool','string'],[@A_centered,@A_normalized,@A_uniform_noise,@A_noise])
  end;
function TGraphExt.AddExtractImagePatches(const I_images:string; const O_patches:string; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_rates:TF_IntList; const A_T:TF_DataType; const A_padding:string):string;
  begin
  result:=AddOper('ExtractImagePatches',[I_images],[],[],[O_patches],['ksizes','strides','rates','T','padding'],['list(int)','list(int)','list(int)','type','string'],[@A_ksizes,@A_strides,@A_rates,@A_T,@A_padding])
  end;
function TGraphExt.AddExtractJpegShape(const I_contents:string; const O_image_shape:string; const A_output_type:TF_DataType):string;
  begin
  result:=AddOper('ExtractJpegShape',[I_contents],[],[],[O_image_shape],['output_type'],['type'],[@A_output_type])
  end;
function TGraphExt.AddExtractVolumePatches(const I_input:string; const O_patches:string; const A_ksizes:TF_IntList; const A_strides:TF_IntList; const A_T:TF_DataType; const A_padding:string):string;
  begin
  result:=AddOper('ExtractVolumePatches',[I_input],[],[],[O_patches],['ksizes','strides','T','padding'],['list(int)','list(int)','type','string'],[@A_ksizes,@A_strides,@A_T,@A_padding])
  end;
function TGraphExt.AddFFT(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('FFT',[I_input],[],[],[O_output],['Tcomplex'],['type'],[@A_Tcomplex])
  end;
function TGraphExt.AddFFT2D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('FFT2D',[I_input],[],[],[O_output],['Tcomplex'],['type'],[@A_Tcomplex])
  end;
function TGraphExt.AddFFT3D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('FFT3D',[I_input],[],[],[O_output],['Tcomplex'],['type'],[@A_Tcomplex])
  end;
function TGraphExt.AddFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('FIFOQueue',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('FIFOQueueV2',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddFact(const O_fact:string):string;
  begin
  result:=AddOper('Fact',[],[],[],[O_fact],[],[],[])
  end;
function TGraphExt.AddFakeParam(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('FakeParam',[],[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddFakeQuantWithMinMaxArgs(const I_inputs:string; const O_outputs:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxArgs',[I_inputs],[],[],[O_outputs],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxArgsGradient(const I_gradients:string; const I_inputs:string; const O_backprops:string; const A_min:real; const A_max:real; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxArgsGradient',[I_gradients,I_inputs],[],[],[O_backprops],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVars(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVars',[I_inputs,I_min,I_max],[],[],[O_outputs],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVarsGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVarsGradient',[I_gradients,I_inputs,I_min,I_max],[],[],[O_backprops_wrt_input,O_backprop_wrt_min,O_backprop_wrt_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVarsPerChannel(const I_inputs:string; const I_min:string; const I_max:string; const O_outputs:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVarsPerChannel',[I_inputs,I_min,I_max],[],[],[O_outputs],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQuantWithMinMaxVarsPerChannelGradient(const I_gradients:string; const I_inputs:string; const I_min:string; const I_max:string; const O_backprops_wrt_input:string; const O_backprop_wrt_min:string; const O_backprop_wrt_max:string; const A_num_bits:cint64; const A_narrow_range:boolean):string;
  begin
  result:=AddOper('FakeQuantWithMinMaxVarsPerChannelGradient',[I_gradients,I_inputs,I_min,I_max],[],[],[O_backprops_wrt_input,O_backprop_wrt_min,O_backprop_wrt_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range])
  end;
function TGraphExt.AddFakeQueue(const I_resource:string; const O_handle:string):string;
  begin
  result:=AddOper('FakeQueue',[I_resource],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddFill(const I_dims:string; const I_value:string; const O_output:string; const A_T:TF_DataType; const A_index_type:TF_DataType):string;
  begin
  result:=AddOper('Fill',[I_dims,I_value],[],[],[O_output],['T','index_type'],['type','type'],[@A_T,@A_index_type])
  end;
function TGraphExt.AddFilterByLastComponentDataset(const I_input_dataset:string; const O_output:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('FilterByLastComponentDataset',[I_input_dataset],[],[],[O_output],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddFilterDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('FilterDataset',[I_input_dataset],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['predicate','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_predicate,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddFingerprint(const I_data:string; const I_method:string; const O_fingerprint:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Fingerprint',[I_data,I_method],[],[],[O_fingerprint],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFixedLengthRecordDataset(const I_filenames:string; const I_header_bytes:string; const I_record_bytes:string; const I_footer_bytes:string; const I_buffer_size:string; const O_handle:string):string;
  begin
  result:=AddOper('FixedLengthRecordDataset',[I_filenames,I_header_bytes,I_record_bytes,I_footer_bytes,I_buffer_size],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddFixedLengthRecordDatasetV2(const I_filenames:string; const I_header_bytes:string; const I_record_bytes:string; const I_footer_bytes:string; const I_buffer_size:string; const I_compression_type:string; const O_handle:string):string;
  begin
  result:=AddOper('FixedLengthRecordDatasetV2',[I_filenames,I_header_bytes,I_record_bytes,I_footer_bytes,I_buffer_size,I_compression_type],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddFixedLengthRecordReader(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('FixedLengthRecordReader',[],[],[],[O_reader_handle],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name'],['int','int','int','int','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddFixedLengthRecordReaderV2(const O_reader_handle:string; const A_header_bytes:cint64; const A_record_bytes:cint64; const A_footer_bytes:cint64; const A_hop_bytes:cint64; const A_container:string; const A_shared_name:string; const A_encoding:string):string;
  begin
  result:=AddOper('FixedLengthRecordReaderV2',[],[],[],[O_reader_handle],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name','encoding'],['int','int','int','int','string','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name,@A_encoding])
  end;
function TGraphExt.AddFixedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_vocab_file:string; const A_distortion:real; const A_num_reserved_ids:cint64; const A_num_shards:cint64; const A_shard:cint64; const A_unigrams:TF_FloatList; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('FixedUnigramCandidateSampler',[I_true_classes],[],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','vocab_file','distortion','num_reserved_ids','num_shards','shard','unigrams','seed','seed2'],['int','int','bool','int','string','float','int','int','int','list(float)','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_vocab_file,@A_distortion,@A_num_reserved_ids,@A_num_shards,@A_shard,@A_unigrams,@A_seed,@A_seed2])
  end;
function TGraphExt.AddFlatMapDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('FlatMapDataset',[I_input_dataset],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddFloor(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Floor',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFloorDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FloorDiv',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFloorMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FloorMod',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFlushSummaryWriter(const I_writer:string):string;
  begin
  result:=AddOper('FlushSummaryWriter',[I_writer],[],[],[],[],[],[])
  end;
function TGraphExt.AddFor(const I_start:string; const I_limit:string; const I_delta:string; const IL_input:string; const OL_output:string; const A_T:TF_TypeList; const A_body:TF_Function):string;
  begin
  result:=AddOper('For',[I_start,I_limit,I_delta],[IL_input],[Length(A_T)],[OL_output],['T','body'],['list(type)','func'],[@A_T,@A_body])
  end;
function TGraphExt.AddFractionalAvgPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalAvgPool',[I_value],[],[],[O_output,O_row_pooling_sequence,O_col_pooling_sequence],['pooling_ratio','pseudo_random','overlapping','deterministic','seed','seed2','T'],['list(float)','bool','bool','bool','int','int','type'],[@A_pooling_ratio,@A_pseudo_random,@A_overlapping,@A_deterministic,@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddFractionalAvgPoolGrad(const I_orig_input_tensor_shape:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalAvgPoolGrad',[I_orig_input_tensor_shape,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],[],[],[O_output],['overlapping','T'],['bool','type'],[@A_overlapping,@A_T])
  end;
function TGraphExt.AddFractionalMaxPool(const I_value:string; const O_output:string; const O_row_pooling_sequence:string; const O_col_pooling_sequence:string; const A_pooling_ratio:TF_FloatList; const A_pseudo_random:boolean; const A_overlapping:boolean; const A_deterministic:boolean; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalMaxPool',[I_value],[],[],[O_output,O_row_pooling_sequence,O_col_pooling_sequence],['pooling_ratio','pseudo_random','overlapping','deterministic','seed','seed2','T'],['list(float)','bool','bool','bool','int','int','type'],[@A_pooling_ratio,@A_pseudo_random,@A_overlapping,@A_deterministic,@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddFractionalMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_out_backprop:string; const I_row_pooling_sequence:string; const I_col_pooling_sequence:string; const O_output:string; const A_overlapping:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FractionalMaxPoolGrad',[I_orig_input,I_orig_output,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],[],[],[O_output],['overlapping','T'],['bool','type'],[@A_overlapping,@A_T])
  end;
function TGraphExt.AddFresnelCos(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FresnelCos',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFresnelSin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('FresnelSin',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddFusedBatchNorm(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNorm',[I_x,I_scale,I_offset,I_mean,I_variance],[],[],[O_y,O_batch_mean,O_batch_variance,O_reserve_space_1,O_reserve_space_2],['T','epsilon','data_format','is_training'],['type','float','string','bool'],[@A_T,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedBatchNormGrad(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_3:string; const O_reserve_space_4:string; const A_T:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNormGrad',[I_y_backprop,I_x,I_scale,I_reserve_space_1,I_reserve_space_2],[],[],[O_x_backprop,O_scale_backprop,O_offset_backprop,O_reserve_space_3,O_reserve_space_4],['T','epsilon','data_format','is_training'],['type','float','string','bool'],[@A_T,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedBatchNormGradV2(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_3:string; const O_reserve_space_4:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNormGradV2',[I_y_backprop,I_x,I_scale,I_reserve_space_1,I_reserve_space_2],[],[],[O_x_backprop,O_scale_backprop,O_offset_backprop,O_reserve_space_3,O_reserve_space_4],['T','U','epsilon','data_format','is_training'],['type','type','float','string','bool'],[@A_T,@A_U,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedBatchNormGradV3(const I_y_backprop:string; const I_x:string; const I_scale:string; const I_reserve_space_1:string; const I_reserve_space_2:string; const I_reserve_space_3:string; const O_x_backprop:string; const O_scale_backprop:string; const O_offset_backprop:string; const O_reserve_space_4:string; const O_reserve_space_5:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNormGradV3',[I_y_backprop,I_x,I_scale,I_reserve_space_1,I_reserve_space_2,I_reserve_space_3],[],[],[O_x_backprop,O_scale_backprop,O_offset_backprop,O_reserve_space_4,O_reserve_space_5],['T','U','epsilon','data_format','is_training'],['type','type','float','string','bool'],[@A_T,@A_U,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedBatchNormV2(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNormV2',[I_x,I_scale,I_offset,I_mean,I_variance],[],[],[O_y,O_batch_mean,O_batch_variance,O_reserve_space_1,O_reserve_space_2],['T','U','epsilon','data_format','is_training'],['type','type','float','string','bool'],[@A_T,@A_U,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedBatchNormV3(const I_x:string; const I_scale:string; const I_offset:string; const I_mean:string; const I_variance:string; const O_y:string; const O_batch_mean:string; const O_batch_variance:string; const O_reserve_space_1:string; const O_reserve_space_2:string; const O_reserve_space_3:string; const A_T:TF_DataType; const A_U:TF_DataType; const A_epsilon:real; const A_data_format:string; const A_is_training:boolean):string;
  begin
  result:=AddOper('FusedBatchNormV3',[I_x,I_scale,I_offset,I_mean,I_variance],[],[],[O_y,O_batch_mean,O_batch_variance,O_reserve_space_1,O_reserve_space_2,O_reserve_space_3],['T','U','epsilon','data_format','is_training'],['type','type','float','string','bool'],[@A_T,@A_U,@A_epsilon,@A_data_format,@A_is_training])
  end;
function TGraphExt.AddFusedPadConv2D(const I_input:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('FusedPadConv2D',[I_input,I_paddings,I_filter],[],[],[O_output],['T','mode','strides','padding'],['type','string','list(int)','string'],[@A_T,@A_mode,@A_strides,@A_padding])
  end;
function TGraphExt.AddFusedResizeAndPadConv2D(const I_input:string; const I_size:string; const I_paddings:string; const I_filter:string; const O_output:string; const A_T:TF_DataType; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('FusedResizeAndPadConv2D',[I_input,I_size,I_paddings,I_filter],[],[],[O_output],['T','resize_align_corners','mode','strides','padding'],['type','bool','string','list(int)','string'],[@A_T,@A_resize_align_corners,@A_mode,@A_strides,@A_padding])
  end;
function TGraphExt.AddGRUBlockCell(const I_x:string; const I_h_prev:string; const I_w_ru:string; const I_w_c:string; const I_b_ru:string; const I_b_c:string; const O_r:string; const O_u:string; const O_c:string; const O_h:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GRUBlockCell',[I_x,I_h_prev,I_w_ru,I_w_c,I_b_ru,I_b_c],[],[],[O_r,O_u,O_c,O_h],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGRUBlockCellGrad(const I_x:string; const I_h_prev:string; const I_w_ru:string; const I_w_c:string; const I_b_ru:string; const I_b_c:string; const I_r:string; const I_u:string; const I_c:string; const I_d_h:string; const O_d_x:string; const O_d_h_prev:string; const O_d_c_bar:string; const O_d_r_bar_u_bar:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GRUBlockCellGrad',[I_x,I_h_prev,I_w_ru,I_w_c,I_b_ru,I_b_c,I_r,I_u,I_c,I_d_h],[],[],[O_d_x,O_d_h_prev,O_d_c_bar,O_d_r_bar_u_bar],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGather(const I_params:string; const I_indices:string; const O_output:string; const A_validate_indices:boolean; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('Gather',[I_params,I_indices],[],[],[O_output],['validate_indices','Tparams','Tindices'],['bool','type','type'],[@A_validate_indices,@A_Tparams,@A_Tindices])
  end;
function TGraphExt.AddGatherNd(const I_params:string; const I_indices:string; const O_output:string; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('GatherNd',[I_params,I_indices],[],[],[O_output],['Tparams','Tindices'],['type','type'],[@A_Tparams,@A_Tindices])
  end;
function TGraphExt.AddGatherV2(const I_params:string; const I_indices:string; const I_axis:string; const O_output:string; const A_batch_dims:cint64; const A_Tparams:TF_DataType; const A_Tindices:TF_DataType; const A_Taxis:TF_DataType):string;
  begin
  result:=AddOper('GatherV2',[I_params,I_indices,I_axis],[],[],[O_output],['batch_dims','Tparams','Tindices','Taxis'],['int','type','type','type'],[@A_batch_dims,@A_Tparams,@A_Tindices,@A_Taxis])
  end;
function TGraphExt.AddGenerateBoundingBoxProposals(const I_scores:string; const I_bbox_deltas:string; const I_image_info:string; const I_anchors:string; const I_nms_threshold:string; const I_pre_nms_topn:string; const I_min_size:string; const O_rois:string; const O_roi_probabilities:string; const A_post_nms_topn:cint64):string;
  begin
  result:=AddOper('GenerateBoundingBoxProposals',[I_scores,I_bbox_deltas,I_image_info,I_anchors,I_nms_threshold,I_pre_nms_topn,I_min_size],[],[],[O_rois,O_roi_probabilities],['post_nms_topn'],['int'],[@A_post_nms_topn])
  end;
function TGraphExt.AddGenerateVocabRemapping(const I_new_vocab_file:string; const I_old_vocab_file:string; const O_remapping:string; const O_num_present:string; const A_new_vocab_offset:cint64; const A_num_new_vocab:cint64; const A_old_vocab_size:cint64):string;
  begin
  result:=AddOper('GenerateVocabRemapping',[I_new_vocab_file,I_old_vocab_file],[],[],[O_remapping,O_num_present],['new_vocab_offset','num_new_vocab','old_vocab_size'],['int','int','int'],[@A_new_vocab_offset,@A_num_new_vocab,@A_old_vocab_size])
  end;
function TGraphExt.AddGeneratorDataset(const IL_init_func_other_args:string; const IL_next_func_other_args:string; const IL_finalize_func_other_args:string; const O_handle:string; const A_init_func:TF_Function; const A_next_func:TF_Function; const A_finalize_func:TF_Function; const A_Tinit_func_args:TF_TypeList; const A_Tnext_func_args:TF_TypeList; const A_Tfinalize_func_args:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('GeneratorDataset',[],[IL_init_func_other_args,IL_next_func_other_args,IL_finalize_func_other_args],[Length(A_Tinit_func_args),Length(A_Tnext_func_args),Length(A_Tfinalize_func_args)],[O_handle],['init_func','next_func','finalize_func','Tinit_func_args','Tnext_func_args','Tfinalize_func_args','output_types','output_shapes'],['func','func','func','list(type)','list(type)','list(type)','list(type)','list(shape)'],[@A_init_func,@A_next_func,@A_finalize_func,@A_Tinit_func_args,@A_Tnext_func_args,@A_Tfinalize_func_args,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddGetSessionHandle(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GetSessionHandle',[I_value],[],[],[O_handle],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGetSessionHandleV2(const I_value:string; const O_handle:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GetSessionHandleV2',[I_value],[],[],[O_handle],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGetSessionTensor(const I_handle:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('GetSessionTensor',[I_handle],[],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddGreater(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Greater',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGreaterEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GreaterEqual',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddGroupByReducerDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_init_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_finalize_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_init_func:TF_Function; const A_reduce_func:TF_Function; const A_finalize_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Tinit_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Tfinalize_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('GroupByReducerDataset',[I_input_dataset],[IL_key_func_other_arguments,IL_init_func_other_arguments,IL_reduce_func_other_arguments,IL_finalize_func_other_arguments],[Length(A_Tkey_func_other_arguments),Length(A_Tinit_func_other_arguments),Length(A_Treduce_func_other_arguments),Length(A_Tfinalize_func_other_arguments)],[O_handle],['key_func','init_func','reduce_func','finalize_func','Tkey_func_other_arguments','Tinit_func_other_arguments','Treduce_func_other_arguments','Tfinalize_func_other_arguments','output_types','output_shapes'],['func','func','func','func','list(type)','list(type)','list(type)','list(type)','list(type)','list(shape)'],[@A_key_func,@A_init_func,@A_reduce_func,@A_finalize_func,@A_Tkey_func_other_arguments,@A_Tinit_func_other_arguments,@A_Treduce_func_other_arguments,@A_Tfinalize_func_other_arguments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddGroupByWindowDataset(const I_input_dataset:string; const IL_key_func_other_arguments:string; const IL_reduce_func_other_arguments:string; const IL_window_size_func_other_arguments:string; const O_handle:string; const A_key_func:TF_Function; const A_reduce_func:TF_Function; const A_window_size_func:TF_Function; const A_Tkey_func_other_arguments:TF_TypeList; const A_Treduce_func_other_arguments:TF_TypeList; const A_Twindow_size_func_other_arguments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('GroupByWindowDataset',[I_input_dataset],[IL_key_func_other_arguments,IL_reduce_func_other_arguments,IL_window_size_func_other_arguments],[Length(A_Tkey_func_other_arguments),Length(A_Treduce_func_other_arguments),Length(A_Twindow_size_func_other_arguments)],[O_handle],['key_func','reduce_func','window_size_func','Tkey_func_other_arguments','Treduce_func_other_arguments','Twindow_size_func_other_arguments','output_types','output_shapes'],['func','func','func','list(type)','list(type)','list(type)','list(type)','list(shape)'],[@A_key_func,@A_reduce_func,@A_window_size_func,@A_Tkey_func_other_arguments,@A_Treduce_func_other_arguments,@A_Twindow_size_func_other_arguments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddGuaranteeConst(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('GuaranteeConst',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddHSVToRGB(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('HSVToRGB',[I_images],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('HashTable',[],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('HashTableV2',[],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddHistogramFixedWidth(const I_values:string; const I_value_range:string; const I_nbins:string; const O_out:string; const A_T:TF_DataType; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('HistogramFixedWidth',[I_values,I_value_range,I_nbins],[],[],[O_out],['T','dtype'],['type','type'],[@A_T,@A_dtype])
  end;
function TGraphExt.AddHistogramSummary(const I_tag:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('HistogramSummary',[I_tag,I_values],[],[],[O_summary],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddHostConst(const O_output:string; const A_value:TF_TensorPtr; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('HostConst',[],[],[],[O_output],['value','dtype'],['tensor','type'],[@A_value,@A_dtype])
  end;
function TGraphExt.AddIFFT(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('IFFT',[I_input],[],[],[O_output],['Tcomplex'],['type'],[@A_Tcomplex])
  end;
function TGraphExt.AddIFFT2D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('IFFT2D',[I_input],[],[],[O_output],['Tcomplex'],['type'],[@A_Tcomplex])
  end;
function TGraphExt.AddIFFT3D(const I_input:string; const O_output:string; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('IFFT3D',[I_input],[],[],[O_output],['Tcomplex'],['type'],[@A_Tcomplex])
  end;
function TGraphExt.AddIRFFT(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('IRFFT',[I_input,I_fft_length],[],[],[O_output],['Treal','Tcomplex'],['type','type'],[@A_Treal,@A_Tcomplex])
  end;
function TGraphExt.AddIRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('IRFFT2D',[I_input,I_fft_length],[],[],[O_output],['Treal','Tcomplex'],['type','type'],[@A_Treal,@A_Tcomplex])
  end;
function TGraphExt.AddIRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('IRFFT3D',[I_input,I_fft_length],[],[],[O_output],['Treal','Tcomplex'],['type','type'],[@A_Treal,@A_Tcomplex])
  end;
function TGraphExt.AddIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Identity',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIdentityN(const IL_input:string; const OL_output:string; const A_T:TF_TypeList):string;
  begin
  result:=AddOper('IdentityN',[],[IL_input],[Length(A_T)],[OL_output],['T'],['list(type)'],[@A_T])
  end;
function TGraphExt.AddIdentityReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('IdentityReader',[],[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddIdentityReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('IdentityReaderV2',[],[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddIf(const I_cond:string; const IL_input:string; const OL_output:string; const A_Tcond:TF_DataType; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_then_branch:TF_Function; const A_else_branch:TF_Function; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('If',[I_cond],[IL_input],[Length(A_Tin)],[OL_output],['Tcond','Tin','Tout','then_branch','else_branch','output_shapes'],['type','list(type)','list(type)','func','func','list(shape)'],[@A_Tcond,@A_Tin,@A_Tout,@A_then_branch,@A_else_branch,@A_output_shapes])
  end;
function TGraphExt.AddIgamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Igamma',[I_a,I_x],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIgammaGradA(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IgammaGradA',[I_a,I_x],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIgammac(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Igammac',[I_a,I_x],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIgnoreErrorsDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IgnoreErrorsDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddImag(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Imag',[I_input],[],[],[O_output],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddImageProjectiveTransformV2(const I_images:string; const I_transforms:string; const I_output_shape:string; const O_transformed_images:string; const A_dtype:TF_DataType; const A_interpolation:string):string;
  begin
  result:=AddOper('ImageProjectiveTransformV2',[I_images,I_transforms,I_output_shape],[],[],[O_transformed_images],['dtype','interpolation'],['type','string'],[@A_dtype,@A_interpolation])
  end;
function TGraphExt.AddImageSummary(const I_tag:string; const I_tensor:string; const O_summary:string; const A_max_images:cint64; const A_T:TF_DataType; const A_bad_color:TF_TensorPtr):string;
  begin
  result:=AddOper('ImageSummary',[I_tag,I_tensor],[],[],[O_summary],['max_images','T','bad_color'],['int','type','tensor'],[@A_max_images,@A_T,@A_bad_color])
  end;
function TGraphExt.AddImmutableConst(const O_tensor:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):string;
  begin
  result:=AddOper('ImmutableConst',[],[],[],[O_tensor],['dtype','shape','memory_region_name'],['type','shape','string'],[@A_dtype,@A_shape,@A_memory_region_name])
  end;
function TGraphExt.AddImportEvent(const I_writer:string; const I_event:string):string;
  begin
  result:=AddOper('ImportEvent',[I_writer,I_event],[],[],[],[],[],[])
  end;
function TGraphExt.AddInTopK(const I_predictions:string; const I_targets:string; const O_precision:string; const A_k:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InTopK',[I_predictions,I_targets],[],[],[O_precision],['k','T'],['int','type'],[@A_k,@A_T])
  end;
function TGraphExt.AddInTopKV2(const I_predictions:string; const I_targets:string; const I_k:string; const O_precision:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InTopKV2',[I_predictions,I_targets,I_k],[],[],[O_precision],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInfeedDequeue(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('InfeedDequeue',[],[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddInfeedDequeueTuple(const OL_outputs:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('InfeedDequeueTuple',[],[],[],[OL_outputs],['dtypes','shapes'],['list(type)','list(shape)'],[@A_dtypes,@A_shapes])
  end;
function TGraphExt.AddInfeedEnqueue(const I_input:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_layout:TF_IntList; const A_device_ordinal:cint64):string;
  begin
  result:=AddOper('InfeedEnqueue',[I_input],[],[],[],['dtype','shape','layout','device_ordinal'],['type','shape','list(int)','int'],[@A_dtype,@A_shape,@A_layout,@A_device_ordinal])
  end;
function TGraphExt.AddInfeedEnqueuePrelinearizedBuffer(const I_input:string; const A_device_ordinal:cint64):string;
  begin
  result:=AddOper('InfeedEnqueuePrelinearizedBuffer',[I_input],[],[],[],['device_ordinal'],['int'],[@A_device_ordinal])
  end;
function TGraphExt.AddInfeedEnqueueTuple(const IL_inputs:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList; const A_layouts:TF_IntList; const A_device_ordinal:cint64):string;
  begin
  result:=AddOper('InfeedEnqueueTuple',[],[IL_inputs],[Length(A_dtypes)],[],['dtypes','shapes','layouts','device_ordinal'],['list(type)','list(shape)','list(int)','int'],[@A_dtypes,@A_shapes,@A_layouts,@A_device_ordinal])
  end;
function TGraphExt.AddInitializeTable(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
  begin
  result:=AddOper('InitializeTable',[I_table_handle,I_keys,I_values],[],[],[],['Tkey','Tval'],['type','type'],[@A_Tkey,@A_Tval])
  end;
function TGraphExt.AddInitializeTableFromTextFile(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
  begin
  result:=AddOper('InitializeTableFromTextFile',[I_table_handle,I_filename],[],[],[],['key_index','value_index','vocab_size','delimiter'],['int','int','int','string'],[@A_key_index,@A_value_index,@A_vocab_size,@A_delimiter])
  end;
function TGraphExt.AddInitializeTableFromTextFileV2(const I_table_handle:string; const I_filename:string; const A_key_index:cint64; const A_value_index:cint64; const A_vocab_size:cint64; const A_delimiter:string):string;
  begin
  result:=AddOper('InitializeTableFromTextFileV2',[I_table_handle,I_filename],[],[],[],['key_index','value_index','vocab_size','delimiter'],['int','int','int','string'],[@A_key_index,@A_value_index,@A_vocab_size,@A_delimiter])
  end;
function TGraphExt.AddInitializeTableV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tkey:TF_DataType; const A_Tval:TF_DataType):string;
  begin
  result:=AddOper('InitializeTableV2',[I_table_handle,I_keys,I_values],[],[],[],['Tkey','Tval'],['type','type'],[@A_Tkey,@A_Tval])
  end;
function TGraphExt.AddInplaceAdd(const I_x:string; const I_i:string; const I_v:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InplaceAdd',[I_x,I_i,I_v],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInplaceSub(const I_x:string; const I_i:string; const I_v:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InplaceSub',[I_x,I_i,I_v],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInplaceUpdate(const I_x:string; const I_i:string; const I_v:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InplaceUpdate',[I_x,I_i,I_v],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('InterleaveDataset',[I_input_dataset,I_cycle_length,I_block_length],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddInv(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Inv',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInvGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InvGrad',[I_y,I_dy],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInvert(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Invert',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddInvertPermutation(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('InvertPermutation',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsBoostedTreesEnsembleInitialized(const I_tree_ensemble_handle:string; const O_is_initialized:string):string;
  begin
  result:=AddOper('IsBoostedTreesEnsembleInitialized',[I_tree_ensemble_handle],[],[],[O_is_initialized],[],[],[])
  end;
function TGraphExt.AddIsBoostedTreesQuantileStreamResourceInitialized(const I_quantile_stream_resource_handle:string; const O_is_initialized:string):string;
  begin
  result:=AddOper('IsBoostedTreesQuantileStreamResourceInitialized',[I_quantile_stream_resource_handle],[],[],[O_is_initialized],[],[],[])
  end;
function TGraphExt.AddIsFinite(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IsFinite',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsInf(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IsInf',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsNan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('IsNan',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddIsVariableInitialized(const I_ref:string; const O_is_initialized:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('IsVariableInitialized',[I_ref],[],[],[O_is_initialized],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddIterator(const O_handle:string; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('Iterator',[],[],[],[O_handle],['shared_name','container','output_types','output_shapes'],['string','string','list(type)','list(shape)'],[@A_shared_name,@A_container,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorFromStringHandle(const I_string_handle:string; const O_resource_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorFromStringHandle',[I_string_handle],[],[],[O_resource_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorFromStringHandleV2(const I_string_handle:string; const O_resource_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorFromStringHandleV2',[I_string_handle],[],[],[O_resource_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorGetDevice(const I_resource:string; const O_device:string):string;
  begin
  result:=AddOper('IteratorGetDevice',[I_resource],[],[],[O_device],[],[],[])
  end;
function TGraphExt.AddIteratorGetNext(const I_iterator:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorGetNext',[I_iterator],[],[],[OL_components],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorGetNextAsOptional(const I_iterator:string; const O_optional:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorGetNextAsOptional',[I_iterator],[],[],[O_optional],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorGetNextSync(const I_iterator:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorGetNextSync',[I_iterator],[],[],[OL_components],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddIteratorToStringHandle(const I_resource_handle:string; const O_string_handle:string):string;
  begin
  result:=AddOper('IteratorToStringHandle',[I_resource_handle],[],[],[O_string_handle],[],[],[])
  end;
function TGraphExt.AddIteratorV2(const O_handle:string; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('IteratorV2',[],[],[],[O_handle],['shared_name','container','output_types','output_shapes'],['string','string','list(type)','list(shape)'],[@A_shared_name,@A_container,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddKMC2ChainInitialization(const I_distances:string; const I_seed:string; const O_index:string):string;
  begin
  result:=AddOper('KMC2ChainInitialization',[I_distances,I_seed],[],[],[O_index],[],[],[])
  end;
function TGraphExt.AddKmeansPlusPlusInitialization(const I_points:string; const I_num_to_sample:string; const I_seed:string; const I_num_retries_per_sample:string; const O_samples:string):string;
  begin
  result:=AddOper('KmeansPlusPlusInitialization',[I_points,I_num_to_sample,I_seed,I_num_retries_per_sample],[],[],[O_samples],[],[],[])
  end;
function TGraphExt.AddL2Loss(const I_t:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('L2Loss',[I_t],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLMDBDataset(const I_filenames:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('LMDBDataset',[I_filenames],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddLMDBReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('LMDBReader',[],[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddLRN(const I_input:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LRN',[I_input],[],[],[O_output],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@A_T])
  end;
function TGraphExt.AddLRNGrad(const I_input_grads:string; const I_input_image:string; const I_output_image:string; const O_output:string; const A_depth_radius:cint64; const A_bias:real; const A_alpha:real; const A_beta:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LRNGrad',[I_input_grads,I_input_image,I_output_image],[],[],[O_output],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@A_T])
  end;
function TGraphExt.AddLSTMBlockCell(const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const O_i:string; const O_cs:string; const O_f:string; const O_o:string; const O_ci:string; const O_co:string; const O_h:string; const A_forget_bias:real; const A_cell_clip:real; const A_use_peephole:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LSTMBlockCell',[I_x,I_cs_prev,I_h_prev,I_w,I_wci,I_wcf,I_wco,I_b],[],[],[O_i,O_cs,O_f,O_o,O_ci,O_co,O_h],['forget_bias','cell_clip','use_peephole','T'],['float','float','bool','type'],[@A_forget_bias,@A_cell_clip,@A_use_peephole,@A_T])
  end;
function TGraphExt.AddLSTMBlockCellGrad(const I_x:string; const I_cs_prev:string; const I_h_prev:string; const I_w:string; const I_wci:string; const I_wcf:string; const I_wco:string; const I_b:string; const I_i:string; const I_cs:string; const I_f:string; const I_o:string; const I_ci:string; const I_co:string; const I_cs_grad:string; const I_h_grad:string; const O_cs_prev_grad:string; const O_dicfo:string; const O_wci_grad:string; const O_wcf_grad:string; const O_wco_grad:string; const A_use_peephole:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LSTMBlockCellGrad',[I_x,I_cs_prev,I_h_prev,I_w,I_wci,I_wcf,I_wco,I_b,I_i,I_cs,I_f,I_o,I_ci,I_co,I_cs_grad,I_h_grad],[],[],[O_cs_prev_grad,O_dicfo,O_wci_grad,O_wcf_grad,O_wco_grad],['use_peephole','T'],['bool','type'],[@A_use_peephole,@A_T])
  end;
function TGraphExt.AddLatencyStatsDataset(const I_input_dataset:string; const I_tag:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('LatencyStatsDataset',[I_input_dataset,I_tag],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddLeakyRelu(const I_features:string; const O_activations:string; const A_alpha:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LeakyRelu',[I_features],[],[],[O_activations],['alpha','T'],['float','type'],[@A_alpha,@A_T])
  end;
function TGraphExt.AddLeakyReluGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_alpha:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LeakyReluGrad',[I_gradients,I_features],[],[],[O_backprops],['alpha','T'],['float','type'],[@A_alpha,@A_T])
  end;
function TGraphExt.AddLearnedUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('LearnedUnigramCandidateSampler',[I_true_classes],[],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddLeftShift(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LeftShift',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLess(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Less',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLessEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LessEqual',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLgamma(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Lgamma',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLinSpace(const I_start:string; const I_stop:string; const I_num:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('LinSpace',[I_start,I_stop,I_num],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddListDiff(const I_x:string; const I_y:string; const O_out:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('ListDiff',[I_x,I_y],[],[],[O_out,O_idx],['T','out_idx'],['type','type'],[@A_T,@A_out_idx])
  end;
function TGraphExt.AddLoadAndRemapMatrix(const I_ckpt_path:string; const I_old_tensor_name:string; const I_row_remapping:string; const I_col_remapping:string; const I_initializing_values:string; const O_output_matrix:string; const A_num_rows:cint64; const A_num_cols:cint64; const A_max_rows_in_memory:cint64):string;
  begin
  result:=AddOper('LoadAndRemapMatrix',[I_ckpt_path,I_old_tensor_name,I_row_remapping,I_col_remapping,I_initializing_values],[],[],[O_output_matrix],['num_rows','num_cols','max_rows_in_memory'],['int','int','int'],[@A_num_rows,@A_num_cols,@A_max_rows_in_memory])
  end;
function TGraphExt.AddLoadTPUEmbeddingADAMParameters(const I_parameters:string; const I_momenta:string; const I_velocities:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingADAMParameters',[I_parameters,I_momenta,I_velocities],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingADAMParametersGradAccumDebug(const I_parameters:string; const I_momenta:string; const I_velocities:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingADAMParametersGradAccumDebug',[I_parameters,I_momenta,I_velocities,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingAdadeltaParameters(const I_parameters:string; const I_accumulators:string; const I_updates:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingAdadeltaParameters',[I_parameters,I_accumulators,I_updates],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingAdadeltaParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_updates:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingAdadeltaParametersGradAccumDebug',[I_parameters,I_accumulators,I_updates,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingAdagradParameters(const I_parameters:string; const I_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingAdagradParameters',[I_parameters,I_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingAdagradParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingAdagradParametersGradAccumDebug',[I_parameters,I_accumulators,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingCenteredRMSPropParameters(const I_parameters:string; const I_ms:string; const I_mom:string; const I_mg:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingCenteredRMSPropParameters',[I_parameters,I_ms,I_mom,I_mg],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingFTRLParameters(const I_parameters:string; const I_accumulators:string; const I_linears:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingFTRLParameters',[I_parameters,I_accumulators,I_linears],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingFTRLParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_linears:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingFTRLParametersGradAccumDebug',[I_parameters,I_accumulators,I_linears,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingMDLAdagradLightParameters(const I_parameters:string; const I_accumulators:string; const I_weights:string; const I_benefits:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingMDLAdagradLightParameters',[I_parameters,I_accumulators,I_weights,I_benefits],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingMomentumParameters(const I_parameters:string; const I_momenta:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingMomentumParameters',[I_parameters,I_momenta],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingMomentumParametersGradAccumDebug(const I_parameters:string; const I_momenta:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingMomentumParametersGradAccumDebug',[I_parameters,I_momenta,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingProximalAdagradParameters(const I_parameters:string; const I_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingProximalAdagradParameters',[I_parameters,I_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(const I_parameters:string; const I_accumulators:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug',[I_parameters,I_accumulators,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingRMSPropParameters(const I_parameters:string; const I_ms:string; const I_mom:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingRMSPropParameters',[I_parameters,I_ms,I_mom],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingRMSPropParametersGradAccumDebug(const I_parameters:string; const I_ms:string; const I_mom:string; const I_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingRMSPropParametersGradAccumDebug',[I_parameters,I_ms,I_mom,I_gradient_accumulators],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLoadTPUEmbeddingStochasticGradientDescentParameters(const I_parameters:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('LoadTPUEmbeddingStochasticGradientDescentParameters',[I_parameters],[],[],[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddLog(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Log',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLog1p(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Log1p',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLogMatrixDeterminant(const I_input:string; const O_sign:string; const O_log_abs_determinant:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LogMatrixDeterminant',[I_input],[],[],[O_sign,O_log_abs_determinant],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLogSoftmax(const I_logits:string; const O_logsoftmax:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('LogSoftmax',[I_logits],[],[],[O_logsoftmax],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddLogUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('LogUniformCandidateSampler',[I_true_classes],[],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddLogicalAnd(const I_x:string; const I_y:string; const O_z:string):string;
  begin
  result:=AddOper('LogicalAnd',[I_x,I_y],[],[],[O_z],[],[],[])
  end;
function TGraphExt.AddLogicalNot(const I_x:string; const O_y:string):string;
  begin
  result:=AddOper('LogicalNot',[I_x],[],[],[O_y],[],[],[])
  end;
function TGraphExt.AddLogicalOr(const I_x:string; const I_y:string; const O_z:string):string;
  begin
  result:=AddOper('LogicalOr',[I_x,I_y],[],[],[O_z],[],[],[])
  end;
function TGraphExt.AddLookupTableExport(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
  begin
  result:=AddOper('LookupTableExport',[I_table_handle],[],[],[O_keys,O_values],['Tkeys','Tvalues'],['type','type'],[@A_Tkeys,@A_Tvalues])
  end;
function TGraphExt.AddLookupTableExportV2(const I_table_handle:string; const O_keys:string; const O_values:string; const A_Tkeys:TF_DataType; const A_Tvalues:TF_DataType):string;
  begin
  result:=AddOper('LookupTableExportV2',[I_table_handle],[],[],[O_keys,O_values],['Tkeys','Tvalues'],['type','type'],[@A_Tkeys,@A_Tvalues])
  end;
function TGraphExt.AddLookupTableFind(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableFind',[I_table_handle,I_keys,I_default_value],[],[],[O_values],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableFindV2(const I_table_handle:string; const I_keys:string; const I_default_value:string; const O_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableFindV2',[I_table_handle,I_keys,I_default_value],[],[],[O_values],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableImport(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableImport',[I_table_handle,I_keys,I_values],[],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableImportV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableImportV2',[I_table_handle,I_keys,I_values],[],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableInsert(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableInsert',[I_table_handle,I_keys,I_values],[],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableInsertV2(const I_table_handle:string; const I_keys:string; const I_values:string; const A_Tin:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('LookupTableInsertV2',[I_table_handle,I_keys,I_values],[],[],[],['Tin','Tout'],['type','type'],[@A_Tin,@A_Tout])
  end;
function TGraphExt.AddLookupTableRemoveV2(const I_table_handle:string; const I_keys:string; const A_Tin:TF_DataType):string;
  begin
  result:=AddOper('LookupTableRemoveV2',[I_table_handle,I_keys],[],[],[],['Tin'],['type'],[@A_Tin])
  end;
function TGraphExt.AddLookupTableSize(const I_table_handle:string; const O_size:string):string;
  begin
  result:=AddOper('LookupTableSize',[I_table_handle],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddLookupTableSizeV2(const I_table_handle:string; const O_size:string):string;
  begin
  result:=AddOper('LookupTableSizeV2',[I_table_handle],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddLoopCond(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('LoopCond',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddLowerBound(const I_sorted_inputs:string; const I_values:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('LowerBound',[I_sorted_inputs,I_values],[],[],[O_output],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddLu(const I_input:string; const O_lu:string; const O_p:string; const A_T:TF_DataType; const A_output_idx_type:TF_DataType):string;
  begin
  result:=AddOper('Lu',[I_input],[],[],[O_lu,O_p],['T','output_idx_type'],['type','type'],[@A_T,@A_output_idx_type])
  end;
function TGraphExt.AddMakeIterator(const I_dataset:string; const I_iterator:string):string;
  begin
  result:=AddOper('MakeIterator',[I_dataset,I_iterator],[],[],[],[],[],[])
  end;
function TGraphExt.AddMapAndBatchDataset(const I_input_dataset:string; const I_batch_size:string; const I_num_parallel_calls:string; const I_drop_remainder:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean):string;
  begin
  result:=AddOper('MapAndBatchDataset',[I_input_dataset,I_batch_size,I_num_parallel_calls,I_drop_remainder],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes','preserve_cardinality'],['func','list(type)','list(type)','list(shape)','bool'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes,@A_preserve_cardinality])
  end;
function TGraphExt.AddMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapClear',[],[],[],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean; const A_preserve_cardinality:boolean):string;
  begin
  result:=AddOper('MapDataset',[I_input_dataset],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes','use_inter_op_parallelism','preserve_cardinality'],['func','list(type)','list(type)','list(shape)','bool','bool'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes,@A_use_inter_op_parallelism,@A_preserve_cardinality])
  end;
function TGraphExt.AddMapDefun(const IL_arguments:string; const IL_captured_inputs:string; const OL_output:string; const A_Targuments:TF_TypeList; const A_Tcaptured:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_f:TF_Function; const A_max_intra_op_parallelism:cint64):string;
  begin
  result:=AddOper('MapDefun',[],[IL_arguments,IL_captured_inputs],[Length(A_Targuments),Length(A_Tcaptured)],[OL_output],['Targuments','Tcaptured','output_types','output_shapes','f','max_intra_op_parallelism'],['list(type)','list(type)','list(type)','list(shape)','func','int'],[@A_Targuments,@A_Tcaptured,@A_output_types,@A_output_shapes,@A_f,@A_max_intra_op_parallelism])
  end;
function TGraphExt.AddMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapIncompleteSize',[],[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapPeek(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapPeek',[I_key,I_indices],[],[],[OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapSize',[],[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapStage(const I_key:string; const I_indices:string; const IL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapStage',[I_key,I_indices],[IL_values],[Length(A_fake_dtypes)],[],['capacity','memory_limit','dtypes','fake_dtypes','container','shared_name'],['int','int','list(type)','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_fake_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapUnstage(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapUnstage',[I_key,I_indices],[],[],[OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MapUnstageNoKey',[I_indices],[],[],[O_key,OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatMul',[I_a,I_b],[],[],[O_product],['transpose_a','transpose_b','T'],['bool','bool','type'],[@A_transpose_a,@A_transpose_b,@A_T])
  end;
function TGraphExt.AddMatchingFiles(const I_pattern:string; const O_filenames:string):string;
  begin
  result:=AddOper('MatchingFiles',[I_pattern],[],[],[O_filenames],[],[],[])
  end;
function TGraphExt.AddMatchingFilesDataset(const I_patterns:string; const O_handle:string):string;
  begin
  result:=AddOper('MatchingFilesDataset',[I_patterns],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddMatrixBandPart(const I_input:string; const I_num_lower:string; const I_num_upper:string; const O_band:string; const A_T:TF_DataType; const A_Tindex:TF_DataType):string;
  begin
  result:=AddOper('MatrixBandPart',[I_input,I_num_lower,I_num_upper],[],[],[O_band],['T','Tindex'],['type','type'],[@A_T,@A_Tindex])
  end;
function TGraphExt.AddMatrixDeterminant(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDeterminant',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiag(const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDiag',[I_diagonal],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiagPart(const I_input:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDiagPart',[I_input],[],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiagPartV2(const I_input:string; const I_k:string; const I_padding_value:string; const O_diagonal:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDiagPartV2',[I_input,I_k,I_padding_value],[],[],[O_diagonal],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiagPartV3(const I_input:string; const I_k:string; const I_padding_value:string; const O_diagonal:string; const A_T:TF_DataType; const A_align:string):string;
  begin
  result:=AddOper('MatrixDiagPartV3',[I_input,I_k,I_padding_value],[],[],[O_diagonal],['T','align'],['type','string'],[@A_T,@A_align])
  end;
function TGraphExt.AddMatrixDiagV2(const I_diagonal:string; const I_k:string; const I_num_rows:string; const I_num_cols:string; const I_padding_value:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixDiagV2',[I_diagonal,I_k,I_num_rows,I_num_cols,I_padding_value],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixDiagV3(const I_diagonal:string; const I_k:string; const I_num_rows:string; const I_num_cols:string; const I_padding_value:string; const O_output:string; const A_T:TF_DataType; const A_align:string):string;
  begin
  result:=AddOper('MatrixDiagV3',[I_diagonal,I_k,I_num_rows,I_num_cols,I_padding_value],[],[],[O_output],['T','align'],['type','string'],[@A_T,@A_align])
  end;
function TGraphExt.AddMatrixExponential(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixExponential',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixInverse(const I_input:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixInverse',[I_input],[],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddMatrixLogarithm(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixLogarithm',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixSetDiag(const I_input:string; const I_diagonal:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixSetDiag',[I_input,I_diagonal],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixSetDiagV2(const I_input:string; const I_diagonal:string; const I_k:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixSetDiagV2',[I_input,I_diagonal,I_k],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixSetDiagV3(const I_input:string; const I_diagonal:string; const I_k:string; const O_output:string; const A_T:TF_DataType; const A_align:string):string;
  begin
  result:=AddOper('MatrixSetDiagV3',[I_input,I_diagonal,I_k],[],[],[O_output],['T','align'],['type','string'],[@A_T,@A_align])
  end;
function TGraphExt.AddMatrixSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixSolve',[I_matrix,I_rhs],[],[],[O_output],['adjoint','T'],['bool','type'],[@A_adjoint,@A_T])
  end;
function TGraphExt.AddMatrixSolveLs(const I_matrix:string; const I_rhs:string; const I_l2_regularizer:string; const O_output:string; const A_T:TF_DataType; const A_fast:boolean):string;
  begin
  result:=AddOper('MatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],[],[],[O_output],['T','fast'],['type','bool'],[@A_T,@A_fast])
  end;
function TGraphExt.AddMatrixSquareRoot(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixSquareRoot',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMatrixTriangularSolve(const I_matrix:string; const I_rhs:string; const O_output:string; const A_lower:boolean; const A_adjoint:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MatrixTriangularSolve',[I_matrix,I_rhs],[],[],[O_output],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@A_T])
  end;
function TGraphExt.AddMax(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Max',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddMaxIntraOpParallelismDataset(const I_input_dataset:string; const I_max_intra_op_parallelism:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('MaxIntraOpParallelismDataset',[I_input_dataset,I_max_intra_op_parallelism],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddMaxPool(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('MaxPool',[I_input],[],[],[O_output],['T','ksize','strides','padding','data_format'],['type','list(int)','list(int)','string','string'],[@A_T,@A_ksize,@A_strides,@A_padding,@A_data_format])
  end;
function TGraphExt.AddMaxPool3D(const I_input:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPool3D',[I_input],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPool3DGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType; const A_TInput:TF_DataType):string;
  begin
  result:=AddOper('MaxPool3DGrad',[I_orig_input,I_orig_output,I_grad],[],[],[O_output],['ksize','strides','padding','data_format','T','TInput'],['list(int)','list(int)','string','string','type','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T,@A_TInput])
  end;
function TGraphExt.AddMaxPool3DGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPool3DGradGrad',[I_orig_input,I_orig_output,I_grad],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGrad',[I_orig_input,I_orig_output,I_grad],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGradGrad(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradGrad',[I_orig_input,I_orig_output,I_grad],[],[],[O_output],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGradGradV2(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const I_ksize:string; const I_strides:string; const O_output:string; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradGradV2',[I_orig_input,I_orig_output,I_grad,I_ksize,I_strides],[],[],[O_output],['padding','data_format','T'],['string','string','type'],[@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGradGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_include_batch_in_index:boolean; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradGradWithArgmax',[I_input,I_grad,I_argmax],[],[],[O_output],['ksize','strides','padding','include_batch_in_index','Targmax','T'],['list(int)','list(int)','string','bool','type','type'],[@A_ksize,@A_strides,@A_padding,@A_include_batch_in_index,@A_Targmax,@A_T])
  end;
function TGraphExt.AddMaxPoolGradV2(const I_orig_input:string; const I_orig_output:string; const I_grad:string; const I_ksize:string; const I_strides:string; const O_output:string; const A_padding:string; const A_data_format:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradV2',[I_orig_input,I_orig_output,I_grad,I_ksize,I_strides],[],[],[O_output],['padding','data_format','T'],['string','string','type'],[@A_padding,@A_data_format,@A_T])
  end;
function TGraphExt.AddMaxPoolGradWithArgmax(const I_input:string; const I_grad:string; const I_argmax:string; const O_output:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string; const A_include_batch_in_index:boolean; const A_Targmax:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolGradWithArgmax',[I_input,I_grad,I_argmax],[],[],[O_output],['ksize','strides','padding','include_batch_in_index','Targmax','T'],['list(int)','list(int)','string','bool','type','type'],[@A_ksize,@A_strides,@A_padding,@A_include_batch_in_index,@A_Targmax,@A_T])
  end;
function TGraphExt.AddMaxPoolV2(const I_input:string; const I_ksize:string; const I_strides:string; const O_output:string; const A_T:TF_DataType; const A_padding:string; const A_data_format:string):string;
  begin
  result:=AddOper('MaxPoolV2',[I_input,I_ksize,I_strides],[],[],[O_output],['T','padding','data_format'],['type','string','string'],[@A_T,@A_padding,@A_data_format])
  end;
function TGraphExt.AddMaxPoolWithArgmax(const I_input:string; const O_output:string; const O_argmax:string; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_Targmax:TF_DataType; const A_padding:string; const A_include_batch_in_index:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MaxPoolWithArgmax',[I_input],[],[],[O_output,O_argmax],['ksize','strides','Targmax','padding','include_batch_in_index','T'],['list(int)','list(int)','type','string','bool','type'],[@A_ksize,@A_strides,@A_Targmax,@A_padding,@A_include_batch_in_index,@A_T])
  end;
function TGraphExt.AddMaximum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Maximum',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMean(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Mean',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddMerge(const IL_inputs:string; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
  begin
  result:=AddOper('Merge',[],[IL_inputs],[A_N],[O_output,O_value_index],['T','N'],['type','int'],[@A_T,@A_N])
  end;
function TGraphExt.AddMergeSummary(const IL_inputs:string; const O_summary:string; const A_N:cint64):string;
  begin
  result:=AddOper('MergeSummary',[],[IL_inputs],[A_N],[O_summary],['N'],['int'],[@A_N])
  end;
function TGraphExt.AddMergeV2Checkpoints(const I_checkpoint_prefixes:string; const I_destination_prefix:string; const A_delete_old_dirs:boolean):string;
  begin
  result:=AddOper('MergeV2Checkpoints',[I_checkpoint_prefixes,I_destination_prefix],[],[],[],['delete_old_dirs'],['bool'],[@A_delete_old_dirs])
  end;
function TGraphExt.AddMfcc(const I_spectrogram:string; const I_sample_rate:string; const O_output:string; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:cint64; const A_dct_coefficient_count:cint64):string;
  begin
  result:=AddOper('Mfcc',[I_spectrogram,I_sample_rate],[],[],[O_output],['upper_frequency_limit','lower_frequency_limit','filterbank_channel_count','dct_coefficient_count'],['float','float','int','int'],[@A_upper_frequency_limit,@A_lower_frequency_limit,@A_filterbank_channel_count,@A_dct_coefficient_count])
  end;
function TGraphExt.AddMin(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Min',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddMinimum(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Minimum',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMirrorPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
  begin
  result:=AddOper('MirrorPad',[I_input,I_paddings],[],[],[O_output],['T','Tpaddings','mode'],['type','type','string'],[@A_T,@A_Tpaddings,@A_mode])
  end;
function TGraphExt.AddMirrorPadGrad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_mode:string):string;
  begin
  result:=AddOper('MirrorPadGrad',[I_input,I_paddings],[],[],[O_output],['T','Tpaddings','mode'],['type','type','string'],[@A_T,@A_Tpaddings,@A_mode])
  end;
function TGraphExt.AddMlirPassthroughOp(const IL_inputs:string; const OL_outputs:string; const A_mlir_module:string; const A_Tinputs:TF_TypeList; const A_Toutputs:TF_TypeList):string;
  begin
  result:=AddOper('MlirPassthroughOp',[],[IL_inputs],[Length(A_Tinputs)],[OL_outputs],['mlir_module','Tinputs','Toutputs'],['string','list(type)','list(type)'],[@A_mlir_module,@A_Tinputs,@A_Toutputs])
  end;
function TGraphExt.AddMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Mod',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddModelDataset(const I_input_dataset:string; const O_handle:string; const A_algorithm:cint64; const A_cpu_budget:cint64; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ModelDataset',[I_input_dataset],[],[],[O_handle],['algorithm','cpu_budget','output_types','output_shapes'],['int','int','list(type)','list(shape)'],[@A_algorithm,@A_cpu_budget,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddMul(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Mul',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMulNoNan(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('MulNoNan',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddMultiDeviceIterator(const O_handle:string; const A_devices:TF_StringList; const A_shared_name:string; const A_container:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('MultiDeviceIterator',[],[],[],[O_handle],['devices','shared_name','container','output_types','output_shapes'],['list(string)','string','string','list(type)','list(shape)'],[@A_devices,@A_shared_name,@A_container,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddMultiDeviceIteratorFromStringHandle(const I_string_handle:string; const O_multi_device_iterator:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('MultiDeviceIteratorFromStringHandle',[I_string_handle],[],[],[O_multi_device_iterator],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddMultiDeviceIteratorGetNextFromShard(const I_multi_device_iterator:string; const I_shard_num:string; const I_incarnation_id:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('MultiDeviceIteratorGetNextFromShard',[I_multi_device_iterator,I_shard_num,I_incarnation_id],[],[],[OL_components],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddMultiDeviceIteratorInit(const I_dataset:string; const I_multi_device_iterator:string; const I_max_buffer_size:string; const O_incarnation_id:string):string;
  begin
  result:=AddOper('MultiDeviceIteratorInit',[I_dataset,I_multi_device_iterator,I_max_buffer_size],[],[],[O_incarnation_id],[],[],[])
  end;
function TGraphExt.AddMultiDeviceIteratorToStringHandle(const I_multi_device_iterator:string; const O_string_handle:string):string;
  begin
  result:=AddOper('MultiDeviceIteratorToStringHandle',[I_multi_device_iterator],[],[],[O_string_handle],[],[],[])
  end;
function TGraphExt.AddMultinomial(const I_logits:string; const I_num_samples:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType; const A_output_dtype:TF_DataType):string;
  begin
  result:=AddOper('Multinomial',[I_logits,I_num_samples],[],[],[O_output],['seed','seed2','T','output_dtype'],['int','int','type','type'],[@A_seed,@A_seed2,@A_T,@A_output_dtype])
  end;
function TGraphExt.AddMutableDenseHashTable(const I_empty_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
  begin
  result:=AddOper('MutableDenseHashTable',[I_empty_key],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor])
  end;
function TGraphExt.AddMutableDenseHashTableV2(const I_empty_key:string; const I_deleted_key:string; const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:cint64; const A_max_load_factor:real):string;
  begin
  result:=AddOper('MutableDenseHashTableV2',[I_empty_key,I_deleted_key],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor])
  end;
function TGraphExt.AddMutableHashTable(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('MutableHashTable',[],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddMutableHashTableOfTensors(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
  begin
  result:=AddOper('MutableHashTableOfTensors',[],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape])
  end;
function TGraphExt.AddMutableHashTableOfTensorsV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):string;
  begin
  result:=AddOper('MutableHashTableOfTensorsV2',[],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape])
  end;
function TGraphExt.AddMutableHashTableV2(const O_table_handle:string; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):string;
  begin
  result:=AddOper('MutableHashTableV2',[],[],[],[O_table_handle],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype])
  end;
function TGraphExt.AddMutexLock(const I_mutex:string; const O_mutex_lock:string):string;
  begin
  result:=AddOper('MutexLock',[I_mutex],[],[],[O_mutex_lock],[],[],[])
  end;
function TGraphExt.AddMutexV2(const O_resource:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('MutexV2',[],[],[],[O_resource],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddNcclAllReduce(const I_input:string; const O_data:string; const A_reduction:string; const A_T:TF_DataType; const A_num_devices:cint64; const A_shared_name:string):string;
  begin
  result:=AddOper('NcclAllReduce',[I_input],[],[],[O_data],['reduction','T','num_devices','shared_name'],['string','type','int','string'],[@A_reduction,@A_T,@A_num_devices,@A_shared_name])
  end;
function TGraphExt.AddNcclBroadcast(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('NcclBroadcast',[I_input],[],[],[O_output],['T','shape'],['type','shape'],[@A_T,@A_shape])
  end;
function TGraphExt.AddNcclReduce(const IL_input:string; const O_data:string; const A_reduction:string; const A_T:TF_DataType; const A_num_devices:cint64):string;
  begin
  result:=AddOper('NcclReduce',[],[IL_input],[A_num_devices],[O_data],['reduction','T','num_devices'],['string','type','int'],[@A_reduction,@A_T,@A_num_devices])
  end;
function TGraphExt.AddNdtri(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Ndtri',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddNearestNeighbors(const I_points:string; const I_centers:string; const I_k:string; const O_nearest_center_indices:string; const O_nearest_center_distances:string):string;
  begin
  result:=AddOper('NearestNeighbors',[I_points,I_centers,I_k],[],[],[O_nearest_center_indices,O_nearest_center_distances],[],[],[])
  end;
function TGraphExt.AddNeg(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Neg',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddNegTrain(const I_w_in:string; const I_w_out:string; const I_examples:string; const I_labels:string; const I_lr:string; const A_vocab_count:TF_IntList; const A_num_negative_samples:cint64):string;
  begin
  result:=AddOper('NegTrain',[I_w_in,I_w_out,I_examples,I_labels,I_lr],[],[],[],['vocab_count','num_negative_samples'],['list(int)','int'],[@A_vocab_count,@A_num_negative_samples])
  end;
function TGraphExt.AddNextAfter(const I_x1:string; const I_x2:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('NextAfter',[I_x1,I_x2],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('NextIteration',[I_data],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddNoOp():string;
  begin
  result:=AddOper('NoOp',[],[],[],[],[],[],[])
  end;
function TGraphExt.AddNonDeterministicInts(const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('NonDeterministicInts',[I_shape],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddNonMaxSuppression(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const O_selected_indices:string; const A_iou_threshold:real):string;
  begin
  result:=AddOper('NonMaxSuppression',[I_boxes,I_scores,I_max_output_size],[],[],[O_selected_indices],['iou_threshold'],['float'],[@A_iou_threshold])
  end;
function TGraphExt.AddNonMaxSuppressionV2(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const O_selected_indices:string; const A_T:TF_DataType; const A_T_threshold:TF_DataType):string;
  begin
  result:=AddOper('NonMaxSuppressionV2',[I_boxes,I_scores,I_max_output_size,I_iou_threshold],[],[],[O_selected_indices],['T','T_threshold'],['type','type'],[@A_T,@A_T_threshold])
  end;
function TGraphExt.AddNonMaxSuppressionV3(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const I_score_threshold:string; const O_selected_indices:string; const A_T:TF_DataType; const A_T_threshold:TF_DataType):string;
  begin
  result:=AddOper('NonMaxSuppressionV3',[I_boxes,I_scores,I_max_output_size,I_iou_threshold,I_score_threshold],[],[],[O_selected_indices],['T','T_threshold'],['type','type'],[@A_T,@A_T_threshold])
  end;
function TGraphExt.AddNonMaxSuppressionV4(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const I_score_threshold:string; const O_selected_indices:string; const O_valid_outputs:string; const A_T:TF_DataType; const A_T_threshold:TF_DataType; const A_pad_to_max_output_size:boolean):string;
  begin
  result:=AddOper('NonMaxSuppressionV4',[I_boxes,I_scores,I_max_output_size,I_iou_threshold,I_score_threshold],[],[],[O_selected_indices,O_valid_outputs],['T','T_threshold','pad_to_max_output_size'],['type','type','bool'],[@A_T,@A_T_threshold,@A_pad_to_max_output_size])
  end;
function TGraphExt.AddNonMaxSuppressionV5(const I_boxes:string; const I_scores:string; const I_max_output_size:string; const I_iou_threshold:string; const I_score_threshold:string; const I_soft_nms_sigma:string; const O_selected_indices:string; const O_selected_scores:string; const O_valid_outputs:string; const A_T:TF_DataType; const A_pad_to_max_output_size:boolean):string;
  begin
  result:=AddOper('NonMaxSuppressionV5',[I_boxes,I_scores,I_max_output_size,I_iou_threshold,I_score_threshold,I_soft_nms_sigma],[],[],[O_selected_indices,O_selected_scores,O_valid_outputs],['T','pad_to_max_output_size'],['type','bool'],[@A_T,@A_pad_to_max_output_size])
  end;
function TGraphExt.AddNonMaxSuppressionWithOverlaps(const I_overlaps:string; const I_scores:string; const I_max_output_size:string; const I_overlap_threshold:string; const I_score_threshold:string; const O_selected_indices:string):string;
  begin
  result:=AddOper('NonMaxSuppressionWithOverlaps',[I_overlaps,I_scores,I_max_output_size,I_overlap_threshold,I_score_threshold],[],[],[O_selected_indices],[],[],[])
  end;
function TGraphExt.AddNonSerializableDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('NonSerializableDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddNotEqual(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType; const A_incompatible_shape_error:boolean):string;
  begin
  result:=AddOper('NotEqual',[I_x,I_y],[],[],[O_z],['T','incompatible_shape_error'],['type','bool'],[@A_T,@A_incompatible_shape_error])
  end;
function TGraphExt.AddNthElement(const I_input:string; const I_n:string; const O_values:string; const A_reverse:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('NthElement',[I_input,I_n],[],[],[O_values],['reverse','T'],['bool','type'],[@A_reverse,@A_T])
  end;
function TGraphExt.AddOneHot(const I_indices:string; const I_depth:string; const I_on_value:string; const I_off_value:string; const O_output:string; const A_axis:cint64; const A_T:TF_DataType; const A_TI:TF_DataType):string;
  begin
  result:=AddOper('OneHot',[I_indices,I_depth,I_on_value,I_off_value],[],[],[O_output],['axis','T','TI'],['int','type','type'],[@A_axis,@A_T,@A_TI])
  end;
function TGraphExt.AddOneShotIterator(const O_handle:string; const A_dataset_factory:TF_Function; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OneShotIterator',[],[],[],[O_handle],['dataset_factory','output_types','output_shapes','container','shared_name'],['func','list(type)','list(shape)','string','string'],[@A_dataset_factory,@A_output_types,@A_output_shapes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOnesLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('OnesLike',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddOptimizeDataset(const I_input_dataset:string; const I_optimizations:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_optimization_configs:TF_StringList):string;
  begin
  result:=AddOper('OptimizeDataset',[I_input_dataset,I_optimizations],[],[],[O_handle],['output_types','output_shapes','optimization_configs'],['list(type)','list(shape)','list(string)'],[@A_output_types,@A_output_shapes,@A_optimization_configs])
  end;
function TGraphExt.AddOptionalFromValue(const IL_components:string; const O_optional:string; const A_Toutput_types:TF_TypeList):string;
  begin
  result:=AddOper('OptionalFromValue',[],[IL_components],[Length(A_Toutput_types)],[O_optional],['Toutput_types'],['list(type)'],[@A_Toutput_types])
  end;
function TGraphExt.AddOptionalGetValue(const I_optional:string; const OL_components:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('OptionalGetValue',[I_optional],[],[],[OL_components],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddOptionalHasValue(const I_optional:string; const O_has_value:string):string;
  begin
  result:=AddOper('OptionalHasValue',[I_optional],[],[],[O_has_value],[],[],[])
  end;
function TGraphExt.AddOptionalNone(const O_optional:string):string;
  begin
  result:=AddOper('OptionalNone',[],[],[],[O_optional],[],[],[])
  end;
function TGraphExt.AddOrderedMapClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapClear',[],[],[],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapIncompleteSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapIncompleteSize',[],[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapPeek(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapPeek',[I_key,I_indices],[],[],[OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapSize',[],[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapStage(const I_key:string; const I_indices:string; const IL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_fake_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapStage',[I_key,I_indices],[IL_values],[Length(A_fake_dtypes)],[],['capacity','memory_limit','dtypes','fake_dtypes','container','shared_name'],['int','int','list(type)','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_fake_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapUnstage(const I_key:string; const I_indices:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapUnstage',[I_key,I_indices],[],[],[OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOrderedMapUnstageNoKey(const I_indices:string; const O_key:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('OrderedMapUnstageNoKey',[I_indices],[],[],[O_key,OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddOutfeedDequeue(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_device_ordinal:cint64):string;
  begin
  result:=AddOper('OutfeedDequeue',[],[],[],[O_output],['dtype','shape','device_ordinal'],['type','shape','int'],[@A_dtype,@A_shape,@A_device_ordinal])
  end;
function TGraphExt.AddOutfeedDequeueTuple(const OL_outputs:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList; const A_device_ordinal:cint64):string;
  begin
  result:=AddOper('OutfeedDequeueTuple',[],[],[],[OL_outputs],['dtypes','shapes','device_ordinal'],['list(type)','list(shape)','int'],[@A_dtypes,@A_shapes,@A_device_ordinal])
  end;
function TGraphExt.AddOutfeedEnqueue(const I_input:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('OutfeedEnqueue',[I_input],[],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddOutfeedEnqueueTuple(const IL_inputs:string; const A_dtypes:TF_TypeList):string;
  begin
  result:=AddOper('OutfeedEnqueueTuple',[],[IL_inputs],[Length(A_dtypes)],[],['dtypes'],['list(type)'],[@A_dtypes])
  end;
function TGraphExt.AddPack(const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
  begin
  result:=AddOper('Pack',[],[IL_values],[A_N],[O_output],['N','T','axis'],['int','type','int'],[@A_N,@A_T,@A_axis])
  end;
function TGraphExt.AddPad(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
  begin
  result:=AddOper('Pad',[I_input,I_paddings],[],[],[O_output],['T','Tpaddings'],['type','type'],[@A_T,@A_Tpaddings])
  end;
function TGraphExt.AddPadV2(const I_input:string; const I_paddings:string; const I_constant_values:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType):string;
  begin
  result:=AddOper('PadV2',[I_input,I_paddings,I_constant_values],[],[],[O_output],['T','Tpaddings'],['type','type'],[@A_T,@A_Tpaddings])
  end;
function TGraphExt.AddPaddedBatchDataset(const I_input_dataset:string; const I_batch_size:string; const IL_padded_shapes:string; const IL_padding_values:string; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('PaddedBatchDataset',[I_input_dataset,I_batch_size],[IL_padded_shapes,IL_padding_values],[A_N,Length(A_Toutput_types)],[O_handle],['Toutput_types','output_shapes','N'],['list(type)','list(shape)','int'],[@A_Toutput_types,@A_output_shapes,@A_N])
  end;
function TGraphExt.AddPaddedBatchDatasetV2(const I_input_dataset:string; const I_batch_size:string; const I_drop_remainder:string; const IL_padded_shapes:string; const IL_padding_values:string; const O_handle:string; const A_parallel_copy:boolean; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('PaddedBatchDatasetV2',[I_input_dataset,I_batch_size,I_drop_remainder],[IL_padded_shapes,IL_padding_values],[A_N,Length(A_Toutput_types)],[O_handle],['parallel_copy','Toutput_types','output_shapes','N'],['bool','list(type)','list(shape)','int'],[@A_parallel_copy,@A_Toutput_types,@A_output_shapes,@A_N])
  end;
function TGraphExt.AddPaddingFIFOQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PaddingFIFOQueue',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddPaddingFIFOQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PaddingFIFOQueueV2',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddParallelConcat(const IL_values:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('ParallelConcat',[],[IL_values],[A_N],[O_output],['N','T','shape'],['int','type','shape'],[@A_N,@A_T,@A_shape])
  end;
function TGraphExt.AddParallelDynamicStitch(const IL_indices:string; const IL_data:string; const O_merged:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ParallelDynamicStitch',[],[IL_indices,IL_data],[A_N,A_N],[O_merged],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddParallelInterleaveDataset(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_sloppy:string; const I_buffer_output_elements:string; const I_prefetch_input_elements:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParallelInterleaveDataset',[I_input_dataset,I_cycle_length,I_block_length,I_sloppy,I_buffer_output_elements,I_prefetch_input_elements],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddParallelInterleaveDatasetV2(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_num_parallel_calls:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_sloppy:boolean):string;
  begin
  result:=AddOper('ParallelInterleaveDatasetV2',[I_input_dataset,I_cycle_length,I_block_length,I_num_parallel_calls],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes','sloppy'],['func','list(type)','list(type)','list(shape)','bool'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes,@A_sloppy])
  end;
function TGraphExt.AddParallelInterleaveDatasetV3(const I_input_dataset:string; const I_cycle_length:string; const I_block_length:string; const I_num_parallel_calls:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_deterministic:string; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParallelInterleaveDatasetV3',[I_input_dataset,I_cycle_length,I_block_length,I_num_parallel_calls],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','deterministic','Targuments','output_types','output_shapes'],['func','string','list(type)','list(type)','list(shape)'],[@A_f,@A_deterministic,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddParallelMapDataset(const I_input_dataset:string; const I_num_parallel_calls:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean; const A_sloppy:boolean; const A_preserve_cardinality:boolean):string;
  begin
  result:=AddOper('ParallelMapDataset',[I_input_dataset,I_num_parallel_calls],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['f','Targuments','output_types','output_shapes','use_inter_op_parallelism','sloppy','preserve_cardinality'],['func','list(type)','list(type)','list(shape)','bool','bool','bool'],[@A_f,@A_Targuments,@A_output_types,@A_output_shapes,@A_use_inter_op_parallelism,@A_sloppy,@A_preserve_cardinality])
  end;
function TGraphExt.AddParameterizedTruncatedNormal(const I_shape:string; const I_means:string; const I_stdevs:string; const I_minvals:string; const I_maxvals:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ParameterizedTruncatedNormal',[I_shape,I_means,I_stdevs,I_minvals,I_maxvals],[],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddParseExample(const I_serialized:string; const I_names:string; const IL_sparse_keys:string; const IL_dense_keys:string; const IL_dense_defaults:string; const OL_sparse_indices:string; const OL_sparse_values:string; const OL_sparse_shapes:string; const OL_dense_values:string; const A_Nsparse:cint64; const A_Ndense:cint64; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParseExample',[I_serialized,I_names],[IL_sparse_keys,IL_dense_keys,IL_dense_defaults],[A_Nsparse,A_Ndense,Length(A_Tdense)],[OL_sparse_indices,OL_sparse_values,OL_sparse_shapes,OL_dense_values],['Nsparse','Ndense','sparse_types','Tdense','dense_shapes'],['int','int','list(type)','list(type)','list(shape)'],[@A_Nsparse,@A_Ndense,@A_sparse_types,@A_Tdense,@A_dense_shapes])
  end;
function TGraphExt.AddParseExampleDataset(const I_input_dataset:string; const I_num_parallel_calls:string; const IL_dense_defaults:string; const O_handle:string; const A_sparse_keys:TF_StringList; const A_dense_keys:TF_StringList; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_sloppy:boolean; const A_ragged_keys:TF_StringList; const A_ragged_value_types:TF_TypeList; const A_ragged_split_types:TF_TypeList):string;
  begin
  result:=AddOper('ParseExampleDataset',[I_input_dataset,I_num_parallel_calls],[IL_dense_defaults],[Length(A_Tdense)],[O_handle],['sparse_keys','dense_keys','sparse_types','Tdense','dense_shapes','output_types','output_shapes','sloppy','ragged_keys','ragged_value_types','ragged_split_types'],['list(string)','list(string)','list(type)','list(type)','list(shape)','list(type)','list(shape)','bool','list(string)','list(type)','list(type)'],[@A_sparse_keys,@A_dense_keys,@A_sparse_types,@A_Tdense,@A_dense_shapes,@A_output_types,@A_output_shapes,@A_sloppy,@A_ragged_keys,@A_ragged_value_types,@A_ragged_split_types])
  end;
function TGraphExt.AddParseExampleV2(const I_serialized:string; const I_names:string; const I_sparse_keys:string; const I_dense_keys:string; const I_ragged_keys:string; const IL_dense_defaults:string; const OL_sparse_indices:string; const OL_sparse_values:string; const OL_sparse_shapes:string; const OL_dense_values:string; const OL_ragged_values:string; const OL_ragged_row_splits:string; const A_Tdense:TF_TypeList; const A_num_sparse:cint64; const A_sparse_types:TF_TypeList; const A_ragged_value_types:TF_TypeList; const A_ragged_split_types:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParseExampleV2',[I_serialized,I_names,I_sparse_keys,I_dense_keys,I_ragged_keys],[IL_dense_defaults],[Length(A_Tdense)],[OL_sparse_indices,OL_sparse_values,OL_sparse_shapes,OL_dense_values,OL_ragged_values,OL_ragged_row_splits],['Tdense','num_sparse','sparse_types','ragged_value_types','ragged_split_types','dense_shapes'],['list(type)','int','list(type)','list(type)','list(type)','list(shape)'],[@A_Tdense,@A_num_sparse,@A_sparse_types,@A_ragged_value_types,@A_ragged_split_types,@A_dense_shapes])
  end;
function TGraphExt.AddParseSequenceExample(const I_serialized:string; const I_debug_name:string; const IL_context_dense_defaults:string; const OL_context_sparse_indices:string; const OL_context_sparse_values:string; const OL_context_sparse_shapes:string; const OL_context_dense_values:string; const OL_feature_list_sparse_indices:string; const OL_feature_list_sparse_values:string; const OL_feature_list_sparse_shapes:string; const OL_feature_list_dense_values:string; const OL_feature_list_dense_lengths:string; const A_feature_list_dense_missing_assumed_empty:TF_StringList; const A_context_sparse_keys:TF_StringList; const A_context_dense_keys:TF_StringList; const A_feature_list_sparse_keys:TF_StringList; const A_feature_list_dense_keys:TF_StringList; const A_Ncontext_sparse:cint64; const A_Ncontext_dense:cint64; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_context_sparse_types:TF_TypeList; const A_Tcontext_dense:TF_TypeList; const A_feature_list_dense_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParseSequenceExample',[I_serialized,I_debug_name],[IL_context_dense_defaults],[Length(A_Tcontext_dense)],[OL_context_sparse_indices,OL_context_sparse_values,OL_context_sparse_shapes,OL_context_dense_values,OL_feature_list_sparse_indices,OL_feature_list_sparse_values,OL_feature_list_sparse_shapes,OL_feature_list_dense_values,OL_feature_list_dense_lengths],['feature_list_dense_missing_assumed_empty','context_sparse_keys','context_dense_keys','feature_list_sparse_keys','feature_list_dense_keys','Ncontext_sparse','Ncontext_dense','Nfeature_list_sparse','Nfeature_list_dense','context_sparse_types','Tcontext_dense','feature_list_dense_types','context_dense_shapes','feature_list_sparse_types','feature_list_dense_shapes'],['list(string)','list(string)','list(string)','list(string)','list(string)','int','int','int','int','list(type)','list(type)','list(type)','list(shape)','list(type)','list(shape)'],[@A_feature_list_dense_missing_assumed_empty,@A_context_sparse_keys,@A_context_dense_keys,@A_feature_list_sparse_keys,@A_feature_list_dense_keys,@A_Ncontext_sparse,@A_Ncontext_dense,@A_Nfeature_list_sparse,@A_Nfeature_list_dense,@A_context_sparse_types,@A_Tcontext_dense,@A_feature_list_dense_types,@A_context_dense_shapes,@A_feature_list_sparse_types,@A_feature_list_dense_shapes])
  end;
function TGraphExt.AddParseSequenceExampleV2(const I_serialized:string; const I_debug_name:string; const I_context_sparse_keys:string; const I_context_dense_keys:string; const I_context_ragged_keys:string; const I_feature_list_sparse_keys:string; const I_feature_list_dense_keys:string; const I_feature_list_ragged_keys:string; const I_feature_list_dense_missing_assumed_empty:string; const IL_context_dense_defaults:string; const OL_context_sparse_indices:string; const OL_context_sparse_values:string; const OL_context_sparse_shapes:string; const OL_context_dense_values:string; const OL_context_ragged_values:string; const OL_context_ragged_row_splits:string; const OL_feature_list_sparse_indices:string; const OL_feature_list_sparse_values:string; const OL_feature_list_sparse_shapes:string; const OL_feature_list_dense_values:string; const OL_feature_list_dense_lengths:string; const OL_feature_list_ragged_values:string; const OL_feature_list_ragged_outer_splits:string; const OL_feature_list_ragged_inner_splits:string; const A_Ncontext_sparse:cint64; const A_Tcontext_dense:TF_TypeList; const A_context_sparse_types:TF_TypeList; const A_context_ragged_value_types:TF_TypeList; const A_context_ragged_split_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_feature_list_dense_types:TF_TypeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_ragged_value_types:TF_TypeList; const A_feature_list_ragged_split_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParseSequenceExampleV2',[I_serialized,I_debug_name,I_context_sparse_keys,I_context_dense_keys,I_context_ragged_keys,I_feature_list_sparse_keys,I_feature_list_dense_keys,I_feature_list_ragged_keys,I_feature_list_dense_missing_assumed_empty],[IL_context_dense_defaults],[Length(A_Tcontext_dense)],[OL_context_sparse_indices,OL_context_sparse_values,OL_context_sparse_shapes,OL_context_dense_values,OL_context_ragged_values,OL_context_ragged_row_splits,OL_feature_list_sparse_indices,OL_feature_list_sparse_values,OL_feature_list_sparse_shapes,OL_feature_list_dense_values,OL_feature_list_dense_lengths,OL_feature_list_ragged_values,OL_feature_list_ragged_outer_splits,OL_feature_list_ragged_inner_splits],['Ncontext_sparse','Tcontext_dense','context_sparse_types','context_ragged_value_types','context_ragged_split_types','context_dense_shapes','Nfeature_list_sparse','Nfeature_list_dense','feature_list_dense_types','feature_list_sparse_types','feature_list_ragged_value_types','feature_list_ragged_split_types','feature_list_dense_shapes'],['int','list(type)','list(type)','list(type)','list(type)','list(shape)','int','int','list(type)','list(type)','list(type)','list(type)','list(shape)'],[@A_Ncontext_sparse,@A_Tcontext_dense,@A_context_sparse_types,@A_context_ragged_value_types,@A_context_ragged_split_types,@A_context_dense_shapes,@A_Nfeature_list_sparse,@A_Nfeature_list_dense,@A_feature_list_dense_types,@A_feature_list_sparse_types,@A_feature_list_ragged_value_types,@A_feature_list_ragged_split_types,@A_feature_list_dense_shapes])
  end;
function TGraphExt.AddParseSingleExample(const I_serialized:string; const IL_dense_defaults:string; const OL_sparse_indices:string; const OL_sparse_values:string; const OL_sparse_shapes:string; const OL_dense_values:string; const A_num_sparse:cint64; const A_sparse_keys:TF_StringList; const A_dense_keys:TF_StringList; const A_sparse_types:TF_TypeList; const A_Tdense:TF_TypeList; const A_dense_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParseSingleExample',[I_serialized],[IL_dense_defaults],[Length(A_Tdense)],[OL_sparse_indices,OL_sparse_values,OL_sparse_shapes,OL_dense_values],['num_sparse','sparse_keys','dense_keys','sparse_types','Tdense','dense_shapes'],['int','list(string)','list(string)','list(type)','list(type)','list(shape)'],[@A_num_sparse,@A_sparse_keys,@A_dense_keys,@A_sparse_types,@A_Tdense,@A_dense_shapes])
  end;
function TGraphExt.AddParseSingleSequenceExample(const I_serialized:string; const I_feature_list_dense_missing_assumed_empty:string; const I_debug_name:string; const IL_context_sparse_keys:string; const IL_context_dense_keys:string; const IL_feature_list_sparse_keys:string; const IL_feature_list_dense_keys:string; const IL_context_dense_defaults:string; const OL_context_sparse_indices:string; const OL_context_sparse_values:string; const OL_context_sparse_shapes:string; const OL_context_dense_values:string; const OL_feature_list_sparse_indices:string; const OL_feature_list_sparse_values:string; const OL_feature_list_sparse_shapes:string; const OL_feature_list_dense_values:string; const A_Ncontext_sparse:cint64; const A_Ncontext_dense:cint64; const A_Nfeature_list_sparse:cint64; const A_Nfeature_list_dense:cint64; const A_context_sparse_types:TF_TypeList; const A_Tcontext_dense:TF_TypeList; const A_feature_list_dense_types:TF_TypeList; const A_context_dense_shapes:TF_ShapeList; const A_feature_list_sparse_types:TF_TypeList; const A_feature_list_dense_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ParseSingleSequenceExample',[I_serialized,I_feature_list_dense_missing_assumed_empty,I_debug_name],[IL_context_sparse_keys,IL_context_dense_keys,IL_feature_list_sparse_keys,IL_feature_list_dense_keys,IL_context_dense_defaults],[A_Ncontext_sparse,A_Ncontext_dense,A_Nfeature_list_sparse,A_Nfeature_list_dense,Length(A_Tcontext_dense)],[OL_context_sparse_indices,OL_context_sparse_values,OL_context_sparse_shapes,OL_context_dense_values,OL_feature_list_sparse_indices,OL_feature_list_sparse_values,OL_feature_list_sparse_shapes,OL_feature_list_dense_values],['Ncontext_sparse','Ncontext_dense','Nfeature_list_sparse','Nfeature_list_dense','context_sparse_types','Tcontext_dense','feature_list_dense_types','context_dense_shapes','feature_list_sparse_types','feature_list_dense_shapes'],['int','int','int','int','list(type)','list(type)','list(type)','list(shape)','list(type)','list(shape)'],[@A_Ncontext_sparse,@A_Ncontext_dense,@A_Nfeature_list_sparse,@A_Nfeature_list_dense,@A_context_sparse_types,@A_Tcontext_dense,@A_feature_list_dense_types,@A_context_dense_shapes,@A_feature_list_sparse_types,@A_feature_list_dense_shapes])
  end;
function TGraphExt.AddParseTensor(const I_serialized:string; const O_output:string; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('ParseTensor',[I_serialized],[],[],[O_output],['out_type'],['type'],[@A_out_type])
  end;
function TGraphExt.AddPartitionedCall(const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function; const A_config:string; const A_config_proto:string; const A_executor_type:string):string;
  begin
  result:=AddOper('PartitionedCall',[],[IL_args],[Length(A_Tin)],[OL_output],['Tin','Tout','f','config','config_proto','executor_type'],['list(type)','list(type)','func','string','string','string'],[@A_Tin,@A_Tout,@A_f,@A_config,@A_config_proto,@A_executor_type])
  end;
function TGraphExt.AddPlaceholder(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('Placeholder',[],[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddPlaceholderV2(const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('PlaceholderV2',[],[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddPlaceholderWithDefault(const I_input:string; const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('PlaceholderWithDefault',[I_input],[],[],[O_output],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape])
  end;
function TGraphExt.AddPolygamma(const I_a:string; const I_x:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Polygamma',[I_a,I_x],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddPopulationCount(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('PopulationCount',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddPow(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Pow',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddPrefetchDataset(const I_input_dataset:string; const I_buffer_size:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_slack_period:cint64; const A_legacy_autotune:boolean):string;
  begin
  result:=AddOper('PrefetchDataset',[I_input_dataset,I_buffer_size],[],[],[O_handle],['output_types','output_shapes','slack_period','legacy_autotune'],['list(type)','list(shape)','int','bool'],[@A_output_types,@A_output_shapes,@A_slack_period,@A_legacy_autotune])
  end;
function TGraphExt.AddPrelinearize(const I_input:string; const O_output:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_layout:TF_IntList):string;
  begin
  result:=AddOper('Prelinearize',[I_input],[],[],[O_output],['dtype','shape','layout'],['type','shape','list(int)'],[@A_dtype,@A_shape,@A_layout])
  end;
function TGraphExt.AddPrelinearizeTuple(const IL_inputs:string; const O_output:string; const A_dtypes:TF_TypeList; const A_shapes:TF_ShapeList; const A_layouts:TF_IntList):string;
  begin
  result:=AddOper('PrelinearizeTuple',[],[IL_inputs],[Length(A_dtypes)],[O_output],['dtypes','shapes','layouts'],['list(type)','list(shape)','list(int)'],[@A_dtypes,@A_shapes,@A_layouts])
  end;
function TGraphExt.AddPreventGradient(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_message:string):string;
  begin
  result:=AddOper('PreventGradient',[I_input],[],[],[O_output],['T','message'],['type','string'],[@A_T,@A_message])
  end;
function TGraphExt.AddPrint(const I_input:string; const IL_data:string; const O_output:string; const A_T:TF_DataType; const A_U:TF_TypeList; const A_message:string; const A_first_n:cint64; const A_summarize:cint64):string;
  begin
  result:=AddOper('Print',[I_input],[IL_data],[Length(A_U)],[O_output],['T','U','message','first_n','summarize'],['type','list(type)','string','int','int'],[@A_T,@A_U,@A_message,@A_first_n,@A_summarize])
  end;
function TGraphExt.AddPrintV2(const I_input:string; const A_output_stream:string; const A_end:string):string;
  begin
  result:=AddOper('PrintV2',[I_input],[],[],[],['output_stream','end'],['string','string'],[@A_output_stream,@A_end])
  end;
function TGraphExt.AddPriorityQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PriorityQueue',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddPriorityQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('PriorityQueueV2',[],[],[],[O_handle],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name])
  end;
function TGraphExt.AddPrivateThreadPoolDataset(const I_input_dataset:string; const I_num_threads:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('PrivateThreadPoolDataset',[I_input_dataset,I_num_threads],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddProd(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Prod',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddPyFunc(const IL_input:string; const OL_output:string; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
  begin
  result:=AddOper('PyFunc',[],[IL_input],[Length(A_Tin)],[OL_output],['token','Tin','Tout'],['string','list(type)','list(type)'],[@A_token,@A_Tin,@A_Tout])
  end;
function TGraphExt.AddPyFuncStateless(const IL_input:string; const OL_output:string; const A_token:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList):string;
  begin
  result:=AddOper('PyFuncStateless',[],[IL_input],[Length(A_Tin)],[OL_output],['token','Tin','Tout'],['string','list(type)','list(type)'],[@A_token,@A_Tin,@A_Tout])
  end;
function TGraphExt.AddQr(const I_input:string; const O_q:string; const O_r:string; const A_full_matrices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Qr',[I_input],[],[],[O_q,O_r],['full_matrices','T'],['bool','type'],[@A_full_matrices,@A_T])
  end;
function TGraphExt.AddQuantizeAndDequantize(const I_input:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const A_T:TF_DataType):string;
  begin
  result:=AddOper('QuantizeAndDequantize',[I_input],[],[],[O_output],['signed_input','num_bits','range_given','input_min','input_max','T'],['bool','int','bool','float','float','type'],[@A_signed_input,@A_num_bits,@A_range_given,@A_input_min,@A_input_max,@A_T])
  end;
function TGraphExt.AddQuantizeAndDequantizeV2(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const A_signed_input:boolean; const A_num_bits:cint64; const A_range_given:boolean; const A_T:TF_DataType; const A_round_mode:string; const A_narrow_range:boolean; const A_axis:cint64):string;
  begin
  result:=AddOper('QuantizeAndDequantizeV2',[I_input,I_input_min,I_input_max],[],[],[O_output],['signed_input','num_bits','range_given','T','round_mode','narrow_range','axis'],['bool','int','bool','type','string','bool','int'],[@A_signed_input,@A_num_bits,@A_range_given,@A_T,@A_round_mode,@A_narrow_range,@A_axis])
  end;
function TGraphExt.AddQuantizeAndDequantizeV3(const I_input:string; const I_input_min:string; const I_input_max:string; const I_num_bits:string; const O_output:string; const A_signed_input:boolean; const A_range_given:boolean; const A_T:TF_DataType; const A_narrow_range:boolean; const A_axis:cint64):string;
  begin
  result:=AddOper('QuantizeAndDequantizeV3',[I_input,I_input_min,I_input_max,I_num_bits],[],[],[O_output],['signed_input','range_given','T','narrow_range','axis'],['bool','bool','type','bool','int'],[@A_signed_input,@A_range_given,@A_T,@A_narrow_range,@A_axis])
  end;
function TGraphExt.AddQuantizeDownAndShrinkRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizeDownAndShrinkRange',[I_input,I_input_min,I_input_max],[],[],[O_output,O_output_min,O_output_max],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizeV2(const I_input:string; const I_min_range:string; const I_max_range:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_mode:string; const A_round_mode:string; const A_narrow_range:boolean; const A_axis:cint64; const A_ensure_minimum_range:real):string;
  begin
  result:=AddOper('QuantizeV2',[I_input,I_min_range,I_max_range],[],[],[O_output,O_output_min,O_output_max],['T','mode','round_mode','narrow_range','axis','ensure_minimum_range'],['type','string','string','bool','int','float'],[@A_T,@A_mode,@A_round_mode,@A_narrow_range,@A_axis,@A_ensure_minimum_range])
  end;
function TGraphExt.AddQuantizedAdd(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
  begin
  result:=AddOper('QuantizedAdd',[I_x,I_y,I_min_x,I_max_x,I_min_y,I_max_y],[],[],[O_z,O_min_z,O_max_z],['T1','T2','Toutput'],['type','type','type'],[@A_T1,@A_T2,@A_Toutput])
  end;
function TGraphExt.AddQuantizedAvgPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('QuantizedAvgPool',[I_input,I_min_input,I_max_input],[],[],[O_output,O_min_output,O_max_output],['T','ksize','strides','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_ksize,@A_strides,@A_padding])
  end;
function TGraphExt.AddQuantizedBatchNormWithGlobalNormalization(const I_t:string; const I_t_min:string; const I_t_max:string; const I_m:string; const I_m_min:string; const I_m_max:string; const I_v:string; const I_v_min:string; const I_v_max:string; const I_beta:string; const I_beta_min:string; const I_beta_max:string; const I_gamma:string; const I_gamma_min:string; const I_gamma_max:string; const O_result:string; const O_result_min:string; const O_result_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType; const A_variance_epsilon:real; const A_scale_after_normalization:boolean):string;
  begin
  result:=AddOper('QuantizedBatchNormWithGlobalNormalization',[I_t,I_t_min,I_t_max,I_m,I_m_min,I_m_max,I_v,I_v_min,I_v_max,I_beta,I_beta_min,I_beta_max,I_gamma,I_gamma_min,I_gamma_max],[],[],[O_result,O_result_min,O_result_max],['Tinput','out_type','variance_epsilon','scale_after_normalization'],['type','type','float','bool'],[@A_Tinput,@A_out_type,@A_variance_epsilon,@A_scale_after_normalization])
  end;
function TGraphExt.AddQuantizedBiasAdd(const I_input:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_bias:string; const I_max_bias:string; const O_output:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedBiasAdd',[I_input,I_bias,I_min_input,I_max_input,I_min_bias,I_max_bias],[],[],[O_output,O_min_out,O_max_out],['T1','T2','out_type'],['type','type','type'],[@A_T1,@A_T2,@A_out_type])
  end;
function TGraphExt.AddQuantizedConcat(const I_concat_dim:string; const IL_values:string; const IL_input_mins:string; const IL_input_maxes:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('QuantizedConcat',[I_concat_dim],[IL_values,IL_input_mins,IL_input_maxes],[A_N,A_N,A_N],[O_output,O_output_min,O_output_max],['N','T'],['int','type'],[@A_N,@A_T])
  end;
function TGraphExt.AddQuantizedConv2D(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2D',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations'],['type','type','type','list(int)','string','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations])
  end;
function TGraphExt.AddQuantizedConv2DAndRelu(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DAndRelu',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DAndReluAndRequantize(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DAndReluAndRequantize',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DAndRequantize(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DAndRequantize',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DPerChannel(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DPerChannel',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations'],['type','type','type','list(int)','string','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations])
  end;
function TGraphExt.AddQuantizedConv2DWithBias(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBias',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DWithBiasAndRelu(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBiasAndRelu',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DWithBiasAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBiasAndReluAndRequantize',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','Tbias','out_type','strides','padding','dilations','padding_list'],['type','type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_Tbias,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DWithBiasAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBiasAndRequantize',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','Tbias','out_type','strides','padding','dilations','padding_list'],['type','type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_Tbias,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DWithBiasSignedSumAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const I_summand:string; const I_min_summand:string; const I_max_summand:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_Tsummand:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBiasSignedSumAndReluAndRequantize',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output,I_summand,I_min_summand,I_max_summand],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','Tbias','Tsummand','out_type','strides','padding','dilations','padding_list'],['type','type','type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_Tbias,@A_Tsummand,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DWithBiasSumAndRelu(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_summand:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBiasSumAndRelu',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter,I_summand],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedConv2DWithBiasSumAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const I_summand:string; const I_min_summand:string; const I_max_summand:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_Tsummand:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedConv2DWithBiasSumAndReluAndRequantize',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output,I_summand,I_min_summand,I_max_summand],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','Tbias','Tsummand','out_type','strides','padding','dilations','padding_list'],['type','type','type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_Tbias,@A_Tsummand,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedDepthwiseConv2D(const I_input:string; const I_filter:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('QuantizedDepthwiseConv2D',[I_input,I_filter,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations'],['type','type','type','list(int)','string','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations])
  end;
function TGraphExt.AddQuantizedDepthwiseConv2DWithBias(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList):string;
  begin
  result:=AddOper('QuantizedDepthwiseConv2DWithBias',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations'],['type','type','type','list(int)','string','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations])
  end;
function TGraphExt.AddQuantizedDepthwiseConv2DWithBiasAndRelu(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedDepthwiseConv2DWithBiasAndRelu',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','out_type','strides','padding','dilations','padding_list'],['type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedDepthwiseConv2DWithBiasAndReluAndRequantize(const I_input:string; const I_filter:string; const I_bias:string; const I_min_input:string; const I_max_input:string; const I_min_filter:string; const I_max_filter:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_Tinput:TF_DataType; const A_Tfilter:TF_DataType; const A_Tbias:TF_DataType; const A_out_type:TF_DataType; const A_strides:TF_IntList; const A_padding:string; const A_dilations:TF_IntList; const A_padding_list:TF_IntList):string;
  begin
  result:=AddOper('QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize',[I_input,I_filter,I_bias,I_min_input,I_max_input,I_min_filter,I_max_filter,I_min_freezed_output,I_max_freezed_output],[],[],[O_output,O_min_output,O_max_output],['Tinput','Tfilter','Tbias','out_type','strides','padding','dilations','padding_list'],['type','type','type','type','list(int)','string','list(int)','list(int)'],[@A_Tinput,@A_Tfilter,@A_Tbias,@A_out_type,@A_strides,@A_padding,@A_dilations,@A_padding_list])
  end;
function TGraphExt.AddQuantizedInstanceNorm(const I_x:string; const I_x_min:string; const I_x_max:string; const O_y:string; const O_y_min:string; const O_y_max:string; const A_T:TF_DataType; const A_output_range_given:boolean; const A_given_y_min:real; const A_given_y_max:real; const A_variance_epsilon:real; const A_min_separation:real):string;
  begin
  result:=AddOper('QuantizedInstanceNorm',[I_x,I_x_min,I_x_max],[],[],[O_y,O_y_min,O_y_max],['T','output_range_given','given_y_min','given_y_max','variance_epsilon','min_separation'],['type','bool','float','float','float','float'],[@A_T,@A_output_range_given,@A_given_y_min,@A_given_y_max,@A_variance_epsilon,@A_min_separation])
  end;
function TGraphExt.AddQuantizedMatMul(const I_a:string; const I_b:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_Tactivation:TF_DataType):string;
  begin
  result:=AddOper('QuantizedMatMul',[I_a,I_b,I_min_a,I_max_a,I_min_b,I_max_b],[],[],[O_out,O_min_out,O_max_out],['T1','T2','Toutput','transpose_a','transpose_b','Tactivation'],['type','type','type','bool','bool','type'],[@A_T1,@A_T2,@A_Toutput,@A_transpose_a,@A_transpose_b,@A_Tactivation])
  end;
function TGraphExt.AddQuantizedMatMulWithBias(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Tbias:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
  begin
  result:=AddOper('QuantizedMatMulWithBias',[I_a,I_b,I_bias,I_min_a,I_max_a,I_min_b,I_max_b],[],[],[O_out,O_min_out,O_max_out],['T1','T2','Tbias','Toutput','transpose_a','transpose_b','input_quant_mode'],['type','type','type','type','bool','bool','string'],[@A_T1,@A_T2,@A_Tbias,@A_Toutput,@A_transpose_a,@A_transpose_b,@A_input_quant_mode])
  end;
function TGraphExt.AddQuantizedMatMulWithBiasAndRelu(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
  begin
  result:=AddOper('QuantizedMatMulWithBiasAndRelu',[I_a,I_b,I_bias,I_min_a,I_max_a,I_min_b,I_max_b],[],[],[O_out,O_min_out,O_max_out],['T1','T2','Toutput','transpose_a','transpose_b','input_quant_mode'],['type','type','type','bool','bool','string'],[@A_T1,@A_T2,@A_Toutput,@A_transpose_a,@A_transpose_b,@A_input_quant_mode])
  end;
function TGraphExt.AddQuantizedMatMulWithBiasAndReluAndRequantize(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Tbias:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
  begin
  result:=AddOper('QuantizedMatMulWithBiasAndReluAndRequantize',[I_a,I_b,I_bias,I_min_a,I_max_a,I_min_b,I_max_b,I_min_freezed_output,I_max_freezed_output],[],[],[O_out,O_min_out,O_max_out],['T1','T2','Tbias','Toutput','transpose_a','transpose_b','input_quant_mode'],['type','type','type','type','bool','bool','string'],[@A_T1,@A_T2,@A_Tbias,@A_Toutput,@A_transpose_a,@A_transpose_b,@A_input_quant_mode])
  end;
function TGraphExt.AddQuantizedMatMulWithBiasAndRequantize(const I_a:string; const I_b:string; const I_bias:string; const I_min_a:string; const I_max_a:string; const I_min_b:string; const I_max_b:string; const I_min_freezed_output:string; const I_max_freezed_output:string; const O_out:string; const O_min_out:string; const O_max_out:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Tbias:TF_DataType; const A_Toutput:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_input_quant_mode:string):string;
  begin
  result:=AddOper('QuantizedMatMulWithBiasAndRequantize',[I_a,I_b,I_bias,I_min_a,I_max_a,I_min_b,I_max_b,I_min_freezed_output,I_max_freezed_output],[],[],[O_out,O_min_out,O_max_out],['T1','T2','Tbias','Toutput','transpose_a','transpose_b','input_quant_mode'],['type','type','type','type','bool','bool','string'],[@A_T1,@A_T2,@A_Tbias,@A_Toutput,@A_transpose_a,@A_transpose_b,@A_input_quant_mode])
  end;
function TGraphExt.AddQuantizedMaxPool(const I_input:string; const I_min_input:string; const I_max_input:string; const O_output:string; const O_min_output:string; const O_max_output:string; const A_T:TF_DataType; const A_ksize:TF_IntList; const A_strides:TF_IntList; const A_padding:string):string;
  begin
  result:=AddOper('QuantizedMaxPool',[I_input,I_min_input,I_max_input],[],[],[O_output,O_min_output,O_max_output],['T','ksize','strides','padding'],['type','list(int)','list(int)','string'],[@A_T,@A_ksize,@A_strides,@A_padding])
  end;
function TGraphExt.AddQuantizedMul(const I_x:string; const I_y:string; const I_min_x:string; const I_max_x:string; const I_min_y:string; const I_max_y:string; const O_z:string; const O_min_z:string; const O_max_z:string; const A_T1:TF_DataType; const A_T2:TF_DataType; const A_Toutput:TF_DataType):string;
  begin
  result:=AddOper('QuantizedMul',[I_x,I_y,I_min_x,I_max_x,I_min_y,I_max_y],[],[],[O_z,O_min_z,O_max_z],['T1','T2','Toutput'],['type','type','type'],[@A_T1,@A_T2,@A_Toutput])
  end;
function TGraphExt.AddQuantizedRelu(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedRelu',[I_features,I_min_features,I_max_features],[],[],[O_activations,O_min_activations,O_max_activations],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizedRelu6(const I_features:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedRelu6',[I_features,I_min_features,I_max_features],[],[],[O_activations,O_min_activations,O_max_activations],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizedReluX(const I_features:string; const I_max_value:string; const I_min_features:string; const I_max_features:string; const O_activations:string; const O_min_activations:string; const O_max_activations:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('QuantizedReluX',[I_features,I_max_value,I_min_features,I_max_features],[],[],[O_activations,O_min_activations,O_max_activations],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddQuantizedReshape(const I_tensor:string; const I_shape:string; const I_input_min:string; const I_input_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
  begin
  result:=AddOper('QuantizedReshape',[I_tensor,I_shape,I_input_min,I_input_max],[],[],[O_output,O_output_min,O_output_max],['T','Tshape'],['type','type'],[@A_T,@A_Tshape])
  end;
function TGraphExt.AddQuantizedResizeBilinear(const I_images:string; const I_size:string; const I_min:string; const I_max:string; const O_resized_images:string; const O_out_min:string; const O_out_max:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('QuantizedResizeBilinear',[I_images,I_size,I_min,I_max],[],[],[O_resized_images,O_out_min,O_out_max],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddQueueClose(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
  begin
  result:=AddOper('QueueClose',[I_handle],[],[],[],['cancel_pending_enqueues'],['bool'],[@A_cancel_pending_enqueues])
  end;
function TGraphExt.AddQueueCloseV2(const I_handle:string; const A_cancel_pending_enqueues:boolean):string;
  begin
  result:=AddOper('QueueCloseV2',[I_handle],[],[],[],['cancel_pending_enqueues'],['bool'],[@A_cancel_pending_enqueues])
  end;
function TGraphExt.AddQueueDequeue(const I_handle:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeue',[I_handle],[],[],[OL_components],['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueMany(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueMany',[I_handle,I_n],[],[],[OL_components],['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueManyV2(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueManyV2',[I_handle,I_n],[],[],[OL_components],['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueUpTo(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueUpTo',[I_handle,I_n],[],[],[OL_components],['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueUpToV2(const I_handle:string; const I_n:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueUpToV2',[I_handle,I_n],[],[],[OL_components],['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueDequeueV2(const I_handle:string; const OL_components:string; const A_component_types:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueDequeueV2',[I_handle],[],[],[OL_components],['component_types','timeout_ms'],['list(type)','int'],[@A_component_types,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueue(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueue',[I_handle],[IL_components],[Length(A_Tcomponents)],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueueMany(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueueMany',[I_handle],[IL_components],[Length(A_Tcomponents)],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueueManyV2(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueueManyV2',[I_handle],[IL_components],[Length(A_Tcomponents)],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueEnqueueV2(const I_handle:string; const IL_components:string; const A_Tcomponents:TF_TypeList; const A_timeout_ms:cint64):string;
  begin
  result:=AddOper('QueueEnqueueV2',[I_handle],[IL_components],[Length(A_Tcomponents)],[],['Tcomponents','timeout_ms'],['list(type)','int'],[@A_Tcomponents,@A_timeout_ms])
  end;
function TGraphExt.AddQueueIsClosed(const I_handle:string; const O_is_closed:string):string;
  begin
  result:=AddOper('QueueIsClosed',[I_handle],[],[],[O_is_closed],[],[],[])
  end;
function TGraphExt.AddQueueIsClosedV2(const I_handle:string; const O_is_closed:string):string;
  begin
  result:=AddOper('QueueIsClosedV2',[I_handle],[],[],[O_is_closed],[],[],[])
  end;
function TGraphExt.AddQueueSize(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('QueueSize',[I_handle],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddQueueSizeV2(const I_handle:string; const O_size:string):string;
  begin
  result:=AddOper('QueueSizeV2',[I_handle],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddRFFT(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('RFFT',[I_input,I_fft_length],[],[],[O_output],['Treal','Tcomplex'],['type','type'],[@A_Treal,@A_Tcomplex])
  end;
function TGraphExt.AddRFFT2D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('RFFT2D',[I_input,I_fft_length],[],[],[O_output],['Treal','Tcomplex'],['type','type'],[@A_Treal,@A_Tcomplex])
  end;
function TGraphExt.AddRFFT3D(const I_input:string; const I_fft_length:string; const O_output:string; const A_Treal:TF_DataType; const A_Tcomplex:TF_DataType):string;
  begin
  result:=AddOper('RFFT3D',[I_input,I_fft_length],[],[],[O_output],['Treal','Tcomplex'],['type','type'],[@A_Treal,@A_Tcomplex])
  end;
function TGraphExt.AddRGBToHSV(const I_images:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RGBToHSV',[I_images],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRaggedGather(const I_params_dense_values:string; const I_indices:string; const IL_params_nested_splits:string; const O_output_dense_values:string; const OL_output_nested_splits:string; const A_Tvalues:TF_DataType; const A_Tindices:TF_DataType; const A_Tsplits:TF_DataType; const A_PARAMS_RAGGED_RANK:cint64; const A_OUTPUT_RAGGED_RANK:cint64):string;
  begin
  result:=AddOper('RaggedGather',[I_params_dense_values,I_indices],[IL_params_nested_splits],[A_PARAMS_RAGGED_RANK],[O_output_dense_values,OL_output_nested_splits],['Tvalues','Tindices','Tsplits','PARAMS_RAGGED_RANK','OUTPUT_RAGGED_RANK'],['type','type','type','int','int'],[@A_Tvalues,@A_Tindices,@A_Tsplits,@A_PARAMS_RAGGED_RANK,@A_OUTPUT_RAGGED_RANK])
  end;
function TGraphExt.AddRaggedRange(const I_starts:string; const I_limits:string; const I_deltas:string; const O_rt_nested_splits:string; const O_rt_dense_values:string; const A_T:TF_DataType; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('RaggedRange',[I_starts,I_limits,I_deltas],[],[],[O_rt_nested_splits,O_rt_dense_values],['T','Tsplits'],['type','type'],[@A_T,@A_Tsplits])
  end;
function TGraphExt.AddRaggedTensorFromVariant(const I_encoded_ragged:string; const O_output_dense_values:string; const OL_output_nested_splits:string; const A_input_ragged_rank:cint64; const A_output_ragged_rank:cint64; const A_Tvalues:TF_DataType; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('RaggedTensorFromVariant',[I_encoded_ragged],[],[],[O_output_dense_values,OL_output_nested_splits],['input_ragged_rank','output_ragged_rank','Tvalues','Tsplits'],['int','int','type','type'],[@A_input_ragged_rank,@A_output_ragged_rank,@A_Tvalues,@A_Tsplits])
  end;
function TGraphExt.AddRaggedTensorToSparse(const I_rt_dense_values:string; const IL_rt_nested_splits:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_dense_shape:string; const A_RAGGED_RANK:cint64; const A_T:TF_DataType; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('RaggedTensorToSparse',[I_rt_dense_values],[IL_rt_nested_splits],[A_RAGGED_RANK],[O_sparse_indices,O_sparse_values,O_sparse_dense_shape],['RAGGED_RANK','T','Tsplits'],['int','type','type'],[@A_RAGGED_RANK,@A_T,@A_Tsplits])
  end;
function TGraphExt.AddRaggedTensorToTensor(const I_shape:string; const I_values:string; const I_default_value:string; const IL_row_partition_tensors:string; const O_result:string; const A_T:TF_DataType; const A_Tindex:TF_DataType; const A_Tshape:TF_DataType; const A_num_row_partition_tensors:cint64; const A_row_partition_types:TF_StringList):string;
  begin
  result:=AddOper('RaggedTensorToTensor',[I_shape,I_values,I_default_value],[IL_row_partition_tensors],[A_num_row_partition_tensors],[O_result],['T','Tindex','Tshape','num_row_partition_tensors','row_partition_types'],['type','type','type','int','list(string)'],[@A_T,@A_Tindex,@A_Tshape,@A_num_row_partition_tensors,@A_row_partition_types])
  end;
function TGraphExt.AddRaggedTensorToVariant(const I_rt_dense_values:string; const IL_rt_nested_splits:string; const O_encoded_ragged:string; const A_RAGGED_RANK:cint64; const A_Tvalues:TF_DataType; const A_Tsplits:TF_DataType; const A_batched_input:boolean):string;
  begin
  result:=AddOper('RaggedTensorToVariant',[I_rt_dense_values],[IL_rt_nested_splits],[A_RAGGED_RANK],[O_encoded_ragged],['RAGGED_RANK','Tvalues','Tsplits','batched_input'],['int','type','type','bool'],[@A_RAGGED_RANK,@A_Tvalues,@A_Tsplits,@A_batched_input])
  end;
function TGraphExt.AddRandomCrop(const I_image:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('RandomCrop',[I_image,I_size],[],[],[O_output],['T','seed','seed2'],['type','int','int'],[@A_T,@A_seed,@A_seed2])
  end;
function TGraphExt.AddRandomDataset(const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('RandomDataset',[I_seed,I_seed2],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddRandomGamma(const I_shape:string; const I_alpha:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomGamma',[I_shape,I_alpha],[],[],[O_output],['seed','seed2','S','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_S,@A_T])
  end;
function TGraphExt.AddRandomGammaGrad(const I_alpha:string; const I_sample:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomGammaGrad',[I_alpha,I_sample],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRandomPoisson(const I_shape:string; const I_rate:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('RandomPoisson',[I_shape,I_rate],[],[],[O_output],['seed','seed2','S','dtype'],['int','int','type','type'],[@A_seed,@A_seed2,@A_S,@A_dtype])
  end;
function TGraphExt.AddRandomPoissonV2(const I_shape:string; const I_rate:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_S:TF_DataType; const A_R:TF_DataType; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('RandomPoissonV2',[I_shape,I_rate],[],[],[O_output],['seed','seed2','S','R','dtype'],['int','int','type','type','type'],[@A_seed,@A_seed2,@A_S,@A_R,@A_dtype])
  end;
function TGraphExt.AddRandomShuffle(const I_value:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomShuffle',[I_value],[],[],[O_output],['seed','seed2','T'],['int','int','type'],[@A_seed,@A_seed2,@A_T])
  end;
function TGraphExt.AddRandomShuffleQueue(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('RandomShuffleQueue',[],[],[],[O_handle],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name])
  end;
function TGraphExt.AddRandomShuffleQueueV2(const O_handle:string; const A_component_types:TF_TypeList; const A_shapes:TF_ShapeList; const A_capacity:cint64; const A_min_after_dequeue:cint64; const A_seed:cint64; const A_seed2:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('RandomShuffleQueueV2',[],[],[],[O_handle],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name])
  end;
function TGraphExt.AddRandomStandardNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomStandardNormal',[I_shape],[],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddRandomUniform(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomUniform',[I_shape],[],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddRandomUniformInt(const I_shape:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_Tout:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RandomUniformInt',[I_shape,I_minval,I_maxval],[],[],[O_output],['seed','seed2','Tout','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_Tout,@A_T])
  end;
function TGraphExt.AddRange(const I_start:string; const I_limit:string; const I_delta:string; const O_output:string; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Range',[I_start,I_limit,I_delta],[],[],[O_output],['Tidx'],['type'],[@A_Tidx])
  end;
function TGraphExt.AddRangeDataset(const I_start:string; const I_stop:string; const I_step:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('RangeDataset',[I_start,I_stop,I_step],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddRank(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Rank',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReadFile(const I_filename:string; const O_contents:string):string;
  begin
  result:=AddOper('ReadFile',[I_filename],[],[],[O_contents],[],[],[])
  end;
function TGraphExt.AddReadVariableOp(const I_resource:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('ReadVariableOp',[I_resource],[],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddReaderNumRecordsProduced(const I_reader_handle:string; const O_records_produced:string):string;
  begin
  result:=AddOper('ReaderNumRecordsProduced',[I_reader_handle],[],[],[O_records_produced],[],[],[])
  end;
function TGraphExt.AddReaderNumRecordsProducedV2(const I_reader_handle:string; const O_records_produced:string):string;
  begin
  result:=AddOper('ReaderNumRecordsProducedV2',[I_reader_handle],[],[],[O_records_produced],[],[],[])
  end;
function TGraphExt.AddReaderNumWorkUnitsCompleted(const I_reader_handle:string; const O_units_completed:string):string;
  begin
  result:=AddOper('ReaderNumWorkUnitsCompleted',[I_reader_handle],[],[],[O_units_completed],[],[],[])
  end;
function TGraphExt.AddReaderNumWorkUnitsCompletedV2(const I_reader_handle:string; const O_units_completed:string):string;
  begin
  result:=AddOper('ReaderNumWorkUnitsCompletedV2',[I_reader_handle],[],[],[O_units_completed],[],[],[])
  end;
function TGraphExt.AddReaderRead(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
  begin
  result:=AddOper('ReaderRead',[I_reader_handle,I_queue_handle],[],[],[O_key,O_value],[],[],[])
  end;
function TGraphExt.AddReaderReadUpTo(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
  begin
  result:=AddOper('ReaderReadUpTo',[I_reader_handle,I_queue_handle,I_num_records],[],[],[O_keys,O_values],[],[],[])
  end;
function TGraphExt.AddReaderReadUpToV2(const I_reader_handle:string; const I_queue_handle:string; const I_num_records:string; const O_keys:string; const O_values:string):string;
  begin
  result:=AddOper('ReaderReadUpToV2',[I_reader_handle,I_queue_handle,I_num_records],[],[],[O_keys,O_values],[],[],[])
  end;
function TGraphExt.AddReaderReadV2(const I_reader_handle:string; const I_queue_handle:string; const O_key:string; const O_value:string):string;
  begin
  result:=AddOper('ReaderReadV2',[I_reader_handle,I_queue_handle],[],[],[O_key,O_value],[],[],[])
  end;
function TGraphExt.AddReaderReset(const I_reader_handle:string):string;
  begin
  result:=AddOper('ReaderReset',[I_reader_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddReaderResetV2(const I_reader_handle:string):string;
  begin
  result:=AddOper('ReaderResetV2',[I_reader_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddReaderRestoreState(const I_reader_handle:string; const I_state:string):string;
  begin
  result:=AddOper('ReaderRestoreState',[I_reader_handle,I_state],[],[],[],[],[],[])
  end;
function TGraphExt.AddReaderRestoreStateV2(const I_reader_handle:string; const I_state:string):string;
  begin
  result:=AddOper('ReaderRestoreStateV2',[I_reader_handle,I_state],[],[],[],[],[],[])
  end;
function TGraphExt.AddReaderSerializeState(const I_reader_handle:string; const O_state:string):string;
  begin
  result:=AddOper('ReaderSerializeState',[I_reader_handle],[],[],[O_state],[],[],[])
  end;
function TGraphExt.AddReaderSerializeStateV2(const I_reader_handle:string; const O_state:string):string;
  begin
  result:=AddOper('ReaderSerializeStateV2',[I_reader_handle],[],[],[O_state],[],[],[])
  end;
function TGraphExt.AddReal(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_Tout:TF_DataType):string;
  begin
  result:=AddOper('Real',[I_input],[],[],[O_output],['T','Tout'],['type','type'],[@A_T,@A_Tout])
  end;
function TGraphExt.AddRealDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RealDiv',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRebatchDataset(const I_input_dataset:string; const I_num_replicas:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_fallback:boolean):string;
  begin
  result:=AddOper('RebatchDataset',[I_input_dataset,I_num_replicas],[],[],[O_handle],['output_types','output_shapes','use_fallback'],['list(type)','list(shape)','bool'],[@A_output_types,@A_output_shapes,@A_use_fallback])
  end;
function TGraphExt.AddReciprocal(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Reciprocal',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReciprocalGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ReciprocalGrad',[I_y,I_dy],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRecordInput(const O_records:string; const A_file_pattern:string; const A_file_random_seed:cint64; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:cint64; const A_file_parallelism:cint64; const A_batch_size:cint64; const A_compression_type:string):string;
  begin
  result:=AddOper('RecordInput',[],[],[],[O_records],['file_pattern','file_random_seed','file_shuffle_shift_ratio','file_buffer_size','file_parallelism','batch_size','compression_type'],['string','int','float','int','int','int','string'],[@A_file_pattern,@A_file_random_seed,@A_file_shuffle_shift_ratio,@A_file_buffer_size,@A_file_parallelism,@A_batch_size,@A_compression_type])
  end;
function TGraphExt.AddRecv(const O_tensor:string; const A_tensor_type:TF_DataType; const A_tensor_name:string; const A_send_device:string; const A_send_device_incarnation:cint64; const A_recv_device:string; const A_client_terminated:boolean):string;
  begin
  result:=AddOper('Recv',[],[],[],[O_tensor],['tensor_type','tensor_name','send_device','send_device_incarnation','recv_device','client_terminated'],['type','string','string','int','string','bool'],[@A_tensor_type,@A_tensor_name,@A_send_device,@A_send_device_incarnation,@A_recv_device,@A_client_terminated])
  end;
function TGraphExt.AddRecvTPUEmbeddingActivations(const OL_outputs:string; const A_num_outputs:cint64; const A_config:string):string;
  begin
  result:=AddOper('RecvTPUEmbeddingActivations',[],[],[],[OL_outputs],['num_outputs','config'],['int','string'],[@A_num_outputs,@A_config])
  end;
function TGraphExt.AddReduceDataset(const I_input_dataset:string; const IL_initial_state:string; const IL_other_arguments:string; const OL_components:string; const A_f:TF_Function; const A_Tstate:TF_TypeList; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_use_inter_op_parallelism:boolean):string;
  begin
  result:=AddOper('ReduceDataset',[I_input_dataset],[IL_initial_state,IL_other_arguments],[Length(A_Tstate),Length(A_Targuments)],[OL_components],['f','Tstate','Targuments','output_types','output_shapes','use_inter_op_parallelism'],['func','list(type)','list(type)','list(type)','list(shape)','bool'],[@A_f,@A_Tstate,@A_Targuments,@A_output_types,@A_output_shapes,@A_use_inter_op_parallelism])
  end;
function TGraphExt.AddReduceJoin(const I_inputs:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_separator:string):string;
  begin
  result:=AddOper('ReduceJoin',[I_inputs,I_reduction_indices],[],[],[O_output],['keep_dims','separator'],['bool','string'],[@A_keep_dims,@A_separator])
  end;
function TGraphExt.AddRefEnter(const I_data:string; const O_output:string; const A_T:TF_DataType; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:cint64):string;
  begin
  result:=AddOper('RefEnter',[I_data],[],[],[O_output],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@A_T,@A_frame_name,@A_is_constant,@A_parallel_iterations])
  end;
function TGraphExt.AddRefExit(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefExit',[I_data],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRefIdentity(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefIdentity',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRefMerge(const IL_inputs:string; const O_output:string; const O_value_index:string; const A_T:TF_DataType; const A_N:cint64):string;
  begin
  result:=AddOper('RefMerge',[],[IL_inputs],[A_N],[O_output,O_value_index],['T','N'],['type','int'],[@A_T,@A_N])
  end;
function TGraphExt.AddRefNextIteration(const I_data:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefNextIteration',[I_data],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRefSelect(const I_index:string; const IL_inputs:string; const O_output:string; const A_T:TF_DataType; const A_N:cint64):string;
  begin
  result:=AddOper('RefSelect',[I_index],[IL_inputs],[A_N],[O_output],['T','N'],['type','int'],[@A_T,@A_N])
  end;
function TGraphExt.AddRefSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RefSwitch',[I_data,I_pred],[],[],[O_output_false,O_output_true],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRegexFullMatch(const I_input:string; const I_pattern:string; const O_output:string):string;
  begin
  result:=AddOper('RegexFullMatch',[I_input,I_pattern],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddRegexReplace(const I_input:string; const I_pattern:string; const I_rewrite:string; const O_output:string; const A_replace_global:boolean):string;
  begin
  result:=AddOper('RegexReplace',[I_input,I_pattern,I_rewrite],[],[],[O_output],['replace_global'],['bool'],[@A_replace_global])
  end;
function TGraphExt.AddRelu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Relu',[I_features],[],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRelu6(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Relu6',[I_features],[],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRelu6Grad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Relu6Grad',[I_gradients,I_features],[],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReluGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ReluGrad',[I_gradients,I_features],[],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRemoteCall(const I_target:string; const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function):string;
  begin
  result:=AddOper('RemoteCall',[I_target],[IL_args],[Length(A_Tin)],[OL_output],['Tin','Tout','f'],['list(type)','list(type)','func'],[@A_Tin,@A_Tout,@A_f])
  end;
function TGraphExt.AddRemoteFusedGraphExecute(const IL_inputs:string; const OL_outputs:string; const A_Tinputs:TF_TypeList; const A_Toutputs:TF_TypeList; const A_serialized_remote_fused_graph_execute_info:string):string;
  begin
  result:=AddOper('RemoteFusedGraphExecute',[],[IL_inputs],[Length(A_Tinputs)],[OL_outputs],['Tinputs','Toutputs','serialized_remote_fused_graph_execute_info'],['list(type)','list(type)','string'],[@A_Tinputs,@A_Toutputs,@A_serialized_remote_fused_graph_execute_info])
  end;
function TGraphExt.AddRepeatDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('RepeatDataset',[I_input_dataset,I_count],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddRequantizationRange(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType):string;
  begin
  result:=AddOper('RequantizationRange',[I_input,I_input_min,I_input_max],[],[],[O_output_min,O_output_max],['Tinput'],['type'],[@A_Tinput])
  end;
function TGraphExt.AddRequantizationRangePerChannel(const I_input:string; const I_input_min:string; const I_input_max:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_clip_value_max:real):string;
  begin
  result:=AddOper('RequantizationRangePerChannel',[I_input,I_input_min,I_input_max],[],[],[O_output_min,O_output_max],['T','clip_value_max'],['type','float'],[@A_T,@A_clip_value_max])
  end;
function TGraphExt.AddRequantize(const I_input:string; const I_input_min:string; const I_input_max:string; const I_requested_output_min:string; const I_requested_output_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_Tinput:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('Requantize',[I_input,I_input_min,I_input_max,I_requested_output_min,I_requested_output_max],[],[],[O_output,O_output_min,O_output_max],['Tinput','out_type'],['type','type'],[@A_Tinput,@A_out_type])
  end;
function TGraphExt.AddRequantizePerChannel(const I_input:string; const I_input_min:string; const I_input_max:string; const I_requested_output_min:string; const I_requested_output_max:string; const O_output:string; const O_output_min:string; const O_output_max:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('RequantizePerChannel',[I_input,I_input_min,I_input_max,I_requested_output_min,I_requested_output_max],[],[],[O_output,O_output_min,O_output_max],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddReshape(const I_tensor:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tshape:TF_DataType):string;
  begin
  result:=AddOper('Reshape',[I_tensor,I_shape],[],[],[O_output],['T','Tshape'],['type','type'],[@A_T,@A_Tshape])
  end;
function TGraphExt.AddResizeArea(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean):string;
  begin
  result:=AddOper('ResizeArea',[I_images,I_size],[],[],[O_resized_images],['T','align_corners'],['type','bool'],[@A_T,@A_align_corners])
  end;
function TGraphExt.AddResizeBicubic(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('ResizeBicubic',[I_images,I_size],[],[],[O_resized_images],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddResizeBicubicGrad(const I_grads:string; const I_original_image:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('ResizeBicubicGrad',[I_grads,I_original_image],[],[],[O_output],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddResizeBilinear(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('ResizeBilinear',[I_images,I_size],[],[],[O_resized_images],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddResizeBilinearGrad(const I_grads:string; const I_original_image:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('ResizeBilinearGrad',[I_grads,I_original_image],[],[],[O_output],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddResizeNearestNeighbor(const I_images:string; const I_size:string; const O_resized_images:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('ResizeNearestNeighbor',[I_images,I_size],[],[],[O_resized_images],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddResizeNearestNeighborGrad(const I_grads:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_align_corners:boolean; const A_half_pixel_centers:boolean):string;
  begin
  result:=AddOper('ResizeNearestNeighborGrad',[I_grads,I_size],[],[],[O_output],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@A_T,@A_align_corners,@A_half_pixel_centers])
  end;
function TGraphExt.AddResourceAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('ResourceAccumulatorApplyGradient',[I_handle,I_local_step,I_gradient],[],[],[],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddResourceAccumulatorNumAccumulated(const I_handle:string; const O_num_accumulated:string):string;
  begin
  result:=AddOper('ResourceAccumulatorNumAccumulated',[I_handle],[],[],[O_num_accumulated],[],[],[])
  end;
function TGraphExt.AddResourceAccumulatorSetGlobalStep(const I_handle:string; const I_new_global_step:string):string;
  begin
  result:=AddOper('ResourceAccumulatorSetGlobalStep',[I_handle,I_new_global_step],[],[],[],[],[],[])
  end;
function TGraphExt.AddResourceAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_average:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('ResourceAccumulatorTakeGradient',[I_handle,I_num_required],[],[],[O_average],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddResourceApplyAdaMax(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdaMax',[I_var,I_m,I_v,I_beta1_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdagrad',[I_var,I_accum,I_lr,I_grad],[],[],[],['T','use_locking','update_slots'],['type','bool','bool'],[@A_T,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddResourceApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_lr,I_l1,I_l2,I_global_step],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdagradV2',[I_var,I_accum,I_lr,I_epsilon,I_grad],[],[],[],['T','use_locking','update_slots'],['type','bool','bool'],[@A_T,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddResourceApplyAdam(const I_var:string; const I_m:string; const I_v:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdam',[I_var,I_m,I_v,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[],[],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceApplyAdamWithAmsgrad(const I_var:string; const I_m:string; const I_v:string; const I_vhat:string; const I_beta1_power:string; const I_beta2_power:string; const I_lr:string; const I_beta1:string; const I_beta2:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAdamWithAmsgrad',[I_var,I_m,I_v,I_vhat,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyAddSign(const I_var:string; const I_m:string; const I_lr:string; const I_alpha:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyAddSign',[I_var,I_m,I_lr,I_alpha,I_sign_decay,I_beta,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_lr_power],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyGradientDescent(const I_var:string; const I_alpha:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyGradientDescent',[I_var,I_alpha,I_delta],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyKerasMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceApplyKerasMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],[],[],[],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_momentum:string; const A_T:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],[],[],[],['T','use_locking','use_nesterov'],['type','bool','bool'],[@A_T,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceApplyPowerSign(const I_var:string; const I_m:string; const I_lr:string; const I_logbase:string; const I_sign_decay:string; const I_beta:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyPowerSign',[I_var,I_m,I_lr,I_logbase,I_sign_decay,I_beta,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_delta:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_delta],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const A_T:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],[],[],[],['T','use_locking'],['type','bool'],[@A_T,@A_use_locking])
  end;
function TGraphExt.AddResourceConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):string;
  begin
  result:=AddOper('ResourceConditionalAccumulator',[],[],[],[O_handle],['dtype','shape','container','shared_name','reduction_type'],['type','shape','string','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name,@A_reduction_type])
  end;
function TGraphExt.AddResourceCountUpTo(const I_resource:string; const O_output:string; const A_limit:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ResourceCountUpTo',[I_resource],[],[],[O_output],['limit','T'],['int','type'],[@A_limit,@A_T])
  end;
function TGraphExt.AddResourceGather(const I_resource:string; const I_indices:string; const O_output:string; const A_batch_dims:cint64; const A_validate_indices:boolean; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceGather',[I_resource,I_indices],[],[],[O_output],['batch_dims','validate_indices','dtype','Tindices'],['int','bool','type','type'],[@A_batch_dims,@A_validate_indices,@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceGatherNd(const I_resource:string; const I_indices:string; const O_output:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceGatherNd',[I_resource,I_indices],[],[],[O_output],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterAdd(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterAdd',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterDiv(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterDiv',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterMax(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterMax',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterMin(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterMin',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterMul(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterMul',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterNdAdd(const I_ref:string; const I_indices:string; const I_updates:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceScatterNdAdd',[I_ref,I_indices,I_updates],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceScatterNdSub(const I_ref:string; const I_indices:string; const I_updates:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceScatterNdSub',[I_ref,I_indices,I_updates],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceScatterNdUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceScatterNdUpdate',[I_ref,I_indices,I_updates],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceScatterSub(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterSub',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceScatterUpdate(const I_resource:string; const I_indices:string; const I_updates:string; const A_dtype:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ResourceScatterUpdate',[I_resource,I_indices,I_updates],[],[],[],['dtype','Tindices'],['type','type'],[@A_dtype,@A_Tindices])
  end;
function TGraphExt.AddResourceSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad,I_indices],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdagrad',[I_var,I_accum,I_lr,I_grad,I_indices],[],[],[],['T','Tindices','use_locking','update_slots'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddResourceSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_indices,I_lr,I_l1,I_l2,I_global_step],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyAdagradV2',[I_var,I_accum,I_lr,I_epsilon,I_grad,I_indices],[],[],[],['T','Tindices','use_locking','update_slots'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddResourceSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_lr_power],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyKerasMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyKerasMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],[],[],[],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],[],[],[],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddResourceSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad,I_indices],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_grad,I_indices],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ResourceSparseApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[],[],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddResourceStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('ResourceStridedSliceAssign',[I_ref,I_begin,I_end,I_strides,I_value],[],[],[],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddRestore(const I_file_pattern:string; const I_tensor_name:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
  begin
  result:=AddOper('Restore',[I_file_pattern,I_tensor_name],[],[],[O_tensor],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard])
  end;
function TGraphExt.AddRestoreSlice(const I_file_pattern:string; const I_tensor_name:string; const I_shape_and_slice:string; const O_tensor:string; const A_dt:TF_DataType; const A_preferred_shard:cint64):string;
  begin
  result:=AddOper('RestoreSlice',[I_file_pattern,I_tensor_name,I_shape_and_slice],[],[],[O_tensor],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard])
  end;
function TGraphExt.AddRestoreV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const OL_tensors:string; const A_dtypes:TF_TypeList):string;
  begin
  result:=AddOper('RestoreV2',[I_prefix,I_tensor_names,I_shape_and_slices],[],[],[OL_tensors],['dtypes'],['list(type)'],[@A_dtypes])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingADAMParameters(const O_parameters:string; const O_momenta:string; const O_velocities:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingADAMParameters',[],[],[],[O_parameters,O_momenta,O_velocities],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingADAMParametersGradAccumDebug(const O_parameters:string; const O_momenta:string; const O_velocities:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingADAMParametersGradAccumDebug',[],[],[],[O_parameters,O_momenta,O_velocities,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingAdadeltaParameters(const O_parameters:string; const O_accumulators:string; const O_updates:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingAdadeltaParameters',[],[],[],[O_parameters,O_accumulators,O_updates],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_updates:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug',[],[],[],[O_parameters,O_accumulators,O_updates,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingAdagradParameters(const O_parameters:string; const O_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingAdagradParameters',[],[],[],[O_parameters,O_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingAdagradParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingAdagradParametersGradAccumDebug',[],[],[],[O_parameters,O_accumulators,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingCenteredRMSPropParameters(const O_parameters:string; const O_ms:string; const O_mom:string; const O_mg:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingCenteredRMSPropParameters',[],[],[],[O_parameters,O_ms,O_mom,O_mg],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingFTRLParameters(const O_parameters:string; const O_accumulators:string; const O_linears:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingFTRLParameters',[],[],[],[O_parameters,O_accumulators,O_linears],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingFTRLParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_linears:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingFTRLParametersGradAccumDebug',[],[],[],[O_parameters,O_accumulators,O_linears,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingMDLAdagradLightParameters(const O_parameters:string; const O_accumulators:string; const O_weights:string; const O_benefits:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingMDLAdagradLightParameters',[],[],[],[O_parameters,O_accumulators,O_weights,O_benefits],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingMomentumParameters(const O_parameters:string; const O_momenta:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingMomentumParameters',[],[],[],[O_parameters,O_momenta],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingMomentumParametersGradAccumDebug(const O_parameters:string; const O_momenta:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingMomentumParametersGradAccumDebug',[],[],[],[O_parameters,O_momenta,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingProximalAdagradParameters(const O_parameters:string; const O_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingProximalAdagradParameters',[],[],[],[O_parameters,O_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(const O_parameters:string; const O_accumulators:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug',[],[],[],[O_parameters,O_accumulators,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingRMSPropParameters(const O_parameters:string; const O_ms:string; const O_mom:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingRMSPropParameters',[],[],[],[O_parameters,O_ms,O_mom],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(const O_parameters:string; const O_ms:string; const O_mom:string; const O_gradient_accumulators:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug',[],[],[],[O_parameters,O_ms,O_mom,O_gradient_accumulators],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddRetrieveTPUEmbeddingStochasticGradientDescentParameters(const O_parameters:string; const A_table_id:cint64; const A_table_name:string; const A_num_shards:cint64; const A_shard_id:cint64; const A_config:string):string;
  begin
  result:=AddOper('RetrieveTPUEmbeddingStochasticGradientDescentParameters',[],[],[],[O_parameters],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config])
  end;
function TGraphExt.AddReverse(const I_tensor:string; const I_dims:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Reverse',[I_tensor,I_dims],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddReverseSequence(const I_input:string; const I_seq_lengths:string; const O_output:string; const A_seq_dim:cint64; const A_batch_dim:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
  begin
  result:=AddOper('ReverseSequence',[I_input,I_seq_lengths],[],[],[O_output],['seq_dim','batch_dim','T','Tlen'],['int','int','type','type'],[@A_seq_dim,@A_batch_dim,@A_T,@A_Tlen])
  end;
function TGraphExt.AddReverseV2(const I_tensor:string; const I_axis:string; const O_output:string; const A_Tidx:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ReverseV2',[I_tensor,I_axis],[],[],[O_output],['Tidx','T'],['type','type'],[@A_Tidx,@A_T])
  end;
function TGraphExt.AddRightShift(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RightShift',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRint(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Rint',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRngSkip(const I_resource:string; const I_algorithm:string; const I_delta:string):string;
  begin
  result:=AddOper('RngSkip',[I_resource,I_algorithm,I_delta],[],[],[],[],[],[])
  end;
function TGraphExt.AddRoll(const I_input:string; const I_shift:string; const I_axis:string; const O_output:string; const A_T:TF_DataType; const A_Tshift:TF_DataType; const A_Taxis:TF_DataType):string;
  begin
  result:=AddOper('Roll',[I_input,I_shift,I_axis],[],[],[O_output],['T','Tshift','Taxis'],['type','type','type'],[@A_T,@A_Tshift,@A_Taxis])
  end;
function TGraphExt.AddRound(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Round',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRpc(const I_address:string; const I_method:string; const I_request:string; const O_response:string; const A_protocol:string; const A_fail_fast:boolean; const A_timeout_in_ms:cint64):string;
  begin
  result:=AddOper('Rpc',[I_address,I_method,I_request],[],[],[O_response],['protocol','fail_fast','timeout_in_ms'],['string','bool','int'],[@A_protocol,@A_fail_fast,@A_timeout_in_ms])
  end;
function TGraphExt.AddRsqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Rsqrt',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddRsqrtGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('RsqrtGrad',[I_y,I_dy],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSampleDistortedBoundingBox(const I_image_size:string; const I_bounding_boxes:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_min_object_covered:real; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
  begin
  result:=AddOper('SampleDistortedBoundingBox',[I_image_size,I_bounding_boxes],[],[],[O_begin,O_size,O_bboxes],['T','seed','seed2','min_object_covered','aspect_ratio_range','area_range','max_attempts','use_image_if_no_bounding_boxes'],['type','int','int','float','list(float)','list(float)','int','bool'],[@A_T,@A_seed,@A_seed2,@A_min_object_covered,@A_aspect_ratio_range,@A_area_range,@A_max_attempts,@A_use_image_if_no_bounding_boxes])
  end;
function TGraphExt.AddSampleDistortedBoundingBoxV2(const I_image_size:string; const I_bounding_boxes:string; const I_min_object_covered:string; const O_begin:string; const O_size:string; const O_bboxes:string; const A_T:TF_DataType; const A_seed:cint64; const A_seed2:cint64; const A_aspect_ratio_range:TF_FloatList; const A_area_range:TF_FloatList; const A_max_attempts:cint64; const A_use_image_if_no_bounding_boxes:boolean):string;
  begin
  result:=AddOper('SampleDistortedBoundingBoxV2',[I_image_size,I_bounding_boxes,I_min_object_covered],[],[],[O_begin,O_size,O_bboxes],['T','seed','seed2','aspect_ratio_range','area_range','max_attempts','use_image_if_no_bounding_boxes'],['type','int','int','list(float)','list(float)','int','bool'],[@A_T,@A_seed,@A_seed2,@A_aspect_ratio_range,@A_area_range,@A_max_attempts,@A_use_image_if_no_bounding_boxes])
  end;
function TGraphExt.AddSamplingDataset(const I_input_dataset:string; const I_rate:string; const I_seed:string; const I_seed2:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SamplingDataset',[I_input_dataset,I_rate,I_seed,I_seed2],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSave(const I_filename:string; const I_tensor_names:string; const IL_data:string; const A_T:TF_TypeList):string;
  begin
  result:=AddOper('Save',[I_filename,I_tensor_names],[IL_data],[Length(A_T)],[],['T'],['list(type)'],[@A_T])
  end;
function TGraphExt.AddSaveSlices(const I_filename:string; const I_tensor_names:string; const I_shapes_and_slices:string; const IL_data:string; const A_T:TF_TypeList):string;
  begin
  result:=AddOper('SaveSlices',[I_filename,I_tensor_names,I_shapes_and_slices],[IL_data],[Length(A_T)],[],['T'],['list(type)'],[@A_T])
  end;
function TGraphExt.AddSaveV2(const I_prefix:string; const I_tensor_names:string; const I_shape_and_slices:string; const IL_tensors:string; const A_dtypes:TF_TypeList):string;
  begin
  result:=AddOper('SaveV2',[I_prefix,I_tensor_names,I_shape_and_slices],[IL_tensors],[Length(A_dtypes)],[],['dtypes'],['list(type)'],[@A_dtypes])
  end;
function TGraphExt.AddScalarSummary(const I_tags:string; const I_values:string; const O_summary:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ScalarSummary',[I_tags,I_values],[],[],[O_summary],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddScaleAndTranslate(const I_images:string; const I_size:string; const I_scale:string; const I_translation:string; const O_resized_images:string; const A_T:TF_DataType; const A_kernel_type:string; const A_antialias:boolean):string;
  begin
  result:=AddOper('ScaleAndTranslate',[I_images,I_size,I_scale,I_translation],[],[],[O_resized_images],['T','kernel_type','antialias'],['type','string','bool'],[@A_T,@A_kernel_type,@A_antialias])
  end;
function TGraphExt.AddScaleAndTranslateGrad(const I_grads:string; const I_original_image:string; const I_scale:string; const I_translation:string; const O_output:string; const A_T:TF_DataType; const A_kernel_type:string; const A_antialias:boolean):string;
  begin
  result:=AddOper('ScaleAndTranslateGrad',[I_grads,I_original_image,I_scale,I_translation],[],[],[O_output],['T','kernel_type','antialias'],['type','string','bool'],[@A_T,@A_kernel_type,@A_antialias])
  end;
function TGraphExt.AddScanDataset(const I_input_dataset:string; const IL_initial_state:string; const IL_other_arguments:string; const O_handle:string; const A_f:TF_Function; const A_Tstate:TF_TypeList; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_preserve_cardinality:boolean; const A_use_default_device:boolean):string;
  begin
  result:=AddOper('ScanDataset',[I_input_dataset],[IL_initial_state,IL_other_arguments],[Length(A_Tstate),Length(A_Targuments)],[O_handle],['f','Tstate','Targuments','output_types','output_shapes','preserve_cardinality','use_default_device'],['func','list(type)','list(type)','list(type)','list(shape)','bool','bool'],[@A_f,@A_Tstate,@A_Targuments,@A_output_types,@A_output_shapes,@A_preserve_cardinality,@A_use_default_device])
  end;
function TGraphExt.AddScatterAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterAdd',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterDiv(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterDiv',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterMax(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterMax',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterMin(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterMin',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterMul(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterMul',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterNd(const I_indices:string; const I_updates:string; const I_shape:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ScatterNd',[I_indices,I_updates,I_shape],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddScatterNdAdd(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterNdAdd',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterNdNonAliasingAdd(const I_input:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('ScatterNdNonAliasingAdd',[I_input,I_indices,I_updates],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddScatterNdSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterNdSub',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterNdUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterNdUpdate',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterSub(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterSub',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddScatterUpdate(const I_ref:string; const I_indices:string; const I_updates:string; const O_output_ref:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('ScatterUpdate',[I_ref,I_indices,I_updates],[],[],[O_output_ref],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSdcaFprint(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('SdcaFprint',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddSdcaOptimizer(const I_example_weights:string; const I_example_labels:string; const I_example_state_data:string; const IL_sparse_example_indices:string; const IL_sparse_feature_indices:string; const IL_sparse_feature_values:string; const IL_dense_features:string; const IL_sparse_indices:string; const IL_sparse_weights:string; const IL_dense_weights:string; const O_out_example_state_data:string; const OL_out_delta_sparse_weights:string; const OL_out_delta_dense_weights:string; const A_loss_type:string; const A_adaptative:boolean; const A_num_sparse_features:cint64; const A_num_sparse_features_with_values:cint64; const A_num_dense_features:cint64; const A_l1:real; const A_l2:real; const A_num_loss_partitions:cint64; const A_num_inner_iterations:cint64):string;
  begin
  result:=AddOper('SdcaOptimizer',[I_example_weights,I_example_labels,I_example_state_data],[IL_sparse_example_indices,IL_sparse_feature_indices,IL_sparse_feature_values,IL_dense_features,IL_sparse_indices,IL_sparse_weights,IL_dense_weights],[A_num_sparse_features,A_num_sparse_features,A_num_sparse_features_with_values,A_num_dense_features,A_num_sparse_features,A_num_sparse_features,A_num_dense_features],[O_out_example_state_data,OL_out_delta_sparse_weights,OL_out_delta_dense_weights],['loss_type','adaptative','num_sparse_features','num_sparse_features_with_values','num_dense_features','l1','l2','num_loss_partitions','num_inner_iterations'],['string','bool','int','int','int','float','float','int','int'],[@A_loss_type,@A_adaptative,@A_num_sparse_features,@A_num_sparse_features_with_values,@A_num_dense_features,@A_l1,@A_l2,@A_num_loss_partitions,@A_num_inner_iterations])
  end;
function TGraphExt.AddSdcaOptimizerV2(const I_example_weights:string; const I_example_labels:string; const I_example_state_data:string; const IL_sparse_example_indices:string; const IL_sparse_feature_indices:string; const IL_sparse_feature_values:string; const IL_dense_features:string; const IL_sparse_indices:string; const IL_sparse_weights:string; const IL_dense_weights:string; const O_out_example_state_data:string; const OL_out_delta_sparse_weights:string; const OL_out_delta_dense_weights:string; const A_loss_type:string; const A_adaptive:boolean; const A_num_sparse_features:cint64; const A_num_sparse_features_with_values:cint64; const A_num_dense_features:cint64; const A_l1:real; const A_l2:real; const A_num_loss_partitions:cint64; const A_num_inner_iterations:cint64):string;
  begin
  result:=AddOper('SdcaOptimizerV2',[I_example_weights,I_example_labels,I_example_state_data],[IL_sparse_example_indices,IL_sparse_feature_indices,IL_sparse_feature_values,IL_dense_features,IL_sparse_indices,IL_sparse_weights,IL_dense_weights],[A_num_sparse_features,A_num_sparse_features,A_num_sparse_features_with_values,A_num_dense_features,A_num_sparse_features,A_num_sparse_features,A_num_dense_features],[O_out_example_state_data,OL_out_delta_sparse_weights,OL_out_delta_dense_weights],['loss_type','adaptive','num_sparse_features','num_sparse_features_with_values','num_dense_features','l1','l2','num_loss_partitions','num_inner_iterations'],['string','bool','int','int','int','float','float','int','int'],[@A_loss_type,@A_adaptive,@A_num_sparse_features,@A_num_sparse_features_with_values,@A_num_dense_features,@A_l1,@A_l2,@A_num_loss_partitions,@A_num_inner_iterations])
  end;
function TGraphExt.AddSdcaShrinkL1(const IL_weights:string; const A_num_features:cint64; const A_l1:real; const A_l2:real):string;
  begin
  result:=AddOper('SdcaShrinkL1',[],[IL_weights],[A_num_features],[],['num_features','l1','l2'],['int','float','float'],[@A_num_features,@A_l1,@A_l2])
  end;
function TGraphExt.AddSegmentMax(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentMax',[I_data,I_segment_ids],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentMean(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentMean',[I_data,I_segment_ids],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentMin(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentMin',[I_data,I_segment_ids],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentProd(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentProd',[I_data,I_segment_ids],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSegmentSum(const I_data:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SegmentSum',[I_data,I_segment_ids],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSelect(const I_condition:string; const I_t:string; const I_e:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Select',[I_condition,I_t,I_e],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSelectV2(const I_condition:string; const I_t:string; const I_e:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SelectV2',[I_condition,I_t,I_e],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSelfAdjointEig(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SelfAdjointEig',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSelfAdjointEigV2(const I_input:string; const O_e:string; const O_v:string; const A_compute_v:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SelfAdjointEigV2',[I_input],[],[],[O_e,O_v],['compute_v','T'],['bool','type'],[@A_compute_v,@A_T])
  end;
function TGraphExt.AddSelu(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Selu',[I_features],[],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSeluGrad(const I_gradients:string; const I_outputs:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SeluGrad',[I_gradients,I_outputs],[],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSend(const I_tensor:string; const A_T:TF_DataType; const A_tensor_name:string; const A_send_device:string; const A_send_device_incarnation:cint64; const A_recv_device:string; const A_client_terminated:boolean):string;
  begin
  result:=AddOper('Send',[I_tensor],[],[],[],['T','tensor_name','send_device','send_device_incarnation','recv_device','client_terminated'],['type','string','string','int','string','bool'],[@A_T,@A_tensor_name,@A_send_device,@A_send_device_incarnation,@A_recv_device,@A_client_terminated])
  end;
function TGraphExt.AddSendTPUEmbeddingGradients(const IL_inputs:string; const IL_learning_rates:string; const A_N:cint64; const A_NN:cint64; const A_config:string):string;
  begin
  result:=AddOper('SendTPUEmbeddingGradients',[],[IL_inputs,IL_learning_rates],[A_N,A_NN],[],['N','NN','config'],['int','int','string'],[@A_N,@A_NN,@A_config])
  end;
function TGraphExt.AddSerializeIterator(const I_resource_handle:string; const O_serialized:string; const A_external_state_policy:cint64):string;
  begin
  result:=AddOper('SerializeIterator',[I_resource_handle],[],[],[O_serialized],['external_state_policy'],['int'],[@A_external_state_policy])
  end;
function TGraphExt.AddSerializeManySparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('SerializeManySparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[],[O_serialized_sparse],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddSerializeSparse(const I_sparse_indices:string; const I_sparse_values:string; const I_sparse_shape:string; const O_serialized_sparse:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('SerializeSparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],[],[],[O_serialized_sparse],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddSerializeTensor(const I_tensor:string; const O_serialized:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SerializeTensor',[I_tensor],[],[],[O_serialized],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSetSize(const I_set_indices:string; const I_set_values:string; const I_set_shape:string; const O_size:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SetSize',[I_set_indices,I_set_values,I_set_shape],[],[],[O_size],['validate_indices','T'],['bool','type'],[@A_validate_indices,@A_T])
  end;
function TGraphExt.AddSetStatsAggregatorDataset(const I_input_dataset:string; const I_stats_aggregator:string; const I_tag:string; const I_counter_prefix:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SetStatsAggregatorDataset',[I_input_dataset,I_stats_aggregator,I_tag,I_counter_prefix],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddShape(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('Shape',[I_input],[],[],[O_output],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddShapeN(const IL_input:string; const OL_output:string; const A_N:cint64; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('ShapeN',[],[IL_input],[A_N],[OL_output],['N','T','out_type'],['int','type','type'],[@A_N,@A_T,@A_out_type])
  end;
function TGraphExt.AddShardDataset(const I_input_dataset:string; const I_num_shards:string; const I_index:string; const O_handle:string; const A_require_non_empty:boolean; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ShardDataset',[I_input_dataset,I_num_shards,I_index],[],[],[O_handle],['require_non_empty','output_types','output_shapes'],['bool','list(type)','list(shape)'],[@A_require_non_empty,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddShardedFilename(const I_basename:string; const I_shard:string; const I_num_shards:string; const O_filename:string):string;
  begin
  result:=AddOper('ShardedFilename',[I_basename,I_shard,I_num_shards],[],[],[O_filename],[],[],[])
  end;
function TGraphExt.AddShardedFilespec(const I_basename:string; const I_num_shards:string; const O_filename:string):string;
  begin
  result:=AddOper('ShardedFilespec',[I_basename,I_num_shards],[],[],[O_filename],[],[],[])
  end;
function TGraphExt.AddShuffleAndRepeatDataset(const I_input_dataset:string; const I_buffer_size:string; const I_seed:string; const I_seed2:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ShuffleAndRepeatDataset',[I_input_dataset,I_buffer_size,I_seed,I_seed2,I_count],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddShuffleDataset(const I_input_dataset:string; const I_buffer_size:string; const I_seed:string; const I_seed2:string; const O_handle:string; const A_reshuffle_each_iteration:boolean; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ShuffleDataset',[I_input_dataset,I_buffer_size,I_seed,I_seed2],[],[],[O_handle],['reshuffle_each_iteration','output_types','output_shapes'],['bool','list(type)','list(shape)'],[@A_reshuffle_each_iteration,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddShuffleDatasetV2(const I_input_dataset:string; const I_buffer_size:string; const I_seed_generator:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ShuffleDatasetV2',[I_input_dataset,I_buffer_size,I_seed_generator],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddShutdownDistributedTPU():string;
  begin
  result:=AddOper('ShutdownDistributedTPU',[],[],[],[],[],[],[])
  end;
function TGraphExt.AddSigmoid(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sigmoid',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSigmoidGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SigmoidGrad',[I_y,I_dy],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSign(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sign',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSin(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sin',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSinh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sinh',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSize(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('Size',[I_input],[],[],[O_output],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddSkipDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SkipDataset',[I_input_dataset,I_count],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSkipgram(const O_vocab_word:string; const O_vocab_freq:string; const O_words_per_epoch:string; const O_current_epoch:string; const O_total_words_processed:string; const O_examples:string; const O_labels:string; const A_filename:string; const A_batch_size:cint64; const A_window_size:cint64; const A_min_count:cint64; const A_subsample:real):string;
  begin
  result:=AddOper('Skipgram',[],[],[],[O_vocab_word,O_vocab_freq,O_words_per_epoch,O_current_epoch,O_total_words_processed,O_examples,O_labels],['filename','batch_size','window_size','min_count','subsample'],['string','int','int','int','float'],[@A_filename,@A_batch_size,@A_window_size,@A_min_count,@A_subsample])
  end;
function TGraphExt.AddSleepDataset(const I_input_dataset:string; const I_sleep_microseconds:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SleepDataset',[I_input_dataset,I_sleep_microseconds],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSlice(const I_input:string; const I_begin:string; const I_size:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType):string;
  begin
  result:=AddOper('Slice',[I_input,I_begin,I_size],[],[],[O_output],['T','Index'],['type','type'],[@A_T,@A_Index])
  end;
function TGraphExt.AddSlidingWindowDataset(const I_input_dataset:string; const I_window_size:string; const I_window_shift:string; const I_window_stride:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SlidingWindowDataset',[I_input_dataset,I_window_size,I_window_shift,I_window_stride],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSnapshot(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Snapshot',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSnapshotDataset(const I_input_dataset:string; const I_path:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_compression:string; const A_reader_path_prefix:string; const A_writer_path_prefix:string; const A_shard_size_bytes:cint64; const A_pending_snapshot_expiry_seconds:cint64; const A_num_reader_threads:cint64; const A_reader_buffer_size:cint64; const A_num_writer_threads:cint64; const A_writer_buffer_size:cint64; const A_shuffle_on_read:boolean; const A_seed:cint64; const A_seed2:cint64; const A_mode:string; const A_snapshot_name:string):string;
  begin
  result:=AddOper('SnapshotDataset',[I_input_dataset,I_path],[],[],[O_handle],['output_types','output_shapes','compression','reader_path_prefix','writer_path_prefix','shard_size_bytes','pending_snapshot_expiry_seconds','num_reader_threads','reader_buffer_size','num_writer_threads','writer_buffer_size','shuffle_on_read','seed','seed2','mode','snapshot_name'],['list(type)','list(shape)','string','string','string','int','int','int','int','int','int','bool','int','int','string','string'],[@A_output_types,@A_output_shapes,@A_compression,@A_reader_path_prefix,@A_writer_path_prefix,@A_shard_size_bytes,@A_pending_snapshot_expiry_seconds,@A_num_reader_threads,@A_reader_buffer_size,@A_num_writer_threads,@A_writer_buffer_size,@A_shuffle_on_read,@A_seed,@A_seed2,@A_mode,@A_snapshot_name])
  end;
function TGraphExt.AddSobolSample(const I_dim:string; const I_num_results:string; const I_skip:string; const O_samples:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('SobolSample',[I_dim,I_num_results,I_skip],[],[],[O_samples],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddSoftmax(const I_logits:string; const O_softmax:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Softmax',[I_logits],[],[],[O_softmax],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SoftmaxCrossEntropyWithLogits',[I_features,I_labels],[],[],[O_loss,O_backprop],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftplus(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Softplus',[I_features],[],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftplusGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SoftplusGrad',[I_gradients,I_features],[],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftsign(const I_features:string; const O_activations:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Softsign',[I_features],[],[],[O_activations],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSoftsignGrad(const I_gradients:string; const I_features:string; const O_backprops:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SoftsignGrad',[I_gradients,I_features],[],[],[O_backprops],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSpaceToBatch(const I_input:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tpaddings:TF_DataType; const A_block_size:cint64):string;
  begin
  result:=AddOper('SpaceToBatch',[I_input,I_paddings],[],[],[O_output],['T','Tpaddings','block_size'],['type','type','int'],[@A_T,@A_Tpaddings,@A_block_size])
  end;
function TGraphExt.AddSpaceToBatchND(const I_input:string; const I_block_shape:string; const I_paddings:string; const O_output:string; const A_T:TF_DataType; const A_Tblock_shape:TF_DataType; const A_Tpaddings:TF_DataType):string;
  begin
  result:=AddOper('SpaceToBatchND',[I_input,I_block_shape,I_paddings],[],[],[O_output],['T','Tblock_shape','Tpaddings'],['type','type','type'],[@A_T,@A_Tblock_shape,@A_Tpaddings])
  end;
function TGraphExt.AddSpaceToDepth(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_block_size:cint64; const A_data_format:string):string;
  begin
  result:=AddOper('SpaceToDepth',[I_input],[],[],[O_output],['T','block_size','data_format'],['type','int','string'],[@A_T,@A_block_size,@A_data_format])
  end;
function TGraphExt.AddSparseAccumulatorApplyGradient(const I_handle:string; const I_local_step:string; const I_gradient_indices:string; const I_gradient_values:string; const I_gradient_shape:string; const A_dtype:TF_DataType; const A_has_known_shape:boolean):string;
  begin
  result:=AddOper('SparseAccumulatorApplyGradient',[I_handle,I_local_step,I_gradient_indices,I_gradient_values,I_gradient_shape],[],[],[],['dtype','has_known_shape'],['type','bool'],[@A_dtype,@A_has_known_shape])
  end;
function TGraphExt.AddSparseAccumulatorTakeGradient(const I_handle:string; const I_num_required:string; const O_indices:string; const O_values:string; const O_shape:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('SparseAccumulatorTakeGradient',[I_handle,I_num_required],[],[],[O_indices,O_values,O_shape],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddSparseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const I_thresh:string; const O_sum_indices:string; const O_sum_values:string; const O_sum_shape:string; const A_T:TF_DataType; const A_Treal:TF_DataType):string;
  begin
  result:=AddOper('SparseAdd',[I_a_indices,I_a_values,I_a_shape,I_b_indices,I_b_values,I_b_shape,I_thresh],[],[],[O_sum_indices,O_sum_values,O_sum_shape],['T','Treal'],['type','type'],[@A_T,@A_Treal])
  end;
function TGraphExt.AddSparseAddGrad(const I_backprop_val_grad:string; const I_a_indices:string; const I_b_indices:string; const I_sum_indices:string; const O_a_val_grad:string; const O_b_val_grad:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseAddGrad',[I_backprop_val_grad,I_a_indices,I_b_indices,I_sum_indices],[],[],[O_a_val_grad,O_b_val_grad],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseApplyAdadelta(const I_var:string; const I_accum:string; const I_accum_update:string; const I_lr:string; const I_rho:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('SparseApplyAdagrad',[I_var,I_accum,I_lr,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking','update_slots'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddSparseApplyAdagradDA(const I_var:string; const I_gradient_accumulator:string; const I_gradient_squared_accumulator:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_global_step:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_indices,I_lr,I_l1,I_l2,I_global_step],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyAdagradV2(const I_var:string; const I_accum:string; const I_lr:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_update_slots:boolean):string;
  begin
  result:=AddOper('SparseApplyAdagradV2',[I_var,I_accum,I_lr,I_epsilon,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking','update_slots'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_update_slots])
  end;
function TGraphExt.AddSparseApplyCenteredRMSProp(const I_var:string; const I_mg:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyFtrl(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_lr_power],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyFtrlV2(const I_var:string; const I_accum:string; const I_linear:string; const I_grad:string; const I_indices:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_l2_shrinkage:string; const I_lr_power:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyMomentum(const I_var:string; const I_accum:string; const I_lr:string; const I_grad:string; const I_indices:string; const I_momentum:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean; const A_use_nesterov:boolean):string;
  begin
  result:=AddOper('SparseApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],[],[],[O_out],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_use_locking,@A_use_nesterov])
  end;
function TGraphExt.AddSparseApplyProximalAdagrad(const I_var:string; const I_accum:string; const I_lr:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyProximalGradientDescent(const I_var:string; const I_alpha:string; const I_l1:string; const I_l2:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseApplyRMSProp(const I_var:string; const I_ms:string; const I_mom:string; const I_lr:string; const I_rho:string; const I_momentum:string; const I_epsilon:string; const I_grad:string; const I_indices:string; const O_out:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_use_locking:boolean):string;
  begin
  result:=AddOper('SparseApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],[],[],[O_out],['T','Tindices','use_locking'],['type','type','bool'],[@A_T,@A_Tindices,@A_use_locking])
  end;
function TGraphExt.AddSparseConcat(const IL_indices:string; const IL_values:string; const IL_shapes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_concat_dim:cint64; const A_N:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseConcat',[],[IL_indices,IL_values,IL_shapes],[A_N,A_N,A_N],[O_output_indices,O_output_values,O_output_shape],['concat_dim','N','T'],['int','int','type'],[@A_concat_dim,@A_N,@A_T])
  end;
function TGraphExt.AddSparseConditionalAccumulator(const O_handle:string; const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):string;
  begin
  result:=AddOper('SparseConditionalAccumulator',[],[],[],[O_handle],['dtype','shape','container','shared_name','reduction_type'],['type','shape','string','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name,@A_reduction_type])
  end;
function TGraphExt.AddSparseCross(const IL_indices:string; const IL_values:string; const IL_shapes:string; const IL_dense_inputs:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_N:cint64; const A_hashed_output:boolean; const A_num_buckets:cint64; const A_hash_key:cint64; const A_sparse_types:TF_TypeList; const A_dense_types:TF_TypeList; const A_out_type:TF_DataType; const A_internal_type:TF_DataType):string;
  begin
  result:=AddOper('SparseCross',[],[IL_indices,IL_values,IL_shapes,IL_dense_inputs],[A_N,Length(A_sparse_types),A_N,Length(A_dense_types)],[O_output_indices,O_output_values,O_output_shape],['N','hashed_output','num_buckets','hash_key','sparse_types','dense_types','out_type','internal_type'],['int','bool','int','int','list(type)','list(type)','type','type'],[@A_N,@A_hashed_output,@A_num_buckets,@A_hash_key,@A_sparse_types,@A_dense_types,@A_out_type,@A_internal_type])
  end;
function TGraphExt.AddSparseDenseCwiseAdd(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseDenseCwiseAdd',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseDenseCwiseDiv(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseDenseCwiseDiv',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseDenseCwiseMul(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const I_dense:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseDenseCwiseMul',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseFillEmptyRows(const I_indices:string; const I_values:string; const I_dense_shape:string; const I_default_value:string; const O_output_indices:string; const O_output_values:string; const O_empty_row_indicator:string; const O_reverse_index_map:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseFillEmptyRows',[I_indices,I_values,I_dense_shape,I_default_value],[],[],[O_output_indices,O_output_values,O_empty_row_indicator,O_reverse_index_map],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseFillEmptyRowsGrad(const I_reverse_index_map:string; const I_grad_values:string; const O_d_values:string; const O_d_default_value:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseFillEmptyRowsGrad',[I_reverse_index_map,I_grad_values],[],[],[O_d_values,O_d_default_value],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseMatMul(const I_a:string; const I_b:string; const O_product:string; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const A_Ta:TF_DataType; const A_Tb:TF_DataType):string;
  begin
  result:=AddOper('SparseMatMul',[I_a,I_b],[],[],[O_product],['transpose_a','transpose_b','a_is_sparse','b_is_sparse','Ta','Tb'],['bool','bool','bool','bool','type','type'],[@A_transpose_a,@A_transpose_b,@A_a_is_sparse,@A_b_is_sparse,@A_Ta,@A_Tb])
  end;
function TGraphExt.AddSparseMatrixAdd(const I_a:string; const I_b:string; const I_alpha:string; const I_beta:string; const O_c:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixAdd',[I_a,I_b,I_alpha,I_beta],[],[],[O_c],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseMatrixMatMul(const I_a:string; const I_b:string; const O_output:string; const A_T:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const A_transpose_output:boolean; const A_conjugate_output:boolean):string;
  begin
  result:=AddOper('SparseMatrixMatMul',[I_a,I_b],[],[],[O_output],['T','transpose_a','transpose_b','adjoint_a','adjoint_b','transpose_output','conjugate_output'],['type','bool','bool','bool','bool','bool','bool'],[@A_T,@A_transpose_a,@A_transpose_b,@A_adjoint_a,@A_adjoint_b,@A_transpose_output,@A_conjugate_output])
  end;
function TGraphExt.AddSparseMatrixMul(const I_a:string; const I_b:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixMul',[I_a,I_b],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseMatrixNNZ(const I_sparse_matrix:string; const O_nnz:string):string;
  begin
  result:=AddOper('SparseMatrixNNZ',[I_sparse_matrix],[],[],[O_nnz],[],[],[])
  end;
function TGraphExt.AddSparseMatrixOrderingAMD(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('SparseMatrixOrderingAMD',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddSparseMatrixSoftmax(const I_logits:string; const O_softmax:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixSoftmax',[I_logits],[],[],[O_softmax],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddSparseMatrixSoftmaxGrad(const I_softmax:string; const I_grad_softmax:string; const O_gradient:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixSoftmaxGrad',[I_softmax,I_grad_softmax],[],[],[O_gradient],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddSparseMatrixSparseCholesky(const I_input:string; const I_permutation:string; const O_output:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixSparseCholesky',[I_input,I_permutation],[],[],[O_output],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddSparseMatrixSparseMatMul(const I_a:string; const I_b:string; const O_c:string; const A_type:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean):string;
  begin
  result:=AddOper('SparseMatrixSparseMatMul',[I_a,I_b],[],[],[O_c],['type','transpose_a','transpose_b','adjoint_a','adjoint_b'],['type','bool','bool','bool','bool'],[@A_type,@A_transpose_a,@A_transpose_b,@A_adjoint_a,@A_adjoint_b])
  end;
function TGraphExt.AddSparseMatrixTranspose(const I_input:string; const O_output:string; const A_conjugate:boolean; const A_type:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixTranspose',[I_input],[],[],[O_output],['conjugate','type'],['bool','type'],[@A_conjugate,@A_type])
  end;
function TGraphExt.AddSparseMatrixZeros(const I_dense_shape:string; const O_sparse_matrix:string; const A_type:TF_DataType):string;
  begin
  result:=AddOper('SparseMatrixZeros',[I_dense_shape],[],[],[O_sparse_matrix],['type'],['type'],[@A_type])
  end;
function TGraphExt.AddSparseReduceMax(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceMax',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[],[O_output],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReduceMaxSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceMaxSparse',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[],[O_output_indices,O_output_values,O_output_shape],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReduceSum(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceSum',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[],[O_output],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReduceSumSparse(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const I_reduction_axes:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_keep_dims:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReduceSumSparse',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],[],[],[O_output_indices,O_output_values,O_output_shape],['keep_dims','T'],['bool','type'],[@A_keep_dims,@A_T])
  end;
function TGraphExt.AddSparseReorder(const I_input_indices:string; const I_input_values:string; const I_input_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseReorder',[I_input_indices,I_input_values,I_input_shape],[],[],[O_output_indices,O_output_values],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseReshape(const I_input_indices:string; const I_input_shape:string; const I_new_shape:string; const O_output_indices:string; const O_output_shape:string):string;
  begin
  result:=AddOper('SparseReshape',[I_input_indices,I_input_shape,I_new_shape],[],[],[O_output_indices,O_output_shape],[],[],[])
  end;
function TGraphExt.AddSparseSegmentMean(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentMean',[I_data,I_indices,I_segment_ids],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentMeanGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentMeanGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentMeanWithNumSegments(const I_data:string; const I_indices:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentMeanWithNumSegments',[I_data,I_indices,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tidx','Tnumsegments'],['type','type','type'],[@A_T,@A_Tidx,@A_Tnumsegments])
  end;
function TGraphExt.AddSparseSegmentSqrtN(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSqrtN',[I_data,I_indices,I_segment_ids],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentSqrtNGrad(const I_grad:string; const I_indices:string; const I_segment_ids:string; const I_output_dim0:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSqrtNGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentSqrtNWithNumSegments(const I_data:string; const I_indices:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSqrtNWithNumSegments',[I_data,I_indices,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tidx','Tnumsegments'],['type','type','type'],[@A_T,@A_Tidx,@A_Tnumsegments])
  end;
function TGraphExt.AddSparseSegmentSum(const I_data:string; const I_indices:string; const I_segment_ids:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSum',[I_data,I_indices,I_segment_ids],[],[],[O_output],['T','Tidx'],['type','type'],[@A_T,@A_Tidx])
  end;
function TGraphExt.AddSparseSegmentSumWithNumSegments(const I_data:string; const I_indices:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tidx:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('SparseSegmentSumWithNumSegments',[I_data,I_indices,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tidx','Tnumsegments'],['type','type','type'],[@A_T,@A_Tidx,@A_Tnumsegments])
  end;
function TGraphExt.AddSparseSlice(const I_indices:string; const I_values:string; const I_shape:string; const I_start:string; const I_size:string; const O_output_indices:string; const O_output_values:string; const O_output_shape:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSlice',[I_indices,I_values,I_shape,I_start,I_size],[],[],[O_output_indices,O_output_values,O_output_shape],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSliceGrad(const I_backprop_val_grad:string; const I_input_indices:string; const I_input_start:string; const I_output_indices:string; const O_val_grad:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSliceGrad',[I_backprop_val_grad,I_input_indices,I_input_start,I_output_indices],[],[],[O_val_grad],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSoftmax(const I_sp_indices:string; const I_sp_values:string; const I_sp_shape:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSoftmax',[I_sp_indices,I_sp_values,I_sp_shape],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSoftmaxCrossEntropyWithLogits(const I_features:string; const I_labels:string; const O_loss:string; const O_backprop:string; const A_T:TF_DataType; const A_Tlabels:TF_DataType):string;
  begin
  result:=AddOper('SparseSoftmaxCrossEntropyWithLogits',[I_features,I_labels],[],[],[O_loss,O_backprop],['T','Tlabels'],['type','type'],[@A_T,@A_Tlabels])
  end;
function TGraphExt.AddSparseSparseMaximum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSparseMaximum',[I_a_indices,I_a_values,I_a_shape,I_b_indices,I_b_values,I_b_shape],[],[],[O_output_indices,O_output_values],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSparseMinimum(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b_indices:string; const I_b_values:string; const I_b_shape:string; const O_output_indices:string; const O_output_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSparseMinimum',[I_a_indices,I_a_values,I_a_shape,I_b_indices,I_b_values,I_b_shape],[],[],[O_output_indices,O_output_values],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseSplit(const I_split_dim:string; const I_indices:string; const I_values:string; const I_shape:string; const OL_output_indices:string; const OL_output_values:string; const OL_output_shape:string; const A_num_split:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseSplit',[I_split_dim,I_indices,I_values,I_shape],[],[],[OL_output_indices,OL_output_values,OL_output_shape],['num_split','T'],['int','type'],[@A_num_split,@A_T])
  end;
function TGraphExt.AddSparseTensorDenseAdd(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SparseTensorDenseAdd',[I_a_indices,I_a_values,I_a_shape,I_b],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddSparseTensorDenseMatMul(const I_a_indices:string; const I_a_values:string; const I_a_shape:string; const I_b:string; const O_product:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_adjoint_a:boolean; const A_adjoint_b:boolean):string;
  begin
  result:=AddOper('SparseTensorDenseMatMul',[I_a_indices,I_a_values,I_a_shape,I_b],[],[],[O_product],['T','Tindices','adjoint_a','adjoint_b'],['type','type','bool','bool'],[@A_T,@A_Tindices,@A_adjoint_a,@A_adjoint_b])
  end;
function TGraphExt.AddSparseTensorSliceDataset(const I_indices:string; const I_values:string; const I_dense_shape:string; const O_handle:string; const A_Tvalues:TF_DataType):string;
  begin
  result:=AddOper('SparseTensorSliceDataset',[I_indices,I_values,I_dense_shape],[],[],[O_handle],['Tvalues'],['type'],[@A_Tvalues])
  end;
function TGraphExt.AddSparseTensorToCSRSparseMatrix(const I_indices:string; const I_values:string; const I_dense_shape:string; const O_sparse_matrix:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseTensorToCSRSparseMatrix',[I_indices,I_values,I_dense_shape],[],[],[O_sparse_matrix],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSparseToDense(const I_sparse_indices:string; const I_output_shape:string; const I_sparse_values:string; const I_default_value:string; const O_dense:string; const A_validate_indices:boolean; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('SparseToDense',[I_sparse_indices,I_output_shape,I_sparse_values,I_default_value],[],[],[O_dense],['validate_indices','T','Tindices'],['bool','type','type'],[@A_validate_indices,@A_T,@A_Tindices])
  end;
function TGraphExt.AddSparseToSparseSetOperation(const I_set1_indices:string; const I_set1_values:string; const I_set1_shape:string; const I_set2_indices:string; const I_set2_values:string; const I_set2_shape:string; const O_result_indices:string; const O_result_values:string; const O_result_shape:string; const A_set_operation:string; const A_validate_indices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SparseToSparseSetOperation',[I_set1_indices,I_set1_values,I_set1_shape,I_set2_indices,I_set2_values,I_set2_shape],[],[],[O_result_indices,O_result_values,O_result_shape],['set_operation','validate_indices','T'],['string','bool','type'],[@A_set_operation,@A_validate_indices,@A_T])
  end;
function TGraphExt.AddSpence(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Spence',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSplit(const I_split_dim:string; const I_value:string; const OL_output:string; const A_num_split:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Split',[I_split_dim,I_value],[],[],[OL_output],['num_split','T'],['int','type'],[@A_num_split,@A_T])
  end;
function TGraphExt.AddSplitV(const I_value:string; const I_size_splits:string; const I_split_dim:string; const OL_output:string; const A_num_split:cint64; const A_T:TF_DataType; const A_Tlen:TF_DataType):string;
  begin
  result:=AddOper('SplitV',[I_value,I_size_splits,I_split_dim],[],[],[OL_output],['num_split','T','Tlen'],['int','type','type'],[@A_num_split,@A_T,@A_Tlen])
  end;
function TGraphExt.AddSqlDataset(const I_driver_name:string; const I_data_source_name:string; const I_query:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('SqlDataset',[I_driver_name,I_data_source_name,I_query],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddSqrt(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sqrt',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSqrtGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SqrtGrad',[I_y,I_dy],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSquare(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Square',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSquaredDifference(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('SquaredDifference',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSqueeze(const I_input:string; const O_output:string; const A_T:TF_DataType; const A_squeeze_dims:TF_IntList):string;
  begin
  result:=AddOper('Squeeze',[I_input],[],[],[O_output],['T','squeeze_dims'],['type','list(int)'],[@A_T,@A_squeeze_dims])
  end;
function TGraphExt.AddStack(const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
  begin
  result:=AddOper('Stack',[],[],[],[O_handle],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name])
  end;
function TGraphExt.AddStackClose(const I_handle:string):string;
  begin
  result:=AddOper('StackClose',[I_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddStackCloseV2(const I_handle:string):string;
  begin
  result:=AddOper('StackCloseV2',[I_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddStackPop(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
  begin
  result:=AddOper('StackPop',[I_handle],[],[],[O_elem],['elem_type'],['type'],[@A_elem_type])
  end;
function TGraphExt.AddStackPopV2(const I_handle:string; const O_elem:string; const A_elem_type:TF_DataType):string;
  begin
  result:=AddOper('StackPopV2',[I_handle],[],[],[O_elem],['elem_type'],['type'],[@A_elem_type])
  end;
function TGraphExt.AddStackPush(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
  begin
  result:=AddOper('StackPush',[I_handle,I_elem],[],[],[O_output],['T','swap_memory'],['type','bool'],[@A_T,@A_swap_memory])
  end;
function TGraphExt.AddStackPushV2(const I_handle:string; const I_elem:string; const O_output:string; const A_T:TF_DataType; const A_swap_memory:boolean):string;
  begin
  result:=AddOper('StackPushV2',[I_handle,I_elem],[],[],[O_output],['T','swap_memory'],['type','bool'],[@A_T,@A_swap_memory])
  end;
function TGraphExt.AddStackV2(const I_max_size:string; const O_handle:string; const A_elem_type:TF_DataType; const A_stack_name:string):string;
  begin
  result:=AddOper('StackV2',[I_max_size],[],[],[O_handle],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name])
  end;
function TGraphExt.AddStage(const IL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Stage',[],[IL_values],[Length(A_dtypes)],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStageClear(const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StageClear',[],[],[],[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStagePeek(const I_index:string; const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StagePeek',[I_index],[],[],[OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStageSize(const O_size:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StageSize',[],[],[],[O_size],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddStatefulPartitionedCall(const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function; const A_config:string; const A_config_proto:string; const A_executor_type:string):string;
  begin
  result:=AddOper('StatefulPartitionedCall',[],[IL_args],[Length(A_Tin)],[OL_output],['Tin','Tout','f','config','config_proto','executor_type'],['list(type)','list(type)','func','string','string','string'],[@A_Tin,@A_Tout,@A_f,@A_config,@A_config_proto,@A_executor_type])
  end;
function TGraphExt.AddStatefulRandomBinomial(const I_resource:string; const I_algorithm:string; const I_shape:string; const I_counts:string; const I_probs:string; const O_output:string; const A_S:TF_DataType; const A_T:TF_DataType; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulRandomBinomial',[I_resource,I_algorithm,I_shape,I_counts,I_probs],[],[],[O_output],['S','T','dtype'],['type','type','type'],[@A_S,@A_T,@A_dtype])
  end;
function TGraphExt.AddStatefulStandardNormal(const I_resource:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulStandardNormal',[I_resource,I_shape],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddStatefulStandardNormalV2(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulStandardNormalV2',[I_resource,I_algorithm,I_shape],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddStatefulTruncatedNormal(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulTruncatedNormal',[I_resource,I_algorithm,I_shape],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddStatefulUniform(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulUniform',[I_resource,I_algorithm,I_shape],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddStatefulUniformFullInt(const I_resource:string; const I_algorithm:string; const I_shape:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulUniformFullInt',[I_resource,I_algorithm,I_shape],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddStatefulUniformInt(const I_resource:string; const I_algorithm:string; const I_shape:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_dtype:TF_DataType; const A_shape_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatefulUniformInt',[I_resource,I_algorithm,I_shape,I_minval,I_maxval],[],[],[O_output],['dtype','shape_dtype'],['type','type'],[@A_dtype,@A_shape_dtype])
  end;
function TGraphExt.AddStatelessIf(const I_cond:string; const IL_input:string; const OL_output:string; const A_Tcond:TF_DataType; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_then_branch:TF_Function; const A_else_branch:TF_Function; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('StatelessIf',[I_cond],[IL_input],[Length(A_Tin)],[OL_output],['Tcond','Tin','Tout','then_branch','else_branch','output_shapes'],['type','list(type)','list(type)','func','func','list(shape)'],[@A_Tcond,@A_Tin,@A_Tout,@A_then_branch,@A_else_branch,@A_output_shapes])
  end;
function TGraphExt.AddStatelessMultinomial(const I_logits:string; const I_num_samples:string; const I_seed:string; const O_output:string; const A_T:TF_DataType; const A_Tseed:TF_DataType; const A_output_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatelessMultinomial',[I_logits,I_num_samples,I_seed],[],[],[O_output],['T','Tseed','output_dtype'],['type','type','type'],[@A_T,@A_Tseed,@A_output_dtype])
  end;
function TGraphExt.AddStatelessRandomBinomial(const I_shape:string; const I_seed:string; const I_counts:string; const I_probs:string; const O_output:string; const A_S:TF_DataType; const A_Tseed:TF_DataType; const A_T:TF_DataType; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomBinomial',[I_shape,I_seed,I_counts,I_probs],[],[],[O_output],['S','Tseed','T','dtype'],['type','type','type','type'],[@A_S,@A_Tseed,@A_T,@A_dtype])
  end;
function TGraphExt.AddStatelessRandomGammaV2(const I_shape:string; const I_seed:string; const I_alpha:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomGammaV2',[I_shape,I_seed,I_alpha],[],[],[O_output],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@A_T,@A_Tseed])
  end;
function TGraphExt.AddStatelessRandomNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomNormal',[I_shape,I_seed],[],[],[O_output],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@A_T,@A_Tseed])
  end;
function TGraphExt.AddStatelessRandomPoisson(const I_shape:string; const I_seed:string; const I_lam:string; const O_output:string; const A_Rtype:TF_DataType; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomPoisson',[I_shape,I_seed,I_lam],[],[],[O_output],['Rtype','dtype','T','Tseed'],['type','type','type','type'],[@A_Rtype,@A_dtype,@A_T,@A_Tseed])
  end;
function TGraphExt.AddStatelessRandomUniform(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomUniform',[I_shape,I_seed],[],[],[O_output],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@A_T,@A_Tseed])
  end;
function TGraphExt.AddStatelessRandomUniformInt(const I_shape:string; const I_seed:string; const I_minval:string; const I_maxval:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
  begin
  result:=AddOper('StatelessRandomUniformInt',[I_shape,I_seed,I_minval,I_maxval],[],[],[O_output],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@A_T,@A_Tseed])
  end;
function TGraphExt.AddStatelessTruncatedNormal(const I_shape:string; const I_seed:string; const O_output:string; const A_dtype:TF_DataType; const A_T:TF_DataType; const A_Tseed:TF_DataType):string;
  begin
  result:=AddOper('StatelessTruncatedNormal',[I_shape,I_seed],[],[],[O_output],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@A_T,@A_Tseed])
  end;
function TGraphExt.AddStatelessWhile(const IL_input:string; const OL_output:string; const A_T:TF_TypeList; const A_cond:TF_Function; const A_body:TF_Function; const A_output_shapes:TF_ShapeList; const A_parallel_iterations:cint64):string;
  begin
  result:=AddOper('StatelessWhile',[],[IL_input],[Length(A_T)],[OL_output],['T','cond','body','output_shapes','parallel_iterations'],['list(type)','func','func','list(shape)','int'],[@A_T,@A_cond,@A_body,@A_output_shapes,@A_parallel_iterations])
  end;
function TGraphExt.AddStaticRegexFullMatch(const I_input:string; const O_output:string; const A_pattern:string):string;
  begin
  result:=AddOper('StaticRegexFullMatch',[I_input],[],[],[O_output],['pattern'],['string'],[@A_pattern])
  end;
function TGraphExt.AddStaticRegexReplace(const I_input:string; const O_output:string; const A_pattern:string; const A_rewrite:string; const A_replace_global:boolean):string;
  begin
  result:=AddOper('StaticRegexReplace',[I_input],[],[],[O_output],['pattern','rewrite','replace_global'],['string','string','bool'],[@A_pattern,@A_rewrite,@A_replace_global])
  end;
function TGraphExt.AddStatsAggregatorHandle(const O_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StatsAggregatorHandle',[],[],[],[O_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddStatsAggregatorHandleV2(const O_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('StatsAggregatorHandleV2',[],[],[],[O_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddStatsAggregatorSetSummaryWriter(const I_stats_aggregator:string; const I_summary:string):string;
  begin
  result:=AddOper('StatsAggregatorSetSummaryWriter',[I_stats_aggregator,I_summary],[],[],[],[],[],[])
  end;
function TGraphExt.AddStatsAggregatorSummary(const I_iterator:string; const O_summary:string):string;
  begin
  result:=AddOper('StatsAggregatorSummary',[I_iterator],[],[],[O_summary],[],[],[])
  end;
function TGraphExt.AddStopGradient(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('StopGradient',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddStridedSlice(const I_input:string; const I_begin:string; const I_end:string; const I_strides:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('StridedSlice',[I_input,I_begin,I_end,I_strides],[],[],[O_output],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddStridedSliceAssign(const I_ref:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const O_output_ref:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('StridedSliceAssign',[I_ref,I_begin,I_end,I_strides,I_value],[],[],[O_output_ref],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddStridedSliceGrad(const I_shape:string; const I_begin:string; const I_end:string; const I_strides:string; const I_dy:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('StridedSliceGrad',[I_shape,I_begin,I_end,I_strides,I_dy],[],[],[O_output],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddStringFormat(const IL_inputs:string; const O_output:string; const A_T:TF_TypeList; const A_template:string; const A_placeholder:string; const A_summarize:cint64):string;
  begin
  result:=AddOper('StringFormat',[],[IL_inputs],[Length(A_T)],[O_output],['T','template','placeholder','summarize'],['list(type)','string','string','int'],[@A_T,@A_template,@A_placeholder,@A_summarize])
  end;
function TGraphExt.AddStringJoin(const IL_inputs:string; const O_output:string; const A_N:cint64; const A_separator:string):string;
  begin
  result:=AddOper('StringJoin',[],[IL_inputs],[A_N],[O_output],['N','separator'],['int','string'],[@A_N,@A_separator])
  end;
function TGraphExt.AddStringLength(const I_input:string; const O_output:string; const A_unit:string):string;
  begin
  result:=AddOper('StringLength',[I_input],[],[],[O_output],['unit'],['string'],[@A_unit])
  end;
function TGraphExt.AddStringLower(const I_input:string; const O_output:string; const A_encoding:string):string;
  begin
  result:=AddOper('StringLower',[I_input],[],[],[O_output],['encoding'],['string'],[@A_encoding])
  end;
function TGraphExt.AddStringNGrams(const I_data:string; const I_data_splits:string; const O_ngrams:string; const O_ngrams_splits:string; const A_separator:string; const A_ngram_widths:TF_IntList; const A_left_pad:string; const A_right_pad:string; const A_pad_width:cint64; const A_preserve_short_sequences:boolean; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('StringNGrams',[I_data,I_data_splits],[],[],[O_ngrams,O_ngrams_splits],['separator','ngram_widths','left_pad','right_pad','pad_width','preserve_short_sequences','Tsplits'],['string','list(int)','string','string','int','bool','type'],[@A_separator,@A_ngram_widths,@A_left_pad,@A_right_pad,@A_pad_width,@A_preserve_short_sequences,@A_Tsplits])
  end;
function TGraphExt.AddStringSplit(const I_input:string; const I_delimiter:string; const O_indices:string; const O_values:string; const O_shape:string; const A_skip_empty:boolean):string;
  begin
  result:=AddOper('StringSplit',[I_input,I_delimiter],[],[],[O_indices,O_values,O_shape],['skip_empty'],['bool'],[@A_skip_empty])
  end;
function TGraphExt.AddStringSplitV2(const I_input:string; const I_sep:string; const O_indices:string; const O_values:string; const O_shape:string; const A_maxsplit:cint64):string;
  begin
  result:=AddOper('StringSplitV2',[I_input,I_sep],[],[],[O_indices,O_values,O_shape],['maxsplit'],['int'],[@A_maxsplit])
  end;
function TGraphExt.AddStringStrip(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('StringStrip',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddStringToHashBucket(const I_string_tensor:string; const O_output:string; const A_num_buckets:cint64):string;
  begin
  result:=AddOper('StringToHashBucket',[I_string_tensor],[],[],[O_output],['num_buckets'],['int'],[@A_num_buckets])
  end;
function TGraphExt.AddStringToHashBucketFast(const I_input:string; const O_output:string; const A_num_buckets:cint64):string;
  begin
  result:=AddOper('StringToHashBucketFast',[I_input],[],[],[O_output],['num_buckets'],['int'],[@A_num_buckets])
  end;
function TGraphExt.AddStringToHashBucketStrong(const I_input:string; const O_output:string; const A_num_buckets:cint64; const A_key:TF_IntList):string;
  begin
  result:=AddOper('StringToHashBucketStrong',[I_input],[],[],[O_output],['num_buckets','key'],['int','list(int)'],[@A_num_buckets,@A_key])
  end;
function TGraphExt.AddStringToNumber(const I_string_tensor:string; const O_output:string; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('StringToNumber',[I_string_tensor],[],[],[O_output],['out_type'],['type'],[@A_out_type])
  end;
function TGraphExt.AddStringUpper(const I_input:string; const O_output:string; const A_encoding:string):string;
  begin
  result:=AddOper('StringUpper',[I_input],[],[],[O_output],['encoding'],['string'],[@A_encoding])
  end;
function TGraphExt.AddSub(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Sub',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSubstr(const I_input:string; const I_pos:string; const I_len:string; const O_output:string; const A_T:TF_DataType; const A_unit:string):string;
  begin
  result:=AddOper('Substr',[I_input,I_pos,I_len],[],[],[O_output],['T','unit'],['type','string'],[@A_T,@A_unit])
  end;
function TGraphExt.AddSum(const I_input:string; const I_reduction_indices:string; const O_output:string; const A_keep_dims:boolean; const A_T:TF_DataType; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('Sum',[I_input,I_reduction_indices],[],[],[O_output],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@A_T,@A_Tidx])
  end;
function TGraphExt.AddSummaryWriter(const O_writer:string; const A_shared_name:string; const A_container:string):string;
  begin
  result:=AddOper('SummaryWriter',[],[],[],[O_writer],['shared_name','container'],['string','string'],[@A_shared_name,@A_container])
  end;
function TGraphExt.AddSvd(const I_input:string; const O_s:string; const O_u:string; const O_v:string; const A_compute_uv:boolean; const A_full_matrices:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Svd',[I_input],[],[],[O_s,O_u,O_v],['compute_uv','full_matrices','T'],['bool','bool','type'],[@A_compute_uv,@A_full_matrices,@A_T])
  end;
function TGraphExt.AddSwitch(const I_data:string; const I_pred:string; const O_output_false:string; const O_output_true:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Switch',[I_data,I_pred],[],[],[O_output_false,O_output_true],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddSymbolicGradient(const IL_input:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function):string;
  begin
  result:=AddOper('SymbolicGradient',[],[IL_input],[Length(A_Tin)],[OL_output],['Tin','Tout','f'],['list(type)','list(type)','func'],[@A_Tin,@A_Tout,@A_f])
  end;
function TGraphExt.AddTFRecordDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const O_handle:string):string;
  begin
  result:=AddOper('TFRecordDataset',[I_filenames,I_compression_type,I_buffer_size],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddTFRecordReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
  begin
  result:=AddOper('TFRecordReader',[],[],[],[O_reader_handle],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type])
  end;
function TGraphExt.AddTFRecordReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string; const A_compression_type:string):string;
  begin
  result:=AddOper('TFRecordReaderV2',[],[],[],[O_reader_handle],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type])
  end;
function TGraphExt.AddTPUCompilationResult(const O_output:string):string;
  begin
  result:=AddOper('TPUCompilationResult',[],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddTPUEmbeddingActivations(const I_embedding_variable:string; const I_sliced_activations:string; const O_output:string; const A_table_id:cint64; const A_lookup_id:cint64):string;
  begin
  result:=AddOper('TPUEmbeddingActivations',[I_embedding_variable,I_sliced_activations],[],[],[O_output],['table_id','lookup_id'],['int','int'],[@A_table_id,@A_lookup_id])
  end;
function TGraphExt.AddTPUOrdinalSelector(const O_device_ordinals:string):string;
  begin
  result:=AddOper('TPUOrdinalSelector',[],[],[],[O_device_ordinals],[],[],[])
  end;
function TGraphExt.AddTPUPartitionedCall(const I_device_ordinal:string; const IL_args:string; const OL_output:string; const A_Tin:TF_TypeList; const A_Tout:TF_TypeList; const A_f:TF_Function; const A_autotuner_thresh:cint64):string;
  begin
  result:=AddOper('TPUPartitionedCall',[I_device_ordinal],[IL_args],[Length(A_Tin)],[OL_output],['Tin','Tout','f','autotuner_thresh'],['list(type)','list(type)','func','int'],[@A_Tin,@A_Tout,@A_f,@A_autotuner_thresh])
  end;
function TGraphExt.AddTPUReplicateMetadata(const A_num_replicas:cint64; const A_num_cores_per_replica:cint64; const A_topology:string; const A_use_tpu:boolean; const A_device_assignment:TF_IntList; const A_computation_shape:TF_IntList; const A_host_compute_core:TF_StringList; const A_padding_map:TF_StringList; const A_step_marker_location:string; const A_allow_soft_placement:boolean):string;
  begin
  result:=AddOper('TPUReplicateMetadata',[],[],[],[],['num_replicas','num_cores_per_replica','topology','use_tpu','device_assignment','computation_shape','host_compute_core','padding_map','step_marker_location','allow_soft_placement'],['int','int','string','bool','list(int)','list(int)','list(string)','list(string)','string','bool'],[@A_num_replicas,@A_num_cores_per_replica,@A_topology,@A_use_tpu,@A_device_assignment,@A_computation_shape,@A_host_compute_core,@A_padding_map,@A_step_marker_location,@A_allow_soft_placement])
  end;
function TGraphExt.AddTPUReplicatedInput(const IL_inputs:string; const O_output:string; const A_N:cint64; const A_T:TF_DataType; const A_is_mirrored_variable:boolean; const A_index:cint64):string;
  begin
  result:=AddOper('TPUReplicatedInput',[],[IL_inputs],[A_N],[O_output],['N','T','is_mirrored_variable','index'],['int','type','bool','int'],[@A_N,@A_T,@A_is_mirrored_variable,@A_index])
  end;
function TGraphExt.AddTPUReplicatedOutput(const I_input:string; const OL_outputs:string; const A_num_replicas:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TPUReplicatedOutput',[I_input],[],[],[OL_outputs],['num_replicas','T'],['int','type'],[@A_num_replicas,@A_T])
  end;
function TGraphExt.AddTakeDataset(const I_input_dataset:string; const I_count:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TakeDataset',[I_input_dataset,I_count],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddTakeManySparseFromTensorsMap(const I_sparse_handles:string; const O_sparse_indices:string; const O_sparse_values:string; const O_sparse_shape:string; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TakeManySparseFromTensorsMap',[I_sparse_handles],[],[],[O_sparse_indices,O_sparse_values,O_sparse_shape],['dtype','container','shared_name'],['type','string','string'],[@A_dtype,@A_container,@A_shared_name])
  end;
function TGraphExt.AddTakeWhileDataset(const I_input_dataset:string; const IL_other_arguments:string; const O_handle:string; const A_predicate:TF_Function; const A_Targuments:TF_TypeList; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TakeWhileDataset',[I_input_dataset],[IL_other_arguments],[Length(A_Targuments)],[O_handle],['predicate','Targuments','output_types','output_shapes'],['func','list(type)','list(type)','list(shape)'],[@A_predicate,@A_Targuments,@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddTan(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Tan',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTanh(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Tanh',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTanhGrad(const I_y:string; const I_dy:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TanhGrad',[I_y,I_dy],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTemporaryVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):string;
  begin
  result:=AddOper('TemporaryVariable',[],[],[],[O_ref],['shape','dtype','var_name'],['shape','type','string'],[@A_shape,@A_dtype,@A_var_name])
  end;
function TGraphExt.AddTensorArray(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArray',[I_size],[],[],[O_handle],['dtype','dynamic_size','clear_after_read','tensor_array_name','element_shape'],['type','bool','bool','string','shape'],[@A_dtype,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayClose(const I_handle:string):string;
  begin
  result:=AddOper('TensorArrayClose',[I_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddTensorArrayCloseV2(const I_handle:string):string;
  begin
  result:=AddOper('TensorArrayCloseV2',[I_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddTensorArrayCloseV3(const I_handle:string):string;
  begin
  result:=AddOper('TensorArrayCloseV3',[I_handle],[],[],[],[],[],[])
  end;
function TGraphExt.AddTensorArrayConcat(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayConcat',[I_handle,I_flow_in],[],[],[O_value,O_lengths],['dtype','element_shape_except0'],['type','shape'],[@A_dtype,@A_element_shape_except0])
  end;
function TGraphExt.AddTensorArrayConcatV2(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayConcatV2',[I_handle,I_flow_in],[],[],[O_value,O_lengths],['dtype','element_shape_except0'],['type','shape'],[@A_dtype,@A_element_shape_except0])
  end;
function TGraphExt.AddTensorArrayConcatV3(const I_handle:string; const I_flow_in:string; const O_value:string; const O_lengths:string; const A_dtype:TF_DataType; const A_element_shape_except0:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayConcatV3',[I_handle,I_flow_in],[],[],[O_value,O_lengths],['dtype','element_shape_except0'],['type','shape'],[@A_dtype,@A_element_shape_except0])
  end;
function TGraphExt.AddTensorArrayGather(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayGather',[I_handle,I_indices,I_flow_in],[],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayGatherV2(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayGatherV2',[I_handle,I_indices,I_flow_in],[],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayGatherV3(const I_handle:string; const I_indices:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayGatherV3',[I_handle,I_indices,I_flow_in],[],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayGrad(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGrad',[I_handle,I_flow_in],[],[],[O_grad_handle],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayGradV2(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGradV2',[I_handle,I_flow_in],[],[],[O_grad_handle],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayGradV3(const I_handle:string; const I_flow_in:string; const O_grad_handle:string; const O_flow_out:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGradV3',[I_handle,I_flow_in],[],[],[O_grad_handle,O_flow_out],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayGradWithShape(const I_handle:string; const I_flow_in:string; const I_shape_to_prepend:string; const O_grad_handle:string; const O_flow_out:string; const A_source:string):string;
  begin
  result:=AddOper('TensorArrayGradWithShape',[I_handle,I_flow_in,I_shape_to_prepend],[],[],[O_grad_handle,O_flow_out],['source'],['string'],[@A_source])
  end;
function TGraphExt.AddTensorArrayPack(const I_handle:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorArrayPack',[I_handle,I_flow_in],[],[],[O_value],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorArrayRead(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayRead',[I_handle,I_index,I_flow_in],[],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddTensorArrayReadV2(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayReadV2',[I_handle,I_index,I_flow_in],[],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddTensorArrayReadV3(const I_handle:string; const I_index:string; const I_flow_in:string; const O_value:string; const A_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayReadV3',[I_handle,I_index,I_flow_in],[],[],[O_value],['dtype'],['type'],[@A_dtype])
  end;
function TGraphExt.AddTensorArrayScatter(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayScatter',[I_handle,I_indices,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayScatterV2(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayScatterV2',[I_handle,I_indices,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayScatterV3(const I_handle:string; const I_indices:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayScatterV3',[I_handle,I_indices,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArraySize(const I_handle:string; const I_flow_in:string; const O_size:string):string;
  begin
  result:=AddOper('TensorArraySize',[I_handle,I_flow_in],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddTensorArraySizeV2(const I_handle:string; const I_flow_in:string; const O_size:string):string;
  begin
  result:=AddOper('TensorArraySizeV2',[I_handle,I_flow_in],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddTensorArraySizeV3(const I_handle:string; const I_flow_in:string; const O_size:string):string;
  begin
  result:=AddOper('TensorArraySizeV3',[I_handle,I_flow_in],[],[],[O_size],[],[],[])
  end;
function TGraphExt.AddTensorArraySplit(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArraySplit',[I_handle,I_value,I_lengths,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArraySplitV2(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArraySplitV2',[I_handle,I_value,I_lengths,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArraySplitV3(const I_handle:string; const I_value:string; const I_lengths:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArraySplitV3',[I_handle,I_value,I_lengths,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayUnpack(const I_handle:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayUnpack',[I_handle,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayV2(const I_size:string; const O_handle:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string):string;
  begin
  result:=AddOper('TensorArrayV2',[I_size],[],[],[O_handle],['dtype','element_shape','dynamic_size','clear_after_read','tensor_array_name'],['type','shape','bool','bool','string'],[@A_dtype,@A_element_shape,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name])
  end;
function TGraphExt.AddTensorArrayV3(const I_size:string; const O_handle:string; const O_flow:string; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_identical_element_shapes:boolean; const A_tensor_array_name:string):string;
  begin
  result:=AddOper('TensorArrayV3',[I_size],[],[],[O_handle,O_flow],['dtype','element_shape','dynamic_size','clear_after_read','identical_element_shapes','tensor_array_name'],['type','shape','bool','bool','bool','string'],[@A_dtype,@A_element_shape,@A_dynamic_size,@A_clear_after_read,@A_identical_element_shapes,@A_tensor_array_name])
  end;
function TGraphExt.AddTensorArrayWrite(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayWrite',[I_handle,I_index,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayWriteV2(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayWriteV2',[I_handle,I_index,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorArrayWriteV3(const I_handle:string; const I_index:string; const I_value:string; const I_flow_in:string; const O_flow_out:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorArrayWriteV3',[I_handle,I_index,I_value,I_flow_in],[],[],[O_flow_out],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTensorDataset(const IL_components:string; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TensorDataset',[],[IL_components],[Length(A_Toutput_types)],[O_handle],['Toutput_types','output_shapes'],['list(type)','list(shape)'],[@A_Toutput_types,@A_output_shapes])
  end;
function TGraphExt.AddTensorForestCreateTreeVariable(const I_tree_handle:string; const I_tree_config:string):string;
  begin
  result:=AddOper('TensorForestCreateTreeVariable',[I_tree_handle,I_tree_config],[],[],[],[],[],[])
  end;
function TGraphExt.AddTensorForestTreeDeserialize(const I_tree_handle:string; const I_tree_config:string):string;
  begin
  result:=AddOper('TensorForestTreeDeserialize',[I_tree_handle,I_tree_config],[],[],[],[],[],[])
  end;
function TGraphExt.AddTensorForestTreeIsInitializedOp(const I_tree_handle:string; const O_is_initialized:string):string;
  begin
  result:=AddOper('TensorForestTreeIsInitializedOp',[I_tree_handle],[],[],[O_is_initialized],[],[],[])
  end;
function TGraphExt.AddTensorForestTreePredict(const I_tree_handle:string; const I_dense_features:string; const O_logits:string; const A_logits_dimension:cint64):string;
  begin
  result:=AddOper('TensorForestTreePredict',[I_tree_handle,I_dense_features],[],[],[O_logits],['logits_dimension'],['int'],[@A_logits_dimension])
  end;
function TGraphExt.AddTensorForestTreeResourceHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TensorForestTreeResourceHandleOp',[],[],[],[O_resource],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddTensorForestTreeSerialize(const I_tree_handle:string; const O_tree_config:string):string;
  begin
  result:=AddOper('TensorForestTreeSerialize',[I_tree_handle],[],[],[O_tree_config],[],[],[])
  end;
function TGraphExt.AddTensorForestTreeSize(const I_tree_handle:string; const O_tree_size:string):string;
  begin
  result:=AddOper('TensorForestTreeSize',[I_tree_handle],[],[],[O_tree_size],[],[],[])
  end;
function TGraphExt.AddTensorListConcat(const I_input_handle:string; const O_tensor:string; const O_lengths:string; const A_element_dtype:TF_DataType; const A_element_shape:TF_Shape):string;
  begin
  result:=AddOper('TensorListConcat',[I_input_handle],[],[],[O_tensor,O_lengths],['element_dtype','element_shape'],['type','shape'],[@A_element_dtype,@A_element_shape])
  end;
function TGraphExt.AddTensorListConcatLists(const I_input_a:string; const I_input_b:string; const O_output:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListConcatLists',[I_input_a,I_input_b],[],[],[O_output],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListConcatV2(const I_input_handle:string; const I_element_shape:string; const I_leading_dims:string; const O_tensor:string; const O_lengths:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListConcatV2',[I_input_handle,I_element_shape,I_leading_dims],[],[],[O_tensor,O_lengths],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddTensorListElementShape(const I_input_handle:string; const O_element_shape:string; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListElementShape',[I_input_handle],[],[],[O_element_shape],['shape_type'],['type'],[@A_shape_type])
  end;
function TGraphExt.AddTensorListFromTensor(const I_tensor:string; const I_element_shape:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListFromTensor',[I_tensor,I_element_shape],[],[],[O_output_handle],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddTensorListGather(const I_input_handle:string; const I_indices:string; const I_element_shape:string; const O_values:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListGather',[I_input_handle,I_indices,I_element_shape],[],[],[O_values],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListGetItem(const I_input_handle:string; const I_index:string; const I_element_shape:string; const O_item:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListGetItem',[I_input_handle,I_index,I_element_shape],[],[],[O_item],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListLength(const I_input_handle:string; const O_length:string):string;
  begin
  result:=AddOper('TensorListLength',[I_input_handle],[],[],[O_length],[],[],[])
  end;
function TGraphExt.AddTensorListPopBack(const I_input_handle:string; const I_element_shape:string; const O_output_handle:string; const O_tensor:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListPopBack',[I_input_handle,I_element_shape],[],[],[O_output_handle,O_tensor],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListPushBack(const I_input_handle:string; const I_tensor:string; const O_output_handle:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListPushBack',[I_input_handle,I_tensor],[],[],[O_output_handle],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListPushBackBatch(const I_input_handles:string; const I_tensor:string; const O_output_handles:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListPushBackBatch',[I_input_handles,I_tensor],[],[],[O_output_handles],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListReserve(const I_element_shape:string; const I_num_elements:string; const O_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListReserve',[I_element_shape,I_num_elements],[],[],[O_handle],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddTensorListResize(const I_input_handle:string; const I_size:string; const O_output_handle:string):string;
  begin
  result:=AddOper('TensorListResize',[I_input_handle,I_size],[],[],[O_output_handle],[],[],[])
  end;
function TGraphExt.AddTensorListScatter(const I_tensor:string; const I_indices:string; const I_element_shape:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListScatter',[I_tensor,I_indices,I_element_shape],[],[],[O_output_handle],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddTensorListScatterIntoExistingList(const I_input_handle:string; const I_tensor:string; const I_indices:string; const O_output_handle:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListScatterIntoExistingList',[I_input_handle,I_tensor,I_indices],[],[],[O_output_handle],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListScatterV2(const I_tensor:string; const I_indices:string; const I_element_shape:string; const I_num_elements:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListScatterV2',[I_tensor,I_indices,I_element_shape,I_num_elements],[],[],[O_output_handle],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddTensorListSetItem(const I_input_handle:string; const I_index:string; const I_item:string; const O_output_handle:string; const A_element_dtype:TF_DataType):string;
  begin
  result:=AddOper('TensorListSetItem',[I_input_handle,I_index,I_item],[],[],[O_output_handle],['element_dtype'],['type'],[@A_element_dtype])
  end;
function TGraphExt.AddTensorListSplit(const I_tensor:string; const I_element_shape:string; const I_lengths:string; const O_output_handle:string; const A_element_dtype:TF_DataType; const A_shape_type:TF_DataType):string;
  begin
  result:=AddOper('TensorListSplit',[I_tensor,I_element_shape,I_lengths],[],[],[O_output_handle],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@A_shape_type])
  end;
function TGraphExt.AddTensorListStack(const I_input_handle:string; const I_element_shape:string; const O_tensor:string; const A_element_dtype:TF_DataType; const A_num_elements:cint64):string;
  begin
  result:=AddOper('TensorListStack',[I_input_handle,I_element_shape],[],[],[O_tensor],['element_dtype','num_elements'],['type','int'],[@A_element_dtype,@A_num_elements])
  end;
function TGraphExt.AddTensorScatterAdd(const I_tensor:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('TensorScatterAdd',[I_tensor,I_indices,I_updates],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddTensorScatterSub(const I_tensor:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('TensorScatterSub',[I_tensor,I_indices,I_updates],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddTensorScatterUpdate(const I_tensor:string; const I_indices:string; const I_updates:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType):string;
  begin
  result:=AddOper('TensorScatterUpdate',[I_tensor,I_indices,I_updates],[],[],[O_output],['T','Tindices'],['type','type'],[@A_T,@A_Tindices])
  end;
function TGraphExt.AddTensorSliceDataset(const IL_components:string; const O_handle:string; const A_Toutput_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('TensorSliceDataset',[],[IL_components],[Length(A_Toutput_types)],[O_handle],['Toutput_types','output_shapes'],['list(type)','list(shape)'],[@A_Toutput_types,@A_output_shapes])
  end;
function TGraphExt.AddTensorStridedSliceUpdate(const I_input:string; const I_begin:string; const I_end:string; const I_strides:string; const I_value:string; const O_output:string; const A_T:TF_DataType; const A_Index:TF_DataType; const A_begin_mask:cint64; const A_end_mask:cint64; const A_ellipsis_mask:cint64; const A_new_axis_mask:cint64; const A_shrink_axis_mask:cint64):string;
  begin
  result:=AddOper('TensorStridedSliceUpdate',[I_input,I_begin,I_end,I_strides,I_value],[],[],[O_output],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@A_T,@A_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask])
  end;
function TGraphExt.AddTensorSummary(const I_tensor:string; const O_summary:string; const A_T:TF_DataType; const A_description:string; const A_labels:TF_StringList; const A_display_name:string):string;
  begin
  result:=AddOper('TensorSummary',[I_tensor],[],[],[O_summary],['T','description','labels','display_name'],['type','string','list(string)','string'],[@A_T,@A_description,@A_labels,@A_display_name])
  end;
function TGraphExt.AddTensorSummaryV2(const I_tag:string; const I_tensor:string; const I_serialized_summary_metadata:string; const O_summary:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TensorSummaryV2',[I_tag,I_tensor,I_serialized_summary_metadata],[],[],[O_summary],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTextLineDataset(const I_filenames:string; const I_compression_type:string; const I_buffer_size:string; const O_handle:string):string;
  begin
  result:=AddOper('TextLineDataset',[I_filenames,I_compression_type,I_buffer_size],[],[],[O_handle],[],[],[])
  end;
function TGraphExt.AddTextLineReader(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TextLineReader',[],[],[],[O_reader_handle],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name])
  end;
function TGraphExt.AddTextLineReaderV2(const O_reader_handle:string; const A_skip_header_lines:cint64; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('TextLineReaderV2',[],[],[],[O_reader_handle],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name])
  end;
function TGraphExt.AddThreadPoolDataset(const I_input_dataset:string; const I_thread_pool:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('ThreadPoolDataset',[I_input_dataset,I_thread_pool],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddThreadPoolHandle(const O_handle:string; const A_num_threads:cint64; const A_max_intra_op_parallelism:cint64; const A_display_name:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('ThreadPoolHandle',[],[],[],[O_handle],['num_threads','max_intra_op_parallelism','display_name','container','shared_name'],['int','int','string','string','string'],[@A_num_threads,@A_max_intra_op_parallelism,@A_display_name,@A_container,@A_shared_name])
  end;
function TGraphExt.AddThreadUnsafeUnigramCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('ThreadUnsafeUnigramCandidateSampler',[I_true_classes],[],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddTile(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType; const A_Tmultiples:TF_DataType):string;
  begin
  result:=AddOper('Tile',[I_input,I_multiples],[],[],[O_output],['T','Tmultiples'],['type','type'],[@A_T,@A_Tmultiples])
  end;
function TGraphExt.AddTileGrad(const I_input:string; const I_multiples:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TileGrad',[I_input,I_multiples],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTimestamp(const O_ts:string):string;
  begin
  result:=AddOper('Timestamp',[],[],[],[O_ts],[],[],[])
  end;
function TGraphExt.AddToBool(const I_input:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ToBool',[I_input],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTopK(const I_input:string; const O_values:string; const O_indices:string; const A_k:cint64; const A_sorted:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TopK',[I_input],[],[],[O_values,O_indices],['k','sorted','T'],['int','bool','type'],[@A_k,@A_sorted,@A_T])
  end;
function TGraphExt.AddTopKV2(const I_input:string; const I_k:string; const O_values:string; const O_indices:string; const A_sorted:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TopKV2',[I_input,I_k],[],[],[O_values,O_indices],['sorted','T'],['bool','type'],[@A_sorted,@A_T])
  end;
function TGraphExt.AddTranspose(const I_x:string; const I_perm:string; const O_y:string; const A_T:TF_DataType; const A_Tperm:TF_DataType):string;
  begin
  result:=AddOper('Transpose',[I_x,I_perm],[],[],[O_y],['T','Tperm'],['type','type'],[@A_T,@A_Tperm])
  end;
function TGraphExt.AddTridiagonalMatMul(const I_superdiag:string; const I_maindiag:string; const I_subdiag:string; const I_rhs:string; const O_output:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TridiagonalMatMul',[I_superdiag,I_maindiag,I_subdiag,I_rhs],[],[],[O_output],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTridiagonalSolve(const I_diagonals:string; const I_rhs:string; const O_output:string; const A_partial_pivoting:boolean; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TridiagonalSolve',[I_diagonals,I_rhs],[],[],[O_output],['partial_pivoting','T'],['bool','type'],[@A_partial_pivoting,@A_T])
  end;
function TGraphExt.AddTruncateDiv(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TruncateDiv',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTruncateMod(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TruncateMod',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddTruncatedNormal(const I_shape:string; const O_output:string; const A_seed:cint64; const A_seed2:cint64; const A_dtype:TF_DataType; const A_T:TF_DataType):string;
  begin
  result:=AddOper('TruncatedNormal',[I_shape],[],[],[O_output],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@A_T])
  end;
function TGraphExt.AddTryRpc(const I_address:string; const I_method:string; const I_request:string; const O_response:string; const O_status_code:string; const O_status_message:string; const A_protocol:string; const A_fail_fast:boolean; const A_timeout_in_ms:cint64):string;
  begin
  result:=AddOper('TryRpc',[I_address,I_method,I_request],[],[],[O_response,O_status_code,O_status_message],['protocol','fail_fast','timeout_in_ms'],['string','bool','int'],[@A_protocol,@A_fail_fast,@A_timeout_in_ms])
  end;
function TGraphExt.AddUnbatch(const I_batched_tensor:string; const I_batch_index:string; const I_id:string; const O_unbatched_tensor:string; const A_timeout_micros:cint64; const A_container:string; const A_shared_name:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Unbatch',[I_batched_tensor,I_batch_index,I_id],[],[],[O_unbatched_tensor],['timeout_micros','container','shared_name','T'],['int','string','string','type'],[@A_timeout_micros,@A_container,@A_shared_name,@A_T])
  end;
function TGraphExt.AddUnbatchDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('UnbatchDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddUnbatchGrad(const I_original_input:string; const I_batch_index:string; const I_grad:string; const I_id:string; const O_batched_grad:string; const A_container:string; const A_shared_name:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('UnbatchGrad',[I_original_input,I_batch_index,I_grad,I_id],[],[],[O_batched_grad],['container','shared_name','T'],['string','string','type'],[@A_container,@A_shared_name,@A_T])
  end;
function TGraphExt.AddUnicodeDecode(const I_input:string; const O_row_splits:string; const O_char_values:string; const A_input_encoding:string; const A_errors:string; const A_replacement_char:cint64; const A_replace_control_characters:boolean; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('UnicodeDecode',[I_input],[],[],[O_row_splits,O_char_values],['input_encoding','errors','replacement_char','replace_control_characters','Tsplits'],['string','string','int','bool','type'],[@A_input_encoding,@A_errors,@A_replacement_char,@A_replace_control_characters,@A_Tsplits])
  end;
function TGraphExt.AddUnicodeDecodeWithOffsets(const I_input:string; const O_row_splits:string; const O_char_values:string; const O_char_to_byte_starts:string; const A_input_encoding:string; const A_errors:string; const A_replacement_char:cint64; const A_replace_control_characters:boolean; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('UnicodeDecodeWithOffsets',[I_input],[],[],[O_row_splits,O_char_values,O_char_to_byte_starts],['input_encoding','errors','replacement_char','replace_control_characters','Tsplits'],['string','string','int','bool','type'],[@A_input_encoding,@A_errors,@A_replacement_char,@A_replace_control_characters,@A_Tsplits])
  end;
function TGraphExt.AddUnicodeEncode(const I_input_values:string; const I_input_splits:string; const O_output:string; const A_errors:string; const A_output_encoding:string; const A_replacement_char:cint64; const A_Tsplits:TF_DataType):string;
  begin
  result:=AddOper('UnicodeEncode',[I_input_values,I_input_splits],[],[],[O_output],['errors','output_encoding','replacement_char','Tsplits'],['string','string','int','type'],[@A_errors,@A_output_encoding,@A_replacement_char,@A_Tsplits])
  end;
function TGraphExt.AddUnicodeScript(const I_input:string; const O_output:string):string;
  begin
  result:=AddOper('UnicodeScript',[I_input],[],[],[O_output],[],[],[])
  end;
function TGraphExt.AddUnicodeTranscode(const I_input:string; const O_output:string; const A_input_encoding:string; const A_output_encoding:string; const A_errors:string; const A_replacement_char:cint64; const A_replace_control_characters:boolean):string;
  begin
  result:=AddOper('UnicodeTranscode',[I_input],[],[],[O_output],['input_encoding','output_encoding','errors','replacement_char','replace_control_characters'],['string','string','string','int','bool'],[@A_input_encoding,@A_output_encoding,@A_errors,@A_replacement_char,@A_replace_control_characters])
  end;
function TGraphExt.AddUniformCandidateSampler(const I_true_classes:string; const O_sampled_candidates:string; const O_true_expected_count:string; const O_sampled_expected_count:string; const A_num_true:cint64; const A_num_sampled:cint64; const A_unique:boolean; const A_range_max:cint64; const A_seed:cint64; const A_seed2:cint64):string;
  begin
  result:=AddOper('UniformCandidateSampler',[I_true_classes],[],[],[O_sampled_candidates,O_true_expected_count,O_sampled_expected_count],['num_true','num_sampled','unique','range_max','seed','seed2'],['int','int','bool','int','int','int'],[@A_num_true,@A_num_sampled,@A_unique,@A_range_max,@A_seed,@A_seed2])
  end;
function TGraphExt.AddUnique(const I_x:string; const O_y:string; const O_idx:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('Unique',[I_x],[],[],[O_y,O_idx],['T','out_idx'],['type','type'],[@A_T,@A_out_idx])
  end;
function TGraphExt.AddUniqueDataset(const I_input_dataset:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('UniqueDataset',[I_input_dataset],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddUniqueV2(const I_x:string; const I_axis:string; const O_y:string; const O_idx:string; const A_T:TF_DataType; const A_Taxis:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('UniqueV2',[I_x,I_axis],[],[],[O_y,O_idx],['T','Taxis','out_idx'],['type','type','type'],[@A_T,@A_Taxis,@A_out_idx])
  end;
function TGraphExt.AddUniqueWithCounts(const I_x:string; const O_y:string; const O_idx:string; const O_count:string; const A_T:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('UniqueWithCounts',[I_x],[],[],[O_y,O_idx,O_count],['T','out_idx'],['type','type'],[@A_T,@A_out_idx])
  end;
function TGraphExt.AddUniqueWithCountsV2(const I_x:string; const I_axis:string; const O_y:string; const O_idx:string; const O_count:string; const A_T:TF_DataType; const A_Taxis:TF_DataType; const A_out_idx:TF_DataType):string;
  begin
  result:=AddOper('UniqueWithCountsV2',[I_x,I_axis],[],[],[O_y,O_idx,O_count],['T','Taxis','out_idx'],['type','type','type'],[@A_T,@A_Taxis,@A_out_idx])
  end;
function TGraphExt.AddUnpack(const I_value:string; const OL_output:string; const A_num:cint64; const A_T:TF_DataType; const A_axis:cint64):string;
  begin
  result:=AddOper('Unpack',[I_value],[],[],[OL_output],['num','T','axis'],['int','type','int'],[@A_num,@A_T,@A_axis])
  end;
function TGraphExt.AddUnravelIndex(const I_indices:string; const I_dims:string; const O_output:string; const A_Tidx:TF_DataType):string;
  begin
  result:=AddOper('UnravelIndex',[I_indices,I_dims],[],[],[O_output],['Tidx'],['type'],[@A_Tidx])
  end;
function TGraphExt.AddUnsortedSegmentJoin(const I_inputs:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_separator:string; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentJoin',[I_inputs,I_segment_ids,I_num_segments],[],[],[O_output],['separator','Tindices','Tnumsegments'],['string','type','type'],[@A_separator,@A_Tindices,@A_Tnumsegments])
  end;
function TGraphExt.AddUnsortedSegmentMax(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentMax',[I_data,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tindices','Tnumsegments'],['type','type','type'],[@A_T,@A_Tindices,@A_Tnumsegments])
  end;
function TGraphExt.AddUnsortedSegmentMin(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentMin',[I_data,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tindices','Tnumsegments'],['type','type','type'],[@A_T,@A_Tindices,@A_Tnumsegments])
  end;
function TGraphExt.AddUnsortedSegmentProd(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentProd',[I_data,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tindices','Tnumsegments'],['type','type','type'],[@A_T,@A_Tindices,@A_Tnumsegments])
  end;
function TGraphExt.AddUnsortedSegmentSum(const I_data:string; const I_segment_ids:string; const I_num_segments:string; const O_output:string; const A_T:TF_DataType; const A_Tindices:TF_DataType; const A_Tnumsegments:TF_DataType):string;
  begin
  result:=AddOper('UnsortedSegmentSum',[I_data,I_segment_ids,I_num_segments],[],[],[O_output],['T','Tindices','Tnumsegments'],['type','type','type'],[@A_T,@A_Tindices,@A_Tnumsegments])
  end;
function TGraphExt.AddUnstage(const OL_values:string; const A_capacity:cint64; const A_memory_limit:cint64; const A_dtypes:TF_TypeList; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Unstage',[],[],[],[OL_values],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name])
  end;
function TGraphExt.AddUnwrapDatasetVariant(const I_input_handle:string; const O_output_handle:string):string;
  begin
  result:=AddOper('UnwrapDatasetVariant',[I_input_handle],[],[],[O_output_handle],[],[],[])
  end;
function TGraphExt.AddUpperBound(const I_sorted_inputs:string; const I_values:string; const O_output:string; const A_T:TF_DataType; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('UpperBound',[I_sorted_inputs,I_values],[],[],[O_output],['T','out_type'],['type','type'],[@A_T,@A_out_type])
  end;
function TGraphExt.AddVarHandleOp(const O_resource:string; const A_container:string; const A_shared_name:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):string;
  begin
  result:=AddOper('VarHandleOp',[],[],[],[O_resource],['container','shared_name','dtype','shape'],['string','string','type','shape'],[@A_container,@A_shared_name,@A_dtype,@A_shape])
  end;
function TGraphExt.AddVarIsInitializedOp(const I_resource:string; const O_is_initialized:string):string;
  begin
  result:=AddOper('VarIsInitializedOp',[I_resource],[],[],[O_is_initialized],[],[],[])
  end;
function TGraphExt.AddVariable(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('Variable',[],[],[],[O_ref],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name])
  end;
function TGraphExt.AddVariableShape(const I_input:string; const O_output:string; const A_out_type:TF_DataType):string;
  begin
  result:=AddOper('VariableShape',[I_input],[],[],[O_output],['out_type'],['type'],[@A_out_type])
  end;
function TGraphExt.AddVariableV2(const O_ref:string; const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('VariableV2',[],[],[],[O_ref],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name])
  end;
function TGraphExt.AddWhere(const I_input:string; const O_index:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Where',[I_input],[],[],[O_index],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddWhile(const IL_input:string; const OL_output:string; const A_T:TF_TypeList; const A_cond:TF_Function; const A_body:TF_Function; const A_output_shapes:TF_ShapeList; const A_parallel_iterations:cint64):string;
  begin
  result:=AddOper('While',[],[IL_input],[Length(A_T)],[OL_output],['T','cond','body','output_shapes','parallel_iterations'],['list(type)','func','func','list(shape)','int'],[@A_T,@A_cond,@A_body,@A_output_shapes,@A_parallel_iterations])
  end;
function TGraphExt.AddWholeFileReader(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('WholeFileReader',[],[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddWholeFileReaderV2(const O_reader_handle:string; const A_container:string; const A_shared_name:string):string;
  begin
  result:=AddOper('WholeFileReaderV2',[],[],[],[O_reader_handle],['container','shared_name'],['string','string'],[@A_container,@A_shared_name])
  end;
function TGraphExt.AddWindowDataset(const I_input_dataset:string; const I_size:string; const I_shift:string; const I_stride:string; const I_drop_remainder:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList):string;
  begin
  result:=AddOper('WindowDataset',[I_input_dataset,I_size,I_shift,I_stride,I_drop_remainder],[],[],[O_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes])
  end;
function TGraphExt.AddWorkerHeartbeat(const I_request:string; const O_response:string):string;
  begin
  result:=AddOper('WorkerHeartbeat',[I_request],[],[],[O_response],[],[],[])
  end;
function TGraphExt.AddWrapDatasetVariant(const I_input_handle:string; const O_output_handle:string):string;
  begin
  result:=AddOper('WrapDatasetVariant',[I_input_handle],[],[],[O_output_handle],[],[],[])
  end;
function TGraphExt.AddWriteAudioSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_tensor:string; const I_sample_rate:string; const A_max_outputs:cint64):string;
  begin
  result:=AddOper('WriteAudioSummary',[I_writer,I_step,I_tag,I_tensor,I_sample_rate],[],[],[],['max_outputs'],['int'],[@A_max_outputs])
  end;
function TGraphExt.AddWriteFile(const I_filename:string; const I_contents:string):string;
  begin
  result:=AddOper('WriteFile',[I_filename,I_contents],[],[],[],[],[],[])
  end;
function TGraphExt.AddWriteGraphSummary(const I_writer:string; const I_step:string; const I_tensor:string):string;
  begin
  result:=AddOper('WriteGraphSummary',[I_writer,I_step,I_tensor],[],[],[],[],[],[])
  end;
function TGraphExt.AddWriteHistogramSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_values:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('WriteHistogramSummary',[I_writer,I_step,I_tag,I_values],[],[],[],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddWriteImageSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_tensor:string; const I_bad_color:string; const A_max_images:cint64; const A_T:TF_DataType):string;
  begin
  result:=AddOper('WriteImageSummary',[I_writer,I_step,I_tag,I_tensor,I_bad_color],[],[],[],['max_images','T'],['int','type'],[@A_max_images,@A_T])
  end;
function TGraphExt.AddWriteRawProtoSummary(const I_writer:string; const I_step:string; const I_tensor:string):string;
  begin
  result:=AddOper('WriteRawProtoSummary',[I_writer,I_step,I_tensor],[],[],[],[],[],[])
  end;
function TGraphExt.AddWriteScalarSummary(const I_writer:string; const I_step:string; const I_tag:string; const I_value:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('WriteScalarSummary',[I_writer,I_step,I_tag,I_value],[],[],[],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddWriteSummary(const I_writer:string; const I_step:string; const I_tensor:string; const I_tag:string; const I_summary_metadata:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('WriteSummary',[I_writer,I_step,I_tensor,I_tag,I_summary_metadata],[],[],[],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddXdivy(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Xdivy',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddXlog1py(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Xlog1py',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddXlogy(const I_x:string; const I_y:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Xlogy',[I_x,I_y],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddZerosLike(const I_x:string; const O_y:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('ZerosLike',[I_x],[],[],[O_y],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddZeta(const I_x:string; const I_q:string; const O_z:string; const A_T:TF_DataType):string;
  begin
  result:=AddOper('Zeta',[I_x,I_q],[],[],[O_z],['T'],['type'],[@A_T])
  end;
function TGraphExt.AddZipDataset(const IL_input_datasets:string; const O_handle:string; const A_output_types:TF_TypeList; const A_output_shapes:TF_ShapeList; const A_N:cint64):string;
  begin
  result:=AddOper('ZipDataset',[],[IL_input_datasets],[A_N],[O_handle],['output_types','output_shapes','N'],['list(type)','list(shape)','int'],[@A_output_types,@A_output_shapes,@A_N])
  end;

//  The Exec<oper> methods
function ExecAbs(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Abs',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAccumulatorNumAccumulated(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AccumulatorNumAccumulated',[I_handle],[],[],[],[D_handle])
  end;
function ExecAccumulatorTakeGradient(const I_handle:TF_TensorPtr; const I_num_required:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_num_required:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AccumulatorTakeGradient',[I_handle,I_num_required],['dtype'],['type'],[@A_dtype],[D_handle,D_num_required])
  end;
function ExecAcos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Acos',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAcosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Acosh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAdd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Add',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecAddManySparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('AddManySparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T','container','shared_name'],['type','string','string'],[@F_T,@A_container,@A_shared_name],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecAddSparseToTensorsMap(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('AddSparseToTensorsMap',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T','container','shared_name'],['type','string','string'],[@F_T,@A_container,@A_shared_name],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecAddV2(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('AddV2',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecAdjustContrast(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const I_min_value:TF_TensorPtr; const I_max_value:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false; const D_min_value:boolean=false; const D_max_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('AdjustContrast',[I_images,I_contrast_factor,I_min_value,I_max_value],['T'],['type'],[@F_T],[D_images,D_contrast_factor,D_min_value,D_max_value])
  end;
function ExecAdjustContrastv2(const I_images:TF_TensorPtr; const I_contrast_factor:TF_TensorPtr; const D_images:boolean=false; const D_contrast_factor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('AdjustContrastv2',[I_images,I_contrast_factor],['T'],['type'],[@F_T],[D_images,D_contrast_factor])
  end;
function ExecAdjustHue(const I_images:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_images:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('AdjustHue',[I_images,I_delta],['T'],['type'],[@F_T],[D_images,D_delta])
  end;
function ExecAdjustSaturation(const I_images:TF_TensorPtr; const I_scale:TF_TensorPtr; const D_images:boolean=false; const D_scale:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('AdjustSaturation',[I_images,I_scale],['T'],['type'],[@F_T],[D_images,D_scale])
  end;
function ExecAll(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('All',[I_input,I_reduction_indices],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecAllToAll(const I_input:TF_TensorPtr; const I_group_assignment:TF_TensorPtr; const A_concat_dimension:integer; const A_split_dimension:integer; const A_split_count:integer; const D_input:boolean=false; const D_group_assignment:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('AllToAll',[I_input,I_group_assignment],['T','concat_dimension','split_dimension','split_count'],['type','int','int','int'],[@F_T,@A_concat_dimension,@A_split_dimension,@A_split_count],[D_input,D_group_assignment])
  end;
function ExecAngle(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Angle',[I_input],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_input])
  end;
function ExecAnonymousIterator(const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('AnonymousIterator',[],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[])
  end;
function ExecAny(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Any',[I_input,I_reduction_indices],['keep_dims','Tidx'],['bool','type'],[@A_keep_dims,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecApplyAdaMax(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta1_power:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_beta1:TF_TensorPtr; const I_beta2:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta1_power:boolean=false; const D_lr:boolean=false; const D_beta1:boolean=false; const D_beta2:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdaMax',[I_var,I_m,I_v,I_beta1_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_m,D_v,D_beta1_power,D_lr,D_beta1,D_beta2,D_epsilon,D_grad])
  end;
function ExecApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_accum_update,D_lr,D_rho,D_epsilon,D_grad])
  end;
function ExecApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdagrad',[I_var,I_accum,I_lr,I_grad],['T','use_locking','update_slots'],['type','bool','bool'],[@F_T,@A_use_locking,@A_update_slots],[D_var,D_accum,D_lr,D_grad])
  end;
function ExecApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_lr,I_l1,I_l2,I_global_step],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_gradient_accumulator,D_gradient_squared_accumulator,D_grad,D_lr,D_l1,D_l2,D_global_step])
  end;
function ExecApplyAdagradV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdagradV2',[I_var,I_accum,I_lr,I_epsilon,I_grad],['T','use_locking','update_slots'],['type','bool','bool'],[@F_T,@A_use_locking,@A_update_slots],[D_var,D_accum,D_lr,D_epsilon,D_grad])
  end;
function ExecApplyAdam(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta1_power:TF_TensorPtr; const I_beta2_power:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_beta1:TF_TensorPtr; const I_beta2:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta1_power:boolean=false; const D_beta2_power:boolean=false; const D_lr:boolean=false; const D_beta1:boolean=false; const D_beta2:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAdam',[I_var,I_m,I_v,I_beta1_power,I_beta2_power,I_lr,I_beta1,I_beta2,I_epsilon,I_grad],['T','use_locking','use_nesterov'],['type','bool','bool'],[@F_T,@A_use_locking,@A_use_nesterov],[D_var,D_m,D_v,D_beta1_power,D_beta2_power,D_lr,D_beta1,D_beta2,D_epsilon,D_grad])
  end;
function ExecApplyAddSign(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_sign_decay:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_lr:boolean=false; const D_alpha:boolean=false; const D_sign_decay:boolean=false; const D_beta:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyAddSign',[I_var,I_m,I_lr,I_alpha,I_sign_decay,I_beta,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_m,D_lr,D_alpha,D_sign_decay,D_beta,D_grad])
  end;
function ExecApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_mg,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad])
  end;
function ExecApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_lr_power],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_lr,D_l1,D_l2,D_lr_power])
  end;
function ExecApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_lr,D_l1,D_l2,D_l2_shrinkage,D_lr_power])
  end;
function ExecApplyGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyGradientDescent',[I_var,I_alpha,I_delta],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_alpha,D_delta])
  end;
function ExecApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_momentum],['T','use_locking','use_nesterov'],['type','bool','bool'],[@F_T,@A_use_locking,@A_use_nesterov],[D_var,D_accum,D_lr,D_grad,D_momentum])
  end;
function ExecApplyPowerSign(const I_var:TF_TensorPtr; const I_m:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_logbase:TF_TensorPtr; const I_sign_decay:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_m:boolean=false; const D_lr:boolean=false; const D_logbase:boolean=false; const D_sign_decay:boolean=false; const D_beta:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyPowerSign',[I_var,I_m,I_lr,I_logbase,I_sign_decay,I_beta,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_m,D_lr,D_logbase,D_sign_decay,D_beta,D_grad])
  end;
function ExecApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_accum,D_lr,D_l1,D_l2,D_grad])
  end;
function ExecApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_delta:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_delta],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_alpha,D_l1,D_l2,D_delta])
  end;
function ExecApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  result:=ExecOper('ApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_var,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad])
  end;
function ExecApproximateEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_tolerance:real; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ApproximateEqual',[I_x,I_y],['T','tolerance'],['type','float'],[@F_T,@A_tolerance],[D_x,D_y])
  end;
function ExecArgMax(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_dimension);
  result:=ExecOper('ArgMax',[I_input,I_dimension],['T','Tidx','output_type'],['type','type','type'],[@F_T,@F_Tidx,@A_output_type],[D_input,D_dimension])
  end;
function ExecArgMin(const I_input:TF_TensorPtr; const I_dimension:TF_TensorPtr; const A_output_type:TF_DataType; const D_input:boolean=false; const D_dimension:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_dimension);
  result:=ExecOper('ArgMin',[I_input,I_dimension],['T','Tidx','output_type'],['type','type','type'],[@F_T,@F_Tidx,@A_output_type],[D_input,D_dimension])
  end;
function ExecAsString(const I_input:TF_TensorPtr; const A_precision:integer; const A_scientific:boolean; const A_shortest:boolean; const A_width:integer; const A_fill:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('AsString',[I_input],['T','precision','scientific','shortest','width','fill'],['type','int','bool','bool','int','string'],[@F_T,@A_precision,@A_scientific,@A_shortest,@A_width,@A_fill],[D_input])
  end;
function ExecAsin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Asin',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAsinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Asinh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAssertNextDataset(const I_input_dataset:TF_TensorPtr; const I_transformations:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_transformations:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AssertNextDataset',[I_input_dataset,I_transformations],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_transformations])
  end;
function ExecAssign(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_validate_shape:boolean; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('Assign',[I_ref,I_value],['T','validate_shape','use_locking'],['type','bool','bool'],[@F_T,@A_validate_shape,@A_use_locking],[D_ref,D_value])
  end;
function ExecAssignAdd(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('AssignAdd',[I_ref,I_value],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_ref,D_value])
  end;
function ExecAssignSub(const I_ref:TF_TensorPtr; const I_value:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('AssignSub',[I_ref,I_value],['T','use_locking'],['type','bool'],[@F_T,@A_use_locking],[D_ref,D_value])
  end;
function ExecAtan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Atan',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAtan2(const I_y:TF_TensorPtr; const I_x:TF_TensorPtr; const D_y:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('Atan2',[I_y,I_x],['T'],['type'],[@F_T],[D_y,D_x])
  end;
function ExecAtanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Atanh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecAudioSpectrogram(const I_input:TF_TensorPtr; const A_window_size:integer; const A_stride:integer; const A_magnitude_squared:boolean; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AudioSpectrogram',[I_input],['window_size','stride','magnitude_squared'],['int','int','bool'],[@A_window_size,@A_stride,@A_magnitude_squared],[D_input])
  end;
function ExecAudioSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_sample_rate:real; const A_max_outputs:integer; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AudioSummary',[I_tag,I_tensor],['sample_rate','max_outputs'],['float','int'],[@A_sample_rate,@A_max_outputs],[D_tag,D_tensor])
  end;
function ExecAudioSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_max_outputs:integer; const D_tag:boolean=false; const D_tensor:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AudioSummaryV2',[I_tag,I_tensor,I_sample_rate],['max_outputs'],['int'],[@A_max_outputs],[D_tag,D_tensor,D_sample_rate])
  end;
function ExecAutoShardDataset(const I_input_dataset:TF_TensorPtr; const I_num_workers:TF_TensorPtr; const I_index:TF_TensorPtr; const A_auto_shard_policy:integer; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_workers:boolean=false; const D_index:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('AutoShardDataset',[I_input_dataset,I_num_workers,I_index],['auto_shard_policy','output_types','output_shapes'],['int','list(type)','list(shape)'],[@A_auto_shard_policy,@A_output_types,@A_output_shapes],[D_input_dataset,D_num_workers,D_index])
  end;
function ExecAvgPool(const I_value:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('AvgPool',[I_value],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_value])
  end;
function ExecAvgPool3D(const I_input:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('AvgPool3D',[I_input],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_input])
  end;
function ExecAvgPool3DGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  result:=ExecOper('AvgPool3DGrad',[I_orig_input_shape,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input_shape,D_grad])
  end;
function ExecAvgPoolGrad(const I_orig_input_shape:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input_shape:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  result:=ExecOper('AvgPoolGrad',[I_orig_input_shape,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input_shape,D_grad])
  end;
function ExecBarrier(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('Barrier',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecBarrierIncompleteSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BarrierIncompleteSize',[I_handle],[],[],[],[D_handle])
  end;
function ExecBarrierReadySize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BarrierReadySize',[I_handle],[],[],[],[D_handle])
  end;
function ExecBatchCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchCholesky',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_l);
  result:=ExecOper('BatchCholeskyGrad',[I_l,I_grad],['T'],['type'],[@F_T],[D_l,D_grad])
  end;
function ExecBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchDataset',[I_input_dataset,I_batch_size],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_batch_size])
  end;
function ExecBatchDatasetV2(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_drop_remainder:TF_TensorPtr; const A_parallel_copy:boolean; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_drop_remainder:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchDatasetV2',[I_input_dataset,I_batch_size,I_drop_remainder],['parallel_copy','output_types','output_shapes'],['bool','list(type)','list(shape)'],[@A_parallel_copy,@A_output_types,@A_output_shapes],[D_input_dataset,D_batch_size,D_drop_remainder])
  end;
function ExecBatchFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchFFT',[I_input],[],[],[],[D_input])
  end;
function ExecBatchFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchFFT2D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchFFT3D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchIFFT',[I_input],[],[],[],[D_input])
  end;
function ExecBatchIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchIFFT2D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BatchIFFT3D',[I_input],[],[],[],[D_input])
  end;
function ExecBatchMatMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_adj_x:boolean; const A_adj_y:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BatchMatMul',[I_x,I_y],['T','adj_x','adj_y'],['type','bool','bool'],[@F_T,@A_adj_x,@A_adj_y],[D_x,D_y])
  end;
function ExecBatchMatMulV2(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_adj_x:boolean; const A_adj_y:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BatchMatMulV2',[I_x,I_y],['T','adj_x','adj_y'],['type','bool','bool'],[@F_T,@A_adj_x,@A_adj_y],[D_x,D_y])
  end;
function ExecBatchMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixBandPart',[I_input,I_num_lower,I_num_upper],['T'],['type'],[@F_T],[D_input,D_num_lower,D_num_upper])
  end;
function ExecBatchMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixDeterminant',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('BatchMatrixDiag',[I_diagonal],['T'],['type'],[@F_T],[D_diagonal])
  end;
function ExecBatchMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixDiagPart',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixInverse',[I_input],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_input])
  end;
function ExecBatchMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchMatrixSetDiag',[I_input,I_diagonal],['T'],['type'],[@F_T],[D_input,D_diagonal])
  end;
function ExecBatchMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('BatchMatrixSolve',[I_matrix,I_rhs],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecBatchMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('BatchMatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],['T','fast'],['type','bool'],[@F_T,@A_fast],[D_matrix,D_rhs,D_l2_regularizer])
  end;
function ExecBatchMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('BatchMatrixTriangularSolve',[I_matrix,I_rhs],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecBatchNormWithGlobalNormalization(const I_t:TF_TensorPtr; const I_m:TF_TensorPtr; const I_v:TF_TensorPtr; const I_beta:TF_TensorPtr; const I_gamma:TF_TensorPtr; const A_variance_epsilon:real; const A_scale_after_normalization:boolean; const D_t:boolean=false; const D_m:boolean=false; const D_v:boolean=false; const D_beta:boolean=false; const D_gamma:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('BatchNormWithGlobalNormalization',[I_t,I_m,I_v,I_beta,I_gamma],['T','variance_epsilon','scale_after_normalization'],['type','float','bool'],[@F_T,@A_variance_epsilon,@A_scale_after_normalization],[D_t,D_m,D_v,D_beta,D_gamma])
  end;
function ExecBatchSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('BatchSelfAdjointEig',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecBatchToSpace(const I_input:TF_TensorPtr; const I_crops:TF_TensorPtr; const A_block_size:integer; const D_input:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_crops);
  result:=ExecOper('BatchToSpace',[I_input,I_crops],['T','block_size','Tidx'],['type','int','type'],[@F_T,@A_block_size,@F_Tidx],[D_input,D_crops])
  end;
function ExecBatchToSpaceND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_crops:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_crops:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tblock_shape:TF_DataType;
    F_Tcrops:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tblock_shape:=TF_TensorType(I_block_shape);
  F_Tcrops:=TF_TensorType(I_crops);
  result:=ExecOper('BatchToSpaceND',[I_input,I_block_shape,I_crops],['T','Tblock_shape','Tcrops'],['type','type','type'],[@F_T,@F_Tblock_shape,@F_Tcrops],[D_input,D_block_shape,D_crops])
  end;
function ExecBesselI0e(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BesselI0e',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecBesselI1e(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BesselI1e',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecBetainc(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Betainc',[I_a,I_b,I_x],['T'],['type'],[@F_T],[D_a,D_b,D_x])
  end;
function ExecBiasAdd(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const A_data_format:string; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('BiasAdd',[I_value,I_bias],['T','data_format'],['type','string'],[@F_T,@A_data_format],[D_value,D_bias])
  end;
function ExecBiasAddGrad(const I_out_backprop:TF_TensorPtr; const A_data_format:string; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_out_backprop);
  result:=ExecOper('BiasAddGrad',[I_out_backprop],['T','data_format'],['type','string'],[@F_T,@A_data_format],[D_out_backprop])
  end;
function ExecBiasAddV1(const I_value:TF_TensorPtr; const I_bias:TF_TensorPtr; const D_value:boolean=false; const D_bias:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('BiasAddV1',[I_value,I_bias],['T'],['type'],[@F_T],[D_value,D_bias])
  end;
function ExecBincount(const I_arr:TF_TensorPtr; const I_size:TF_TensorPtr; const I_weights:TF_TensorPtr; const D_arr:boolean=false; const D_size:boolean=false; const D_weights:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_weights);
  result:=ExecOper('Bincount',[I_arr,I_size,I_weights],['T'],['type'],[@F_T],[D_arr,D_size,D_weights])
  end;
function ExecBitcast(const I_input:TF_TensorPtr; const A_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Bitcast',[I_input],['T','type'],['type','type'],[@F_T,@A_type],[D_input])
  end;
function ExecBitwiseAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BitwiseAnd',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecBitwiseOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BitwiseOr',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecBitwiseXor(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('BitwiseXor',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecBoostedTreesAggregateStats(const I_node_ids:TF_TensorPtr; const I_gradients:TF_TensorPtr; const I_hessians:TF_TensorPtr; const I_feature:TF_TensorPtr; const A_max_splits:integer; const A_num_buckets:integer; const D_node_ids:boolean=false; const D_gradients:boolean=false; const D_hessians:boolean=false; const D_feature:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BoostedTreesAggregateStats',[I_node_ids,I_gradients,I_hessians,I_feature],['max_splits','num_buckets'],['int','int'],[@A_max_splits,@A_num_buckets],[D_node_ids,D_gradients,D_hessians,D_feature])
  end;
function ExecBoostedTreesCenterBias(const I_tree_ensemble_handle:TF_TensorPtr; const I_mean_gradients:TF_TensorPtr; const I_mean_hessians:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const D_tree_ensemble_handle:boolean=false; const D_mean_gradients:boolean=false; const D_mean_hessians:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BoostedTreesCenterBias',[I_tree_ensemble_handle,I_mean_gradients,I_mean_hessians,I_l1,I_l2],[],[],[],[D_tree_ensemble_handle,D_mean_gradients,D_mean_hessians,D_l1,D_l2])
  end;
function ExecBoostedTreesEnsembleResourceHandleOp(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('BoostedTreesEnsembleResourceHandleOp',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecBoostedTreesQuantileStreamResourceHandleOp(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('BoostedTreesQuantileStreamResourceHandleOp',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecBroadcastArgs(const I_s0:TF_TensorPtr; const I_s1:TF_TensorPtr; const D_s0:boolean=false; const D_s1:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_s0);
  result:=ExecOper('BroadcastArgs',[I_s0,I_s1],['T'],['type'],[@F_T],[D_s0,D_s1])
  end;
function ExecBroadcastTo(const I_input:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_input:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_shape);
  result:=ExecOper('BroadcastTo',[I_input,I_shape],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_input,D_shape])
  end;
function ExecBucketize(const I_input:TF_TensorPtr; const A_boundaries:array of real; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Bucketize',[I_input],['T','boundaries'],['type','list(float)'],[@F_T,@A_boundaries],[D_input])
  end;
function ExecBytesProducedStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('BytesProducedStatsDataset',[I_input_dataset,I_tag],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_tag])
  end;
function ExecCSRSparseMatrixToDense(const I_sparse_input:TF_TensorPtr; const A_type:TF_DataType; const D_sparse_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CSRSparseMatrixToDense',[I_sparse_input],['type'],['type'],[@A_type],[D_sparse_input])
  end;
function ExecCacheDataset(const I_input_dataset:TF_TensorPtr; const I_filename:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_filename:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CacheDataset',[I_input_dataset,I_filename],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_filename])
  end;
function ExecCacheDatasetV2(const I_input_dataset:TF_TensorPtr; const I_filename:TF_TensorPtr; const I_cache:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_filename:boolean=false; const D_cache:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CacheDatasetV2',[I_input_dataset,I_filename,I_cache],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_filename,D_cache])
  end;
function ExecCast(const I_x:TF_TensorPtr; const A_DstT:TF_DataType; const A_Truncate:boolean; const D_x:boolean=false):TF_TensorPtr;
  var
    F_SrcT:TF_DataType;
  begin
  F_SrcT:=TF_TensorType(I_x);
  result:=ExecOper('Cast',[I_x],['SrcT','DstT','Truncate'],['type','type','bool'],[@F_SrcT,@A_DstT,@A_Truncate],[D_x])
  end;
function ExecCeil(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Ceil',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecCheckNumerics(const I_tensor:TF_TensorPtr; const A_message:string; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('CheckNumerics',[I_tensor],['T','message'],['type','string'],[@F_T,@A_message],[D_tensor])
  end;
function ExecCheckNumericsV2(const I_tensor:TF_TensorPtr; const A_message:string; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('CheckNumericsV2',[I_tensor],['T','message'],['type','string'],[@F_T,@A_message],[D_tensor])
  end;
function ExecCholesky(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Cholesky',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecCholeskyGrad(const I_l:TF_TensorPtr; const I_grad:TF_TensorPtr; const D_l:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_l);
  result:=ExecOper('CholeskyGrad',[I_l,I_grad],['T'],['type'],[@F_T],[D_l,D_grad])
  end;
function ExecClipByValue(const I_t:TF_TensorPtr; const I_clip_value_min:TF_TensorPtr; const I_clip_value_max:TF_TensorPtr; const D_t:boolean=false; const D_clip_value_min:boolean=false; const D_clip_value_max:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('ClipByValue',[I_t,I_clip_value_min,I_clip_value_max],['T'],['type'],[@F_T],[D_t,D_clip_value_min,D_clip_value_max])
  end;
function ExecCollectiveBcastRecv(const A_T:TF_DataType; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_shape:TF_Shape; const A_communication_hint:string):TF_TensorPtr;
  begin
  result:=ExecOper('CollectiveBcastRecv',[],['T','group_size','group_key','instance_key','shape','communication_hint'],['type','int','int','int','shape','string'],[@A_T,@A_group_size,@A_group_key,@A_instance_key,@A_shape,@A_communication_hint],[])
  end;
function ExecCollectiveBcastSend(const I_input:TF_TensorPtr; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_shape:TF_Shape; const A_communication_hint:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CollectiveBcastSend',[I_input],['T','group_size','group_key','instance_key','shape','communication_hint'],['type','int','int','int','shape','string'],[@F_T,@A_group_size,@A_group_key,@A_instance_key,@A_shape,@A_communication_hint],[D_input])
  end;
function ExecCollectiveGather(const I_input:TF_TensorPtr; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_shape:TF_Shape; const A_communication_hint:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CollectiveGather',[I_input],['T','group_size','group_key','instance_key','shape','communication_hint'],['type','int','int','int','shape','string'],[@F_T,@A_group_size,@A_group_key,@A_instance_key,@A_shape,@A_communication_hint],[D_input])
  end;
function ExecCollectivePermute(const I_input:TF_TensorPtr; const I_source_target_pairs:TF_TensorPtr; const D_input:boolean=false; const D_source_target_pairs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CollectivePermute',[I_input,I_source_target_pairs],['T'],['type'],[@F_T],[D_input,D_source_target_pairs])
  end;
function ExecCollectiveReduce(const I_input:TF_TensorPtr; const A_group_size:integer; const A_group_key:integer; const A_instance_key:integer; const A_merge_op:string; const A_final_op:string; const A_subdiv_offsets:array of integer; const A_wait_for:array of integer; const A_communication_hint:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CollectiveReduce',[I_input],['T','group_size','group_key','instance_key','merge_op','final_op','subdiv_offsets','wait_for','communication_hint'],['type','int','int','int','string','string','list(int)','list(int)','string'],[@F_T,@A_group_size,@A_group_key,@A_instance_key,@A_merge_op,@A_final_op,@A_subdiv_offsets,@A_wait_for,@A_communication_hint],[D_input])
  end;
function ExecCompareAndBitpack(const I_input:TF_TensorPtr; const I_threshold:TF_TensorPtr; const D_input:boolean=false; const D_threshold:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CompareAndBitpack',[I_input,I_threshold],['T'],['type'],[@F_T],[D_input,D_threshold])
  end;
function ExecComplex(const I_real:TF_TensorPtr; const I_imag:TF_TensorPtr; const A_Tout:TF_DataType; const D_real:boolean=false; const D_imag:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_real);
  result:=ExecOper('Complex',[I_real,I_imag],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_real,D_imag])
  end;
function ExecComplexAbs(const I_x:TF_TensorPtr; const A_Tout:TF_DataType; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ComplexAbs',[I_x],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_x])
  end;
function ExecConcatenateDataset(const I_input_dataset:TF_TensorPtr; const I_another_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_another_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ConcatenateDataset',[I_input_dataset,I_another_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_another_dataset])
  end;
function ExecConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('ConditionalAccumulator',[],['dtype','shape','container','shared_name','reduction_type'],['type','shape','string','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name,@A_reduction_type],[])
  end;
function ExecConfigureDistributedTPU(const A_embedding_config:string; const A_tpu_embedding_config:string; const A_is_global_init:boolean; const A_enable_whole_mesh_compilations:boolean; const A_compilation_failure_closes_chips:boolean):TF_TensorPtr;
  begin
  result:=ExecOper('ConfigureDistributedTPU',[],['embedding_config','tpu_embedding_config','is_global_init','enable_whole_mesh_compilations','compilation_failure_closes_chips'],['string','string','bool','bool','bool'],[@A_embedding_config,@A_tpu_embedding_config,@A_is_global_init,@A_enable_whole_mesh_compilations,@A_compilation_failure_closes_chips],[])
  end;
function ExecConj(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conj',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecConjugateTranspose(const I_x:TF_TensorPtr; const I_perm:TF_TensorPtr; const D_x:boolean=false; const D_perm:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tperm:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tperm:=TF_TensorType(I_perm);
  result:=ExecOper('ConjugateTranspose',[I_x,I_perm],['T','Tperm'],['type','type'],[@F_T,@F_Tperm],[D_x,D_perm])
  end;
function ExecConst(const A_value:TF_TensorPtr; const A_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('Const',[],['value','dtype'],['tensor','type'],[@A_value,@A_dtype],[])
  end;
function ExecConv2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:array of integer; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv2D',[I_input,I_filter],['T','strides','use_cudnn_on_gpu','padding','explicit_paddings','data_format','dilations'],['type','list(int)','bool','string','list(int)','string','list(int)'],[@F_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_explicit_paddings,@A_data_format,@A_dilations],[D_input,D_filter])
  end;
function ExecConv2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:array of integer; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv2DBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],['T','strides','use_cudnn_on_gpu','padding','explicit_paddings','data_format','dilations'],['type','list(int)','bool','string','list(int)','string','list(int)'],[@F_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_explicit_paddings,@A_data_format,@A_dilations],[D_input,D_filter_sizes,D_out_backprop])
  end;
function ExecConv2DBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_use_cudnn_on_gpu:boolean; const A_padding:string; const A_explicit_paddings:array of integer; const A_data_format:string; const A_dilations:array of integer; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_filter);
  result:=ExecOper('Conv2DBackpropInput',[I_input_sizes,I_filter,I_out_backprop],['T','strides','use_cudnn_on_gpu','padding','explicit_paddings','data_format','dilations'],['type','list(int)','bool','string','list(int)','string','list(int)'],[@F_T,@A_strides,@A_use_cudnn_on_gpu,@A_padding,@A_explicit_paddings,@A_data_format,@A_dilations],[D_input_sizes,D_filter,D_out_backprop])
  end;
function ExecConv3D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3D',[I_input,I_filter],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_data_format,@A_dilations],[D_input,D_filter])
  end;
function ExecConv3DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3DBackpropFilter',[I_input,I_filter,I_out_backprop],['T','strides','padding','dilations'],['type','list(int)','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_dilations],[D_input,D_filter,D_out_backprop])
  end;
function ExecConv3DBackpropFilterV2(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3DBackpropFilterV2',[I_input,I_filter_sizes,I_out_backprop],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_data_format,@A_dilations],[D_input,D_filter_sizes,D_out_backprop])
  end;
function ExecConv3DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Conv3DBackpropInput',[I_input,I_filter,I_out_backprop],['T','strides','padding','dilations'],['type','list(int)','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_dilations],[D_input,D_filter,D_out_backprop])
  end;
function ExecConv3DBackpropInputV2(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_Tshape:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tshape:=TF_TensorType(I_input_sizes);
  F_T:=TF_TensorType(I_filter);
  result:=ExecOper('Conv3DBackpropInputV2',[I_input_sizes,I_filter,I_out_backprop],['T','strides','padding','data_format','dilations','Tshape'],['type','list(int)','string','string','list(int)','type'],[@F_T,@A_strides,@A_padding,@A_data_format,@A_dilations,@F_Tshape],[D_input_sizes,D_filter,D_out_backprop])
  end;
function ExecCopy(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:array of string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Copy',[I_input],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@F_T,@A_tensor_name,@A_debug_ops_spec],[D_input])
  end;
function ExecCopyHost(const I_input:TF_TensorPtr; const A_tensor_name:string; const A_debug_ops_spec:array of string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CopyHost',[I_input],['T','tensor_name','debug_ops_spec'],['type','string','list(string)'],[@F_T,@A_tensor_name,@A_debug_ops_spec],[D_input])
  end;
function ExecCos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Cos',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecCosh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Cosh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecCountUpTo(const I_ref:TF_TensorPtr; const A_limit:integer; const D_ref:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('CountUpTo',[I_ref],['limit','T'],['int','type'],[@A_limit,@F_T],[D_ref])
  end;
function ExecCropAndResize(const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_crop_size:TF_TensorPtr; const A_method:string; const A_extrapolation_value:real; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_crop_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('CropAndResize',[I_image,I_boxes,I_box_ind,I_crop_size],['T','method','extrapolation_value'],['type','string','float'],[@F_T,@A_method,@A_extrapolation_value],[D_image,D_boxes,D_box_ind,D_crop_size])
  end;
function ExecCropAndResizeGradBoxes(const I_grads:TF_TensorPtr; const I_image:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const A_method:string; const D_grads:boolean=false; const D_image:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('CropAndResizeGradBoxes',[I_grads,I_image,I_boxes,I_box_ind],['T','method'],['type','string'],[@F_T,@A_method],[D_grads,D_image,D_boxes,D_box_ind])
  end;
function ExecCropAndResizeGradImage(const I_grads:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_box_ind:TF_TensorPtr; const I_image_size:TF_TensorPtr; const A_T:TF_DataType; const A_method:string; const D_grads:boolean=false; const D_boxes:boolean=false; const D_box_ind:boolean=false; const D_image_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CropAndResizeGradImage',[I_grads,I_boxes,I_box_ind,I_image_size],['T','method'],['type','string'],[@A_T,@A_method],[D_grads,D_boxes,D_box_ind,D_image_size])
  end;
function ExecCross(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Cross',[I_a,I_b],['T'],['type'],[@F_T],[D_a,D_b])
  end;
function ExecCrossReplicaSum(const I_input:TF_TensorPtr; const I_group_assignment:TF_TensorPtr; const D_input:boolean=false; const D_group_assignment:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('CrossReplicaSum',[I_input,I_group_assignment],['T'],['type'],[@F_T],[D_input,D_group_assignment])
  end;
function ExecCudnnRNNParamsSize(const I_num_layers:TF_TensorPtr; const I_num_units:TF_TensorPtr; const I_input_size:TF_TensorPtr; const A_T:TF_DataType; const A_S:TF_DataType; const A_rnn_mode:string; const A_input_mode:string; const A_direction:string; const A_dropout:real; const A_seed:integer; const A_seed2:integer; const A_num_proj:integer; const D_num_layers:boolean=false; const D_num_units:boolean=false; const D_input_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('CudnnRNNParamsSize',[I_num_layers,I_num_units,I_input_size],['T','S','rnn_mode','input_mode','direction','dropout','seed','seed2','num_proj'],['type','type','string','string','string','float','int','int','int'],[@A_T,@A_S,@A_rnn_mode,@A_input_mode,@A_direction,@A_dropout,@A_seed,@A_seed2,@A_num_proj],[D_num_layers,D_num_units,D_input_size])
  end;
function ExecCumprod(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('Cumprod',[I_x,I_axis],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@F_T,@F_Tidx],[D_x,D_axis])
  end;
function ExecCumsum(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('Cumsum',[I_x,I_axis],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@F_T,@F_Tidx],[D_x,D_axis])
  end;
function ExecCumulativeLogsumexp(const I_x:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_exclusive:boolean; const A_reverse:boolean; const D_x:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('CumulativeLogsumexp',[I_x,I_axis],['exclusive','reverse','T','Tidx'],['bool','bool','type','type'],[@A_exclusive,@A_reverse,@F_T,@F_Tidx],[D_x,D_axis])
  end;
function ExecDataFormatDimMap(const I_x:TF_TensorPtr; const A_src_format:string; const A_dst_format:string; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('DataFormatDimMap',[I_x],['T','src_format','dst_format'],['type','string','string'],[@F_T,@A_src_format,@A_dst_format],[D_x])
  end;
function ExecDataFormatVecPermute(const I_x:TF_TensorPtr; const A_src_format:string; const A_dst_format:string; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('DataFormatVecPermute',[I_x],['T','src_format','dst_format'],['type','string','string'],[@F_T,@A_src_format,@A_dst_format],[D_x])
  end;
function ExecDatasetCardinality(const I_input_dataset:TF_TensorPtr; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DatasetCardinality',[I_input_dataset],[],[],[],[D_input_dataset])
  end;
function ExecDatasetFromGraph(const I_graph_def:TF_TensorPtr; const D_graph_def:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DatasetFromGraph',[I_graph_def],[],[],[],[D_graph_def])
  end;
function ExecDatasetToGraph(const I_input_dataset:TF_TensorPtr; const A_stateful_whitelist:array of string; const A_allow_stateful:boolean; const A_strip_device_assignment:boolean; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DatasetToGraph',[I_input_dataset],['stateful_whitelist','allow_stateful','strip_device_assignment'],['list(string)','bool','bool'],[@A_stateful_whitelist,@A_allow_stateful,@A_strip_device_assignment],[D_input_dataset])
  end;
function ExecDatasetToGraphV2(const I_input_dataset:TF_TensorPtr; const A_external_state_policy:integer; const A_strip_device_assignment:boolean; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DatasetToGraphV2',[I_input_dataset],['external_state_policy','strip_device_assignment'],['int','bool'],[@A_external_state_policy,@A_strip_device_assignment],[D_input_dataset])
  end;
function ExecDawsn(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Dawsn',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecDebugGradientIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugGradientIdentity',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecDebugGradientRefIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugGradientRefIdentity',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecDebugIdentity(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:array of string; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugIdentity',[I_input],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@F_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc],[D_input])
  end;
function ExecDebugIdentityV2(const I_input:TF_TensorPtr; const A_tfdbg_context_id:string; const A_op_name:string; const A_output_slot:integer; const A_tensor_debug_mode:integer; const A_debug_urls:array of string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugIdentityV2',[I_input],['T','tfdbg_context_id','op_name','output_slot','tensor_debug_mode','debug_urls'],['type','string','string','int','int','list(string)'],[@F_T,@A_tfdbg_context_id,@A_op_name,@A_output_slot,@A_tensor_debug_mode,@A_debug_urls],[D_input])
  end;
function ExecDebugNanCount(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:array of string; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugNanCount',[I_input],['T','device_name','tensor_name','debug_urls','gated_grpc'],['type','string','string','list(string)','bool'],[@F_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_gated_grpc],[D_input])
  end;
function ExecDebugNumericSummary(const I_input:TF_TensorPtr; const A_device_name:string; const A_tensor_name:string; const A_debug_urls:array of string; const A_lower_bound:real; const A_upper_bound:real; const A_mute_if_healthy:boolean; const A_gated_grpc:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugNumericSummary',[I_input],['T','device_name','tensor_name','debug_urls','lower_bound','upper_bound','mute_if_healthy','gated_grpc'],['type','string','string','list(string)','float','float','bool','bool'],[@F_T,@A_device_name,@A_tensor_name,@A_debug_urls,@A_lower_bound,@A_upper_bound,@A_mute_if_healthy,@A_gated_grpc],[D_input])
  end;
function ExecDebugNumericSummaryV2(const I_input:TF_TensorPtr; const A_output_dtype:TF_DataType; const A_tensor_debug_mode:integer; const A_tensor_id:integer; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DebugNumericSummaryV2',[I_input],['output_dtype','T','tensor_debug_mode','tensor_id'],['type','type','int','int'],[@A_output_dtype,@F_T,@A_tensor_debug_mode,@A_tensor_id],[D_input])
  end;
function ExecDecodeAndCropJpeg(const I_contents:TF_TensorPtr; const I_crop_window:TF_TensorPtr; const A_channels:integer; const A_ratio:integer; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string; const D_contents:boolean=false; const D_crop_window:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeAndCropJpeg',[I_contents,I_crop_window],['channels','ratio','fancy_upscaling','try_recover_truncated','acceptable_fraction','dct_method'],['int','int','bool','bool','float','string'],[@A_channels,@A_ratio,@A_fancy_upscaling,@A_try_recover_truncated,@A_acceptable_fraction,@A_dct_method],[D_contents,D_crop_window])
  end;
function ExecDecodeBase64(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeBase64',[I_input],[],[],[],[D_input])
  end;
function ExecDecodeBmp(const I_contents:TF_TensorPtr; const A_channels:integer; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeBmp',[I_contents],['channels'],['int'],[@A_channels],[D_contents])
  end;
function ExecDecodeCompressed(const I_bytes:TF_TensorPtr; const A_compression_type:string; const D_bytes:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeCompressed',[I_bytes],['compression_type'],['string'],[@A_compression_type],[D_bytes])
  end;
function ExecDecodeGif(const I_contents:TF_TensorPtr; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeGif',[I_contents],[],[],[],[D_contents])
  end;
function ExecDecodeJSONExample(const I_json_examples:TF_TensorPtr; const D_json_examples:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeJSONExample',[I_json_examples],[],[],[],[D_json_examples])
  end;
function ExecDecodeJpeg(const I_contents:TF_TensorPtr; const A_channels:integer; const A_ratio:integer; const A_fancy_upscaling:boolean; const A_try_recover_truncated:boolean; const A_acceptable_fraction:real; const A_dct_method:string; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeJpeg',[I_contents],['channels','ratio','fancy_upscaling','try_recover_truncated','acceptable_fraction','dct_method'],['int','int','bool','bool','float','string'],[@A_channels,@A_ratio,@A_fancy_upscaling,@A_try_recover_truncated,@A_acceptable_fraction,@A_dct_method],[D_contents])
  end;
function ExecDecodePaddedRaw(const I_input_bytes:TF_TensorPtr; const I_fixed_length:TF_TensorPtr; const A_out_type:TF_DataType; const A_little_endian:boolean; const D_input_bytes:boolean=false; const D_fixed_length:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodePaddedRaw',[I_input_bytes,I_fixed_length],['out_type','little_endian'],['type','bool'],[@A_out_type,@A_little_endian],[D_input_bytes,D_fixed_length])
  end;
function ExecDecodePng(const I_contents:TF_TensorPtr; const A_channels:integer; const A_dtype:TF_DataType; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodePng',[I_contents],['channels','dtype'],['int','type'],[@A_channels,@A_dtype],[D_contents])
  end;
function ExecDecodeRaw(const I_bytes:TF_TensorPtr; const A_out_type:TF_DataType; const A_little_endian:boolean; const D_bytes:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DecodeRaw',[I_bytes],['out_type','little_endian'],['type','bool'],[@A_out_type,@A_little_endian],[D_bytes])
  end;
function ExecDeepCopy(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('DeepCopy',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecDenseToCSRSparseMatrix(const I_dense_input:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_dense_input:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_dense_input);
  result:=ExecOper('DenseToCSRSparseMatrix',[I_dense_input,I_indices],['T'],['type'],[@F_T],[D_dense_input,D_indices])
  end;
function ExecDenseToSparseBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_row_shape:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_row_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('DenseToSparseBatchDataset',[I_input_dataset,I_batch_size,I_row_shape],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_batch_size,D_row_shape])
  end;
function ExecDepthToSpace(const I_input:TF_TensorPtr; const A_block_size:integer; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DepthToSpace',[I_input],['T','block_size','data_format'],['type','int','string'],[@F_T,@A_block_size,@A_data_format],[D_input])
  end;
function ExecDepthwiseConv2dNative(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DepthwiseConv2dNative',[I_input,I_filter],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_data_format,@A_dilations],[D_input,D_filter])
  end;
function ExecDepthwiseConv2dNativeBackpropFilter(const I_input:TF_TensorPtr; const I_filter_sizes:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input:boolean=false; const D_filter_sizes:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DepthwiseConv2dNativeBackpropFilter',[I_input,I_filter_sizes,I_out_backprop],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_data_format,@A_dilations],[D_input,D_filter_sizes,D_out_backprop])
  end;
function ExecDepthwiseConv2dNativeBackpropInput(const I_input_sizes:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const A_dilations:array of integer; const D_input_sizes:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_filter);
  result:=ExecOper('DepthwiseConv2dNativeBackpropInput',[I_input_sizes,I_filter,I_out_backprop],['T','strides','padding','data_format','dilations'],['type','list(int)','string','string','list(int)'],[@F_T,@A_strides,@A_padding,@A_data_format,@A_dilations],[D_input_sizes,D_filter,D_out_backprop])
  end;
function ExecDequantize(const I_input:TF_TensorPtr; const I_min_range:TF_TensorPtr; const I_max_range:TF_TensorPtr; const A_mode:string; const A_narrow_range:boolean; const A_axis:integer; const A_dtype:TF_DataType; const D_input:boolean=false; const D_min_range:boolean=false; const D_max_range:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dequantize',[I_input,I_min_range,I_max_range],['T','mode','narrow_range','axis','dtype'],['type','string','bool','int','type'],[@F_T,@A_mode,@A_narrow_range,@A_axis,@A_dtype],[D_input,D_min_range,D_max_range])
  end;
function ExecDestroyTemporaryVariable(const I_ref:TF_TensorPtr; const A_var_name:string; const D_ref:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  result:=ExecOper('DestroyTemporaryVariable',[I_ref],['T','var_name'],['type','string'],[@F_T,@A_var_name],[D_ref])
  end;
function ExecDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('Diag',[I_diagonal],['T'],['type'],[@F_T],[D_diagonal])
  end;
function ExecDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('DiagPart',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecDigamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Digamma',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecDilation2D(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dilation2D',[I_input,I_filter],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@F_T,@A_strides,@A_rates,@A_padding],[D_input,D_filter])
  end;
function ExecDilation2DBackpropFilter(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dilation2DBackpropFilter',[I_input,I_filter,I_out_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@F_T,@A_strides,@A_rates,@A_padding],[D_input,D_filter,D_out_backprop])
  end;
function ExecDilation2DBackpropInput(const I_input:TF_TensorPtr; const I_filter:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_input:boolean=false; const D_filter:boolean=false; const D_out_backprop:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Dilation2DBackpropInput',[I_input,I_filter,I_out_backprop],['T','strides','rates','padding'],['type','list(int)','list(int)','string'],[@F_T,@A_strides,@A_rates,@A_padding],[D_input,D_filter,D_out_backprop])
  end;
function ExecDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Div',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecDivNoNan(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('DivNoNan',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecDrawBoundingBoxes(const I_images:TF_TensorPtr; const I_boxes:TF_TensorPtr; const D_images:boolean=false; const D_boxes:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('DrawBoundingBoxes',[I_images,I_boxes],['T'],['type'],[@F_T],[D_images,D_boxes])
  end;
function ExecDrawBoundingBoxesV2(const I_images:TF_TensorPtr; const I_boxes:TF_TensorPtr; const I_colors:TF_TensorPtr; const D_images:boolean=false; const D_boxes:boolean=false; const D_colors:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('DrawBoundingBoxesV2',[I_images,I_boxes,I_colors],['T'],['type'],[@F_T],[D_images,D_boxes,D_colors])
  end;
function ExecEditDistance(const I_hypothesis_indices:TF_TensorPtr; const I_hypothesis_values:TF_TensorPtr; const I_hypothesis_shape:TF_TensorPtr; const I_truth_indices:TF_TensorPtr; const I_truth_values:TF_TensorPtr; const I_truth_shape:TF_TensorPtr; const A_normalize:boolean; const D_hypothesis_indices:boolean=false; const D_hypothesis_values:boolean=false; const D_hypothesis_shape:boolean=false; const D_truth_indices:boolean=false; const D_truth_values:boolean=false; const D_truth_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_hypothesis_values);
  result:=ExecOper('EditDistance',[I_hypothesis_indices,I_hypothesis_values,I_hypothesis_shape,I_truth_indices,I_truth_values,I_truth_shape],['normalize','T'],['bool','type'],[@A_normalize,@F_T],[D_hypothesis_indices,D_hypothesis_values,D_hypothesis_shape,D_truth_indices,D_truth_values,D_truth_shape])
  end;
function ExecElu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Elu',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecEluGrad(const I_gradients:TF_TensorPtr; const I_outputs:TF_TensorPtr; const D_gradients:boolean=false; const D_outputs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('EluGrad',[I_gradients,I_outputs],['T'],['type'],[@F_T],[D_gradients,D_outputs])
  end;
function ExecEmpty(const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const A_init:boolean; const D_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Empty',[I_shape],['dtype','init'],['type','bool'],[@A_dtype,@A_init],[D_shape])
  end;
function ExecEmptyTensorList(const I_element_shape:TF_TensorPtr; const I_max_num_elements:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_element_shape:boolean=false; const D_max_num_elements:boolean=false):TF_TensorPtr;
  var
    F_shape_type:TF_DataType;
  begin
  F_shape_type:=TF_TensorType(I_element_shape);
  result:=ExecOper('EmptyTensorList',[I_element_shape,I_max_num_elements],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@F_shape_type],[D_element_shape,D_max_num_elements])
  end;
function ExecEncodeBase64(const I_input:TF_TensorPtr; const A_pad:boolean; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeBase64',[I_input],['pad'],['bool'],[@A_pad],[D_input])
  end;
function ExecEncodeJpeg(const I_image:TF_TensorPtr; const A_format:string; const A_quality:integer; const A_progressive:boolean; const A_optimize_size:boolean; const A_chroma_downsampling:boolean; const A_density_unit:string; const A_x_density:integer; const A_y_density:integer; const A_xmp_metadata:string; const D_image:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeJpeg',[I_image],['format','quality','progressive','optimize_size','chroma_downsampling','density_unit','x_density','y_density','xmp_metadata'],['string','int','bool','bool','bool','string','int','int','string'],[@A_format,@A_quality,@A_progressive,@A_optimize_size,@A_chroma_downsampling,@A_density_unit,@A_x_density,@A_y_density,@A_xmp_metadata],[D_image])
  end;
function ExecEncodeJpegVariableQuality(const I_images:TF_TensorPtr; const I_quality:TF_TensorPtr; const D_images:boolean=false; const D_quality:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeJpegVariableQuality',[I_images,I_quality],[],[],[],[D_images,D_quality])
  end;
function ExecEncodePng(const I_image:TF_TensorPtr; const A_compression:integer; const D_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('EncodePng',[I_image],['compression','T'],['int','type'],[@A_compression,@F_T],[D_image])
  end;
function ExecEncodeWav(const I_audio:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const D_audio:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('EncodeWav',[I_audio,I_sample_rate],[],[],[],[D_audio,D_sample_rate])
  end;
function ExecEnsureShape(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('EnsureShape',[I_input],['shape','T'],['shape','type'],[@A_shape,@F_T],[D_input])
  end;
function ExecEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:integer; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('Enter',[I_data],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@F_T,@A_frame_name,@A_is_constant,@A_parallel_iterations],[D_data])
  end;
function ExecEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_incompatible_shape_error:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Equal',[I_x,I_y],['T','incompatible_shape_error'],['type','bool'],[@F_T,@A_incompatible_shape_error],[D_x,D_y])
  end;
function ExecErf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Erf',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecErfc(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Erfc',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecErfinv(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Erfinv',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecEuclideanNorm(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('EuclideanNorm',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('Exit',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecExp(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Exp',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecExpandDims(const I_input:TF_TensorPtr; const I_dim:TF_TensorPtr; const D_input:boolean=false; const D_dim:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tdim:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tdim:=TF_TensorType(I_dim);
  result:=ExecOper('ExpandDims',[I_input,I_dim],['T','Tdim'],['type','type'],[@F_T,@F_Tdim],[D_input,D_dim])
  end;
function ExecExperimentalAssertNextDataset(const I_input_dataset:TF_TensorPtr; const I_transformations:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_transformations:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalAssertNextDataset',[I_input_dataset,I_transformations],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_transformations])
  end;
function ExecExperimentalAutoShardDataset(const I_input_dataset:TF_TensorPtr; const I_num_workers:TF_TensorPtr; const I_index:TF_TensorPtr; const A_auto_shard_policy:integer; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_workers:boolean=false; const D_index:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalAutoShardDataset',[I_input_dataset,I_num_workers,I_index],['auto_shard_policy','output_types','output_shapes'],['int','list(type)','list(shape)'],[@A_auto_shard_policy,@A_output_types,@A_output_shapes],[D_input_dataset,D_num_workers,D_index])
  end;
function ExecExperimentalBytesProducedStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalBytesProducedStatsDataset',[I_input_dataset,I_tag],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_tag])
  end;
function ExecExperimentalDatasetCardinality(const I_input_dataset:TF_TensorPtr; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalDatasetCardinality',[I_input_dataset],[],[],[],[D_input_dataset])
  end;
function ExecExperimentalDenseToSparseBatchDataset(const I_input_dataset:TF_TensorPtr; const I_batch_size:TF_TensorPtr; const I_row_shape:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_batch_size:boolean=false; const D_row_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalDenseToSparseBatchDataset',[I_input_dataset,I_batch_size,I_row_shape],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_batch_size,D_row_shape])
  end;
function ExecExperimentalIgnoreErrorsDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalIgnoreErrorsDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecExperimentalIteratorGetDevice(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalIteratorGetDevice',[I_resource],[],[],[],[D_resource])
  end;
function ExecExperimentalLMDBDataset(const I_filenames:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_filenames:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalLMDBDataset',[I_filenames],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_filenames])
  end;
function ExecExperimentalLatencyStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalLatencyStatsDataset',[I_input_dataset,I_tag],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_tag])
  end;
function ExecExperimentalMatchingFilesDataset(const I_patterns:TF_TensorPtr; const D_patterns:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalMatchingFilesDataset',[I_patterns],[],[],[],[D_patterns])
  end;
function ExecExperimentalMaxIntraOpParallelismDataset(const I_input_dataset:TF_TensorPtr; const I_max_intra_op_parallelism:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_max_intra_op_parallelism:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalMaxIntraOpParallelismDataset',[I_input_dataset,I_max_intra_op_parallelism],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_max_intra_op_parallelism])
  end;
function ExecExperimentalNonSerializableDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalNonSerializableDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecExperimentalPrivateThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_num_threads:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_threads:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalPrivateThreadPoolDataset',[I_input_dataset,I_num_threads],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_num_threads])
  end;
function ExecExperimentalRandomDataset(const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalRandomDataset',[I_seed,I_seed2],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_seed,D_seed2])
  end;
function ExecExperimentalRebatchDataset(const I_input_dataset:TF_TensorPtr; const I_num_replicas:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_use_fallback:boolean; const D_input_dataset:boolean=false; const D_num_replicas:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalRebatchDataset',[I_input_dataset,I_num_replicas],['output_types','output_shapes','use_fallback'],['list(type)','list(shape)','bool'],[@A_output_types,@A_output_shapes,@A_use_fallback],[D_input_dataset,D_num_replicas])
  end;
function ExecExperimentalSetStatsAggregatorDataset(const I_input_dataset:TF_TensorPtr; const I_stats_aggregator:TF_TensorPtr; const I_tag:TF_TensorPtr; const I_counter_prefix:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_stats_aggregator:boolean=false; const D_tag:boolean=false; const D_counter_prefix:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalSetStatsAggregatorDataset',[I_input_dataset,I_stats_aggregator,I_tag,I_counter_prefix],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_stats_aggregator,D_tag,D_counter_prefix])
  end;
function ExecExperimentalSleepDataset(const I_input_dataset:TF_TensorPtr; const I_sleep_microseconds:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_sleep_microseconds:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalSleepDataset',[I_input_dataset,I_sleep_microseconds],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_sleep_microseconds])
  end;
function ExecExperimentalSlidingWindowDataset(const I_input_dataset:TF_TensorPtr; const I_window_size:TF_TensorPtr; const I_window_shift:TF_TensorPtr; const I_window_stride:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_window_size:boolean=false; const D_window_shift:boolean=false; const D_window_stride:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalSlidingWindowDataset',[I_input_dataset,I_window_size,I_window_shift,I_window_stride],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_window_size,D_window_shift,D_window_stride])
  end;
function ExecExperimentalSqlDataset(const I_driver_name:TF_TensorPtr; const I_data_source_name:TF_TensorPtr; const I_query:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_driver_name:boolean=false; const D_data_source_name:boolean=false; const D_query:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalSqlDataset',[I_driver_name,I_data_source_name,I_query],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_driver_name,D_data_source_name,D_query])
  end;
function ExecExperimentalStatsAggregatorHandle(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalStatsAggregatorHandle',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecExperimentalStatsAggregatorSummary(const I_iterator:TF_TensorPtr; const D_iterator:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalStatsAggregatorSummary',[I_iterator],[],[],[],[D_iterator])
  end;
function ExecExperimentalThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_thread_pool:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_thread_pool:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalThreadPoolDataset',[I_input_dataset,I_thread_pool],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_thread_pool])
  end;
function ExecExperimentalThreadPoolHandle(const A_num_threads:integer; const A_max_intra_op_parallelism:integer; const A_display_name:string; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalThreadPoolHandle',[],['num_threads','max_intra_op_parallelism','display_name','container','shared_name'],['int','int','string','string','string'],[@A_num_threads,@A_max_intra_op_parallelism,@A_display_name,@A_container,@A_shared_name],[])
  end;
function ExecExperimentalUnbatchDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalUnbatchDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecExperimentalUniqueDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExperimentalUniqueDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecExpint(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Expint',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecExpm1(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Expm1',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecExtractGlimpse(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_offsets:TF_TensorPtr; const A_centered:boolean; const A_normalized:boolean; const A_uniform_noise:boolean; const A_noise:string; const D_input:boolean=false; const D_size:boolean=false; const D_offsets:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExtractGlimpse',[I_input,I_size,I_offsets],['centered','normalized','uniform_noise','noise'],['bool','bool','bool','string'],[@A_centered,@A_normalized,@A_uniform_noise,@A_noise],[D_input,D_size,D_offsets])
  end;
function ExecExtractImagePatches(const I_images:TF_TensorPtr; const A_ksizes:array of integer; const A_strides:array of integer; const A_rates:array of integer; const A_padding:string; const D_images:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ExtractImagePatches',[I_images],['ksizes','strides','rates','T','padding'],['list(int)','list(int)','list(int)','type','string'],[@A_ksizes,@A_strides,@A_rates,@F_T,@A_padding],[D_images])
  end;
function ExecExtractJpegShape(const I_contents:TF_TensorPtr; const A_output_type:TF_DataType; const D_contents:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ExtractJpegShape',[I_contents],['output_type'],['type'],[@A_output_type],[D_contents])
  end;
function ExecExtractVolumePatches(const I_input:TF_TensorPtr; const A_ksizes:array of integer; const A_strides:array of integer; const A_padding:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('ExtractVolumePatches',[I_input],['ksizes','strides','T','padding'],['list(int)','list(int)','type','string'],[@A_ksizes,@A_strides,@F_T,@A_padding],[D_input])
  end;
function ExecFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('FFT',[I_input],['Tcomplex'],['type'],[@F_Tcomplex],[D_input])
  end;
function ExecFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('FFT2D',[I_input],['Tcomplex'],['type'],[@F_Tcomplex],[D_input])
  end;
function ExecFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('FFT3D',[I_input],['Tcomplex'],['type'],[@F_Tcomplex],[D_input])
  end;
function ExecFIFOQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('FIFOQueue',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecFIFOQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('FIFOQueueV2',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecFact():TF_TensorPtr;
  begin
  result:=ExecOper('Fact',[],[],[],[],[])
  end;
function ExecFakeParam(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('FakeParam',[],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape],[])
  end;
function ExecFakeQuantWithMinMaxArgs(const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:integer; const A_narrow_range:boolean; const D_inputs:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxArgs',[I_inputs],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range],[D_inputs])
  end;
function ExecFakeQuantWithMinMaxArgsGradient(const I_gradients:TF_TensorPtr; const I_inputs:TF_TensorPtr; const A_min:real; const A_max:real; const A_num_bits:integer; const A_narrow_range:boolean; const D_gradients:boolean=false; const D_inputs:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxArgsGradient',[I_gradients,I_inputs],['min','max','num_bits','narrow_range'],['float','float','int','bool'],[@A_min,@A_max,@A_num_bits,@A_narrow_range],[D_gradients,D_inputs])
  end;
function ExecFakeQuantWithMinMaxVars(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:integer; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxVars',[I_inputs,I_min,I_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range],[D_inputs,D_min,D_max])
  end;
function ExecFakeQuantWithMinMaxVarsPerChannel(const I_inputs:TF_TensorPtr; const I_min:TF_TensorPtr; const I_max:TF_TensorPtr; const A_num_bits:integer; const A_narrow_range:boolean; const D_inputs:boolean=false; const D_min:boolean=false; const D_max:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQuantWithMinMaxVarsPerChannel',[I_inputs,I_min,I_max],['num_bits','narrow_range'],['int','bool'],[@A_num_bits,@A_narrow_range],[D_inputs,D_min,D_max])
  end;
function ExecFakeQueue(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FakeQueue',[I_resource],[],[],[],[D_resource])
  end;
function ExecFill(const I_dims:TF_TensorPtr; const I_value:TF_TensorPtr; const D_dims:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_index_type:TF_DataType;
    F_T:TF_DataType;
  begin
  F_index_type:=TF_TensorType(I_dims);
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('Fill',[I_dims,I_value],['T','index_type'],['type','type'],[@F_T,@F_index_type],[D_dims,D_value])
  end;
function ExecFilterByLastComponentDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FilterByLastComponentDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecFingerprint(const I_data:TF_TensorPtr; const I_method:TF_TensorPtr; const D_data:boolean=false; const D_method:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('Fingerprint',[I_data,I_method],['T'],['type'],[@F_T],[D_data,D_method])
  end;
function ExecFixedLengthRecordDataset(const I_filenames:TF_TensorPtr; const I_header_bytes:TF_TensorPtr; const I_record_bytes:TF_TensorPtr; const I_footer_bytes:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const D_filenames:boolean=false; const D_header_bytes:boolean=false; const D_record_bytes:boolean=false; const D_footer_bytes:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordDataset',[I_filenames,I_header_bytes,I_record_bytes,I_footer_bytes,I_buffer_size],[],[],[],[D_filenames,D_header_bytes,D_record_bytes,D_footer_bytes,D_buffer_size])
  end;
function ExecFixedLengthRecordDatasetV2(const I_filenames:TF_TensorPtr; const I_header_bytes:TF_TensorPtr; const I_record_bytes:TF_TensorPtr; const I_footer_bytes:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const D_filenames:boolean=false; const D_header_bytes:boolean=false; const D_record_bytes:boolean=false; const D_footer_bytes:boolean=false; const D_buffer_size:boolean=false; const D_compression_type:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordDatasetV2',[I_filenames,I_header_bytes,I_record_bytes,I_footer_bytes,I_buffer_size,I_compression_type],[],[],[],[D_filenames,D_header_bytes,D_record_bytes,D_footer_bytes,D_buffer_size,D_compression_type])
  end;
function ExecFixedLengthRecordReader(const A_header_bytes:integer; const A_record_bytes:integer; const A_footer_bytes:integer; const A_hop_bytes:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordReader',[],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name'],['int','int','int','int','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name],[])
  end;
function ExecFixedLengthRecordReaderV2(const A_header_bytes:integer; const A_record_bytes:integer; const A_footer_bytes:integer; const A_hop_bytes:integer; const A_container:string; const A_shared_name:string; const A_encoding:string):TF_TensorPtr;
  begin
  result:=ExecOper('FixedLengthRecordReaderV2',[],['header_bytes','record_bytes','footer_bytes','hop_bytes','container','shared_name','encoding'],['int','int','int','int','string','string','string'],[@A_header_bytes,@A_record_bytes,@A_footer_bytes,@A_hop_bytes,@A_container,@A_shared_name,@A_encoding],[])
  end;
function ExecFloor(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Floor',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecFloorDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('FloorDiv',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecFloorMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('FloorMod',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecFractionalAvgPoolGrad(const I_orig_input_tensor_shape:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input_tensor_shape:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_out_backprop);
  result:=ExecOper('FractionalAvgPoolGrad',[I_orig_input_tensor_shape,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],['overlapping','T'],['bool','type'],[@A_overlapping,@F_T],[D_orig_input_tensor_shape,D_out_backprop,D_row_pooling_sequence,D_col_pooling_sequence])
  end;
function ExecFractionalMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_out_backprop:TF_TensorPtr; const I_row_pooling_sequence:TF_TensorPtr; const I_col_pooling_sequence:TF_TensorPtr; const A_overlapping:boolean; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_out_backprop:boolean=false; const D_row_pooling_sequence:boolean=false; const D_col_pooling_sequence:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('FractionalMaxPoolGrad',[I_orig_input,I_orig_output,I_out_backprop,I_row_pooling_sequence,I_col_pooling_sequence],['overlapping','T'],['bool','type'],[@A_overlapping,@F_T],[D_orig_input,D_orig_output,D_out_backprop,D_row_pooling_sequence,D_col_pooling_sequence])
  end;
function ExecFresnelCos(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('FresnelCos',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecFresnelSin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('FresnelSin',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecFusedPadConv2D(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_mode:string; const A_strides:array of integer; const A_padding:string; const D_input:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('FusedPadConv2D',[I_input,I_paddings,I_filter],['T','mode','strides','padding'],['type','string','list(int)','string'],[@F_T,@A_mode,@A_strides,@A_padding],[D_input,D_paddings,D_filter])
  end;
function ExecFusedResizeAndPadConv2D(const I_input:TF_TensorPtr; const I_size:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_filter:TF_TensorPtr; const A_resize_align_corners:boolean; const A_mode:string; const A_strides:array of integer; const A_padding:string; const D_input:boolean=false; const D_size:boolean=false; const D_paddings:boolean=false; const D_filter:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('FusedResizeAndPadConv2D',[I_input,I_size,I_paddings,I_filter],['T','resize_align_corners','mode','strides','padding'],['type','bool','string','list(int)','string'],[@F_T,@A_resize_align_corners,@A_mode,@A_strides,@A_padding],[D_input,D_size,D_paddings,D_filter])
  end;
function ExecGather(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_validate_indices:boolean; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_Tparams:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_Tparams:=TF_TensorType(I_params);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('Gather',[I_params,I_indices],['validate_indices','Tparams','Tindices'],['bool','type','type'],[@A_validate_indices,@F_Tparams,@F_Tindices],[D_params,D_indices])
  end;
function ExecGatherNd(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_params:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_Tparams:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_Tparams:=TF_TensorType(I_params);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('GatherNd',[I_params,I_indices],['Tparams','Tindices'],['type','type'],[@F_Tparams,@F_Tindices],[D_params,D_indices])
  end;
function ExecGatherV2(const I_params:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_axis:TF_TensorPtr; const A_batch_dims:integer; const D_params:boolean=false; const D_indices:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_Tparams:TF_DataType;
    F_Tindices:TF_DataType;
    F_Taxis:TF_DataType;
  begin
  F_Tparams:=TF_TensorType(I_params);
  F_Tindices:=TF_TensorType(I_indices);
  F_Taxis:=TF_TensorType(I_axis);
  result:=ExecOper('GatherV2',[I_params,I_indices,I_axis],['batch_dims','Tparams','Tindices','Taxis'],['int','type','type','type'],[@A_batch_dims,@F_Tparams,@F_Tindices,@F_Taxis],[D_params,D_indices,D_axis])
  end;
function ExecGetSessionHandle(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('GetSessionHandle',[I_value],['T'],['type'],[@F_T],[D_value])
  end;
function ExecGetSessionHandleV2(const I_value:TF_TensorPtr; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('GetSessionHandleV2',[I_value],['T'],['type'],[@F_T],[D_value])
  end;
function ExecGetSessionTensor(const I_handle:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('GetSessionTensor',[I_handle],['dtype'],['type'],[@A_dtype],[D_handle])
  end;
function ExecGreater(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Greater',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecGreaterEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('GreaterEqual',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecGuaranteeConst(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('GuaranteeConst',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecHSVToRGB(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('HSVToRGB',[I_images],['T'],['type'],[@F_T],[D_images])
  end;
function ExecHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('HashTable',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('HashTableV2',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecHistogramFixedWidth(const I_values:TF_TensorPtr; const I_value_range:TF_TensorPtr; const I_nbins:TF_TensorPtr; const A_dtype:TF_DataType; const D_values:boolean=false; const D_value_range:boolean=false; const D_nbins:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_values);
  result:=ExecOper('HistogramFixedWidth',[I_values,I_value_range,I_nbins],['T','dtype'],['type','type'],[@F_T,@A_dtype],[D_values,D_value_range,D_nbins])
  end;
function ExecHistogramSummary(const I_tag:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tag:boolean=false; const D_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_values);
  result:=ExecOper('HistogramSummary',[I_tag,I_values],['T'],['type'],[@F_T],[D_tag,D_values])
  end;
function ExecHostConst(const A_value:TF_TensorPtr; const A_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('HostConst',[],['value','dtype'],['tensor','type'],[@A_value,@A_dtype],[])
  end;
function ExecIFFT(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('IFFT',[I_input],['Tcomplex'],['type'],[@F_Tcomplex],[D_input])
  end;
function ExecIFFT2D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('IFFT2D',[I_input],['Tcomplex'],['type'],[@F_Tcomplex],[D_input])
  end;
function ExecIFFT3D(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('IFFT3D',[I_input],['Tcomplex'],['type'],[@F_Tcomplex],[D_input])
  end;
function ExecIRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Treal:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('IRFFT',[I_input,I_fft_length],['Treal','Tcomplex'],['type','type'],[@A_Treal,@F_Tcomplex],[D_input,D_fft_length])
  end;
function ExecIRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Treal:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('IRFFT2D',[I_input,I_fft_length],['Treal','Tcomplex'],['type','type'],[@A_Treal,@F_Tcomplex],[D_input,D_fft_length])
  end;
function ExecIRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Treal:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  var
    F_Tcomplex:TF_DataType;
  begin
  F_Tcomplex:=TF_TensorType(I_input);
  result:=ExecOper('IRFFT3D',[I_input,I_fft_length],['Treal','Tcomplex'],['type','type'],[@A_Treal,@F_Tcomplex],[D_input,D_fft_length])
  end;
function ExecIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Identity',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecIdentityReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('IdentityReader',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecIdentityReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('IdentityReaderV2',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecIgamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Igamma',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecIgammaGradA(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('IgammaGradA',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecIgammac(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Igammac',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecIgnoreErrorsDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IgnoreErrorsDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecImag(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Imag',[I_input],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_input])
  end;
function ExecImageProjectiveTransformV2(const I_images:TF_TensorPtr; const I_transforms:TF_TensorPtr; const I_output_shape:TF_TensorPtr; const A_interpolation:string; const D_images:boolean=false; const D_transforms:boolean=false; const D_output_shape:boolean=false):TF_TensorPtr;
  var
    F_dtype:TF_DataType;
  begin
  F_dtype:=TF_TensorType(I_images);
  result:=ExecOper('ImageProjectiveTransformV2',[I_images,I_transforms,I_output_shape],['dtype','interpolation'],['type','string'],[@F_dtype,@A_interpolation],[D_images,D_transforms,D_output_shape])
  end;
function ExecImageSummary(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const A_max_images:integer; const A_bad_color:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('ImageSummary',[I_tag,I_tensor],['max_images','T','bad_color'],['int','type','tensor'],[@A_max_images,@F_T,@A_bad_color],[D_tag,D_tensor])
  end;
function ExecImmutableConst(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_memory_region_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('ImmutableConst',[],['dtype','shape','memory_region_name'],['type','shape','string'],[@A_dtype,@A_shape,@A_memory_region_name],[])
  end;
function ExecInTopK(const I_predictions:TF_TensorPtr; const I_targets:TF_TensorPtr; const A_k:integer; const D_predictions:boolean=false; const D_targets:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_targets);
  result:=ExecOper('InTopK',[I_predictions,I_targets],['k','T'],['int','type'],[@A_k,@F_T],[D_predictions,D_targets])
  end;
function ExecInTopKV2(const I_predictions:TF_TensorPtr; const I_targets:TF_TensorPtr; const I_k:TF_TensorPtr; const D_predictions:boolean=false; const D_targets:boolean=false; const D_k:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_targets);
  result:=ExecOper('InTopKV2',[I_predictions,I_targets,I_k],['T'],['type'],[@F_T],[D_predictions,D_targets,D_k])
  end;
function ExecInfeedDequeue(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('InfeedDequeue',[],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape],[])
  end;
function ExecInplaceAdd(const I_x:TF_TensorPtr; const I_i:TF_TensorPtr; const I_v:TF_TensorPtr; const D_x:boolean=false; const D_i:boolean=false; const D_v:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('InplaceAdd',[I_x,I_i,I_v],['T'],['type'],[@F_T],[D_x,D_i,D_v])
  end;
function ExecInplaceSub(const I_x:TF_TensorPtr; const I_i:TF_TensorPtr; const I_v:TF_TensorPtr; const D_x:boolean=false; const D_i:boolean=false; const D_v:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('InplaceSub',[I_x,I_i,I_v],['T'],['type'],[@F_T],[D_x,D_i,D_v])
  end;
function ExecInplaceUpdate(const I_x:TF_TensorPtr; const I_i:TF_TensorPtr; const I_v:TF_TensorPtr; const D_x:boolean=false; const D_i:boolean=false; const D_v:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('InplaceUpdate',[I_x,I_i,I_v],['T'],['type'],[@F_T],[D_x,D_i,D_v])
  end;
function ExecInv(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Inv',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecInvGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('InvGrad',[I_y,I_dy],['T'],['type'],[@F_T],[D_y,D_dy])
  end;
function ExecInvert(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Invert',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecInvertPermutation(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('InvertPermutation',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsBoostedTreesEnsembleInitialized(const I_tree_ensemble_handle:TF_TensorPtr; const D_tree_ensemble_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IsBoostedTreesEnsembleInitialized',[I_tree_ensemble_handle],[],[],[],[D_tree_ensemble_handle])
  end;
function ExecIsBoostedTreesQuantileStreamResourceInitialized(const I_quantile_stream_resource_handle:TF_TensorPtr; const D_quantile_stream_resource_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IsBoostedTreesQuantileStreamResourceInitialized',[I_quantile_stream_resource_handle],[],[],[],[D_quantile_stream_resource_handle])
  end;
function ExecIsFinite(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('IsFinite',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsInf(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('IsInf',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsNan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('IsNan',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecIsVariableInitialized(const I_ref:TF_TensorPtr; const D_ref:boolean=false):TF_TensorPtr;
  var
    F_dtype:TF_DataType;
  begin
  F_dtype:=TF_TensorType(I_ref);
  result:=ExecOper('IsVariableInitialized',[I_ref],['dtype'],['type'],[@F_dtype],[D_ref])
  end;
function ExecIterator(const A_shared_name:string; const A_container:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('Iterator',[],['shared_name','container','output_types','output_shapes'],['string','string','list(type)','list(shape)'],[@A_shared_name,@A_container,@A_output_types,@A_output_shapes],[])
  end;
function ExecIteratorFromStringHandle(const I_string_handle:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_string_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorFromStringHandle',[I_string_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_string_handle])
  end;
function ExecIteratorFromStringHandleV2(const I_string_handle:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_string_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorFromStringHandleV2',[I_string_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_string_handle])
  end;
function ExecIteratorGetDevice(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorGetDevice',[I_resource],[],[],[],[D_resource])
  end;
function ExecIteratorGetNextAsOptional(const I_iterator:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_iterator:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorGetNextAsOptional',[I_iterator],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_iterator])
  end;
function ExecIteratorToStringHandle(const I_resource_handle:TF_TensorPtr; const D_resource_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorToStringHandle',[I_resource_handle],[],[],[],[D_resource_handle])
  end;
function ExecIteratorV2(const A_shared_name:string; const A_container:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('IteratorV2',[],['shared_name','container','output_types','output_shapes'],['string','string','list(type)','list(shape)'],[@A_shared_name,@A_container,@A_output_types,@A_output_shapes],[])
  end;
function ExecKMC2ChainInitialization(const I_distances:TF_TensorPtr; const I_seed:TF_TensorPtr; const D_distances:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('KMC2ChainInitialization',[I_distances,I_seed],[],[],[],[D_distances,D_seed])
  end;
function ExecKmeansPlusPlusInitialization(const I_points:TF_TensorPtr; const I_num_to_sample:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_num_retries_per_sample:TF_TensorPtr; const D_points:boolean=false; const D_num_to_sample:boolean=false; const D_seed:boolean=false; const D_num_retries_per_sample:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('KmeansPlusPlusInitialization',[I_points,I_num_to_sample,I_seed,I_num_retries_per_sample],[],[],[],[D_points,D_num_to_sample,D_seed,D_num_retries_per_sample])
  end;
function ExecL2Loss(const I_t:TF_TensorPtr; const D_t:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('L2Loss',[I_t],['T'],['type'],[@F_T],[D_t])
  end;
function ExecLMDBDataset(const I_filenames:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_filenames:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LMDBDataset',[I_filenames],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_filenames])
  end;
function ExecLMDBReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('LMDBReader',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecLRN(const I_input:TF_TensorPtr; const A_depth_radius:integer; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('LRN',[I_input],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@F_T],[D_input])
  end;
function ExecLRNGrad(const I_input_grads:TF_TensorPtr; const I_input_image:TF_TensorPtr; const I_output_image:TF_TensorPtr; const A_depth_radius:integer; const A_bias:real; const A_alpha:real; const A_beta:real; const D_input_grads:boolean=false; const D_input_image:boolean=false; const D_output_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input_grads);
  result:=ExecOper('LRNGrad',[I_input_grads,I_input_image,I_output_image],['depth_radius','bias','alpha','beta','T'],['int','float','float','float','type'],[@A_depth_radius,@A_bias,@A_alpha,@A_beta,@F_T],[D_input_grads,D_input_image,D_output_image])
  end;
function ExecLatencyStatsDataset(const I_input_dataset:TF_TensorPtr; const I_tag:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_tag:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LatencyStatsDataset',[I_input_dataset,I_tag],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_tag])
  end;
function ExecLeakyRelu(const I_features:TF_TensorPtr; const A_alpha:real; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('LeakyRelu',[I_features],['alpha','T'],['float','type'],[@A_alpha,@F_T],[D_features])
  end;
function ExecLeakyReluGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const A_alpha:real; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('LeakyReluGrad',[I_gradients,I_features],['alpha','T'],['float','type'],[@A_alpha,@F_T],[D_gradients,D_features])
  end;
function ExecLeftShift(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('LeftShift',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecLess(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Less',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecLessEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('LessEqual',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecLgamma(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Lgamma',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecLinSpace(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_num:TF_TensorPtr; const D_start:boolean=false; const D_stop:boolean=false; const D_num:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_start);
  F_Tidx:=TF_TensorType(I_num);
  result:=ExecOper('LinSpace',[I_start,I_stop,I_num],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_start,D_stop,D_num])
  end;
function ExecLoadAndRemapMatrix(const I_ckpt_path:TF_TensorPtr; const I_old_tensor_name:TF_TensorPtr; const I_row_remapping:TF_TensorPtr; const I_col_remapping:TF_TensorPtr; const I_initializing_values:TF_TensorPtr; const A_num_rows:integer; const A_num_cols:integer; const A_max_rows_in_memory:integer; const D_ckpt_path:boolean=false; const D_old_tensor_name:boolean=false; const D_row_remapping:boolean=false; const D_col_remapping:boolean=false; const D_initializing_values:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LoadAndRemapMatrix',[I_ckpt_path,I_old_tensor_name,I_row_remapping,I_col_remapping,I_initializing_values],['num_rows','num_cols','max_rows_in_memory'],['int','int','int'],[@A_num_rows,@A_num_cols,@A_max_rows_in_memory],[D_ckpt_path,D_old_tensor_name,D_row_remapping,D_col_remapping,D_initializing_values])
  end;
function ExecLog(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Log',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecLog1p(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Log1p',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecLogSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  result:=ExecOper('LogSoftmax',[I_logits],['T'],['type'],[@F_T],[D_logits])
  end;
function ExecLogicalAnd(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LogicalAnd',[I_x,I_y],[],[],[],[D_x,D_y])
  end;
function ExecLogicalNot(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LogicalNot',[I_x],[],[],[],[D_x])
  end;
function ExecLogicalOr(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LogicalOr',[I_x,I_y],[],[],[],[D_x,D_y])
  end;
function ExecLookupTableFind(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
  var
    F_Tin:TF_DataType;
    F_Tout:TF_DataType;
  begin
  F_Tin:=TF_TensorType(I_keys);
  F_Tout:=TF_TensorType(I_default_value);
  result:=ExecOper('LookupTableFind',[I_table_handle,I_keys,I_default_value],['Tin','Tout'],['type','type'],[@F_Tin,@F_Tout],[D_table_handle,D_keys,D_default_value])
  end;
function ExecLookupTableFindV2(const I_table_handle:TF_TensorPtr; const I_keys:TF_TensorPtr; const I_default_value:TF_TensorPtr; const D_table_handle:boolean=false; const D_keys:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
  var
    F_Tin:TF_DataType;
    F_Tout:TF_DataType;
  begin
  F_Tin:=TF_TensorType(I_keys);
  F_Tout:=TF_TensorType(I_default_value);
  result:=ExecOper('LookupTableFindV2',[I_table_handle,I_keys,I_default_value],['Tin','Tout'],['type','type'],[@F_Tin,@F_Tout],[D_table_handle,D_keys,D_default_value])
  end;
function ExecLookupTableSize(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LookupTableSize',[I_table_handle],[],[],[],[D_table_handle])
  end;
function ExecLookupTableSizeV2(const I_table_handle:TF_TensorPtr; const D_table_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LookupTableSizeV2',[I_table_handle],[],[],[],[D_table_handle])
  end;
function ExecLoopCond(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('LoopCond',[I_input],[],[],[],[D_input])
  end;
function ExecLowerBound(const I_sorted_inputs:TF_TensorPtr; const I_values:TF_TensorPtr; const A_out_type:TF_DataType; const D_sorted_inputs:boolean=false; const D_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sorted_inputs);
  result:=ExecOper('LowerBound',[I_sorted_inputs,I_values],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_sorted_inputs,D_values])
  end;
function ExecMapIncompleteSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('MapIncompleteSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecMapSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('MapSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('MatMul',[I_a,I_b],['transpose_a','transpose_b','T'],['bool','bool','type'],[@A_transpose_a,@A_transpose_b,@F_T],[D_a,D_b])
  end;
function ExecMatchingFiles(const I_pattern:TF_TensorPtr; const D_pattern:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MatchingFiles',[I_pattern],[],[],[],[D_pattern])
  end;
function ExecMatchingFilesDataset(const I_patterns:TF_TensorPtr; const D_patterns:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MatchingFilesDataset',[I_patterns],[],[],[],[D_patterns])
  end;
function ExecMatrixBandPart(const I_input:TF_TensorPtr; const I_num_lower:TF_TensorPtr; const I_num_upper:TF_TensorPtr; const D_input:boolean=false; const D_num_lower:boolean=false; const D_num_upper:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindex:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tindex:=TF_TensorType(I_num_lower);
  result:=ExecOper('MatrixBandPart',[I_input,I_num_lower,I_num_upper],['T','Tindex'],['type','type'],[@F_T,@F_Tindex],[D_input,D_num_lower,D_num_upper])
  end;
function ExecMatrixDeterminant(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixDeterminant',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixDiag(const I_diagonal:TF_TensorPtr; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('MatrixDiag',[I_diagonal],['T'],['type'],[@F_T],[D_diagonal])
  end;
function ExecMatrixDiagPart(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixDiagPart',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixDiagPartV2(const I_input:TF_TensorPtr; const I_k:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const D_input:boolean=false; const D_k:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixDiagPartV2',[I_input,I_k,I_padding_value],['T'],['type'],[@F_T],[D_input,D_k,D_padding_value])
  end;
function ExecMatrixDiagPartV3(const I_input:TF_TensorPtr; const I_k:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const A_align:string; const D_input:boolean=false; const D_k:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixDiagPartV3',[I_input,I_k,I_padding_value],['T','align'],['type','string'],[@F_T,@A_align],[D_input,D_k,D_padding_value])
  end;
function ExecMatrixDiagV2(const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const I_num_rows:TF_TensorPtr; const I_num_cols:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const D_diagonal:boolean=false; const D_k:boolean=false; const D_num_rows:boolean=false; const D_num_cols:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('MatrixDiagV2',[I_diagonal,I_k,I_num_rows,I_num_cols,I_padding_value],['T'],['type'],[@F_T],[D_diagonal,D_k,D_num_rows,D_num_cols,D_padding_value])
  end;
function ExecMatrixDiagV3(const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const I_num_rows:TF_TensorPtr; const I_num_cols:TF_TensorPtr; const I_padding_value:TF_TensorPtr; const A_align:string; const D_diagonal:boolean=false; const D_k:boolean=false; const D_num_rows:boolean=false; const D_num_cols:boolean=false; const D_padding_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonal);
  result:=ExecOper('MatrixDiagV3',[I_diagonal,I_k,I_num_rows,I_num_cols,I_padding_value],['T','align'],['type','string'],[@F_T,@A_align],[D_diagonal,D_k,D_num_rows,D_num_cols,D_padding_value])
  end;
function ExecMatrixExponential(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixExponential',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixInverse(const I_input:TF_TensorPtr; const A_adjoint:boolean; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixInverse',[I_input],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_input])
  end;
function ExecMatrixLogarithm(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixLogarithm',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixSetDiag(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixSetDiag',[I_input,I_diagonal],['T'],['type'],[@F_T],[D_input,D_diagonal])
  end;
function ExecMatrixSetDiagV2(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const D_input:boolean=false; const D_diagonal:boolean=false; const D_k:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixSetDiagV2',[I_input,I_diagonal,I_k],['T'],['type'],[@F_T],[D_input,D_diagonal,D_k])
  end;
function ExecMatrixSetDiagV3(const I_input:TF_TensorPtr; const I_diagonal:TF_TensorPtr; const I_k:TF_TensorPtr; const A_align:string; const D_input:boolean=false; const D_diagonal:boolean=false; const D_k:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixSetDiagV3',[I_input,I_diagonal,I_k],['T','align'],['type','string'],[@F_T,@A_align],[D_input,D_diagonal,D_k])
  end;
function ExecMatrixSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('MatrixSolve',[I_matrix,I_rhs],['adjoint','T'],['bool','type'],[@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecMatrixSolveLs(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const I_l2_regularizer:TF_TensorPtr; const A_fast:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false; const D_l2_regularizer:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('MatrixSolveLs',[I_matrix,I_rhs,I_l2_regularizer],['T','fast'],['type','bool'],[@F_T,@A_fast],[D_matrix,D_rhs,D_l2_regularizer])
  end;
function ExecMatrixSquareRoot(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MatrixSquareRoot',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecMatrixTriangularSolve(const I_matrix:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_lower:boolean; const A_adjoint:boolean; const D_matrix:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_matrix);
  result:=ExecOper('MatrixTriangularSolve',[I_matrix,I_rhs],['lower','adjoint','T'],['bool','bool','type'],[@A_lower,@A_adjoint,@F_T],[D_matrix,D_rhs])
  end;
function ExecMax(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Max',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecMaxIntraOpParallelismDataset(const I_input_dataset:TF_TensorPtr; const I_max_intra_op_parallelism:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_max_intra_op_parallelism:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MaxIntraOpParallelismDataset',[I_input_dataset,I_max_intra_op_parallelism],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_max_intra_op_parallelism])
  end;
function ExecMaxPool(const I_input:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MaxPool',[I_input],['T','ksize','strides','padding','data_format'],['type','list(int)','list(int)','string','string'],[@F_T,@A_ksize,@A_strides,@A_padding,@A_data_format],[D_input])
  end;
function ExecMaxPool3D(const I_input:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MaxPool3D',[I_input],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_input])
  end;
function ExecMaxPool3DGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_TInput:TF_DataType;
    F_T:TF_DataType;
  begin
  F_TInput:=TF_TensorType(I_orig_input);
  F_T:=TF_TensorType(I_grad);
  result:=ExecOper('MaxPool3DGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T','TInput'],['list(int)','list(int)','string','string','type','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T,@F_TInput],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPool3DGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPool3DGradGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPoolGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPoolGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPoolGradGrad(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPoolGradGrad',[I_orig_input,I_orig_output,I_grad],['ksize','strides','padding','data_format','T'],['list(int)','list(int)','string','string','type'],[@A_ksize,@A_strides,@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad])
  end;
function ExecMaxPoolGradGradV2(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_ksize:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false; const D_ksize:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPoolGradGradV2',[I_orig_input,I_orig_output,I_grad,I_ksize,I_strides],['padding','data_format','T'],['string','string','type'],[@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad,D_ksize,D_strides])
  end;
function ExecMaxPoolGradGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_include_batch_in_index:boolean; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Targmax:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Targmax:=TF_TensorType(I_argmax);
  result:=ExecOper('MaxPoolGradGradWithArgmax',[I_input,I_grad,I_argmax],['ksize','strides','padding','include_batch_in_index','Targmax','T'],['list(int)','list(int)','string','bool','type','type'],[@A_ksize,@A_strides,@A_padding,@A_include_batch_in_index,@F_Targmax,@F_T],[D_input,D_grad,D_argmax])
  end;
function ExecMaxPoolGradV2(const I_orig_input:TF_TensorPtr; const I_orig_output:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_ksize:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_padding:string; const A_data_format:string; const D_orig_input:boolean=false; const D_orig_output:boolean=false; const D_grad:boolean=false; const D_ksize:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_orig_input);
  result:=ExecOper('MaxPoolGradV2',[I_orig_input,I_orig_output,I_grad,I_ksize,I_strides],['padding','data_format','T'],['string','string','type'],[@A_padding,@A_data_format,@F_T],[D_orig_input,D_orig_output,D_grad,D_ksize,D_strides])
  end;
function ExecMaxPoolGradWithArgmax(const I_input:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_argmax:TF_TensorPtr; const A_ksize:array of integer; const A_strides:array of integer; const A_padding:string; const A_include_batch_in_index:boolean; const D_input:boolean=false; const D_grad:boolean=false; const D_argmax:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Targmax:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Targmax:=TF_TensorType(I_argmax);
  result:=ExecOper('MaxPoolGradWithArgmax',[I_input,I_grad,I_argmax],['ksize','strides','padding','include_batch_in_index','Targmax','T'],['list(int)','list(int)','string','bool','type','type'],[@A_ksize,@A_strides,@A_padding,@A_include_batch_in_index,@F_Targmax,@F_T],[D_input,D_grad,D_argmax])
  end;
function ExecMaxPoolV2(const I_input:TF_TensorPtr; const I_ksize:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_padding:string; const A_data_format:string; const D_input:boolean=false; const D_ksize:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('MaxPoolV2',[I_input,I_ksize,I_strides],['T','padding','data_format'],['type','string','string'],[@F_T,@A_padding,@A_data_format],[D_input,D_ksize,D_strides])
  end;
function ExecMaximum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Maximum',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMean(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Mean',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecMfcc(const I_spectrogram:TF_TensorPtr; const I_sample_rate:TF_TensorPtr; const A_upper_frequency_limit:real; const A_lower_frequency_limit:real; const A_filterbank_channel_count:integer; const A_dct_coefficient_count:integer; const D_spectrogram:boolean=false; const D_sample_rate:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Mfcc',[I_spectrogram,I_sample_rate],['upper_frequency_limit','lower_frequency_limit','filterbank_channel_count','dct_coefficient_count'],['float','float','int','int'],[@A_upper_frequency_limit,@A_lower_frequency_limit,@A_filterbank_channel_count,@A_dct_coefficient_count],[D_spectrogram,D_sample_rate])
  end;
function ExecMin(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Min',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecMinimum(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Minimum',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMirrorPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('MirrorPad',[I_input,I_paddings],['T','Tpaddings','mode'],['type','type','string'],[@F_T,@F_Tpaddings,@A_mode],[D_input,D_paddings])
  end;
function ExecMirrorPadGrad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_mode:string; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('MirrorPadGrad',[I_input,I_paddings],['T','Tpaddings','mode'],['type','type','string'],[@F_T,@F_Tpaddings,@A_mode],[D_input,D_paddings])
  end;
function ExecMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Mod',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecModelDataset(const I_input_dataset:TF_TensorPtr; const A_algorithm:integer; const A_cpu_budget:integer; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ModelDataset',[I_input_dataset],['algorithm','cpu_budget','output_types','output_shapes'],['int','int','list(type)','list(shape)'],[@A_algorithm,@A_cpu_budget,@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecMul(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Mul',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMulNoNan(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('MulNoNan',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecMultiDeviceIterator(const A_devices:array of string; const A_shared_name:string; const A_container:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('MultiDeviceIterator',[],['devices','shared_name','container','output_types','output_shapes'],['list(string)','string','string','list(type)','list(shape)'],[@A_devices,@A_shared_name,@A_container,@A_output_types,@A_output_shapes],[])
  end;
function ExecMultiDeviceIteratorFromStringHandle(const I_string_handle:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_string_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MultiDeviceIteratorFromStringHandle',[I_string_handle],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_string_handle])
  end;
function ExecMultiDeviceIteratorInit(const I_dataset:TF_TensorPtr; const I_multi_device_iterator:TF_TensorPtr; const I_max_buffer_size:TF_TensorPtr; const D_dataset:boolean=false; const D_multi_device_iterator:boolean=false; const D_max_buffer_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MultiDeviceIteratorInit',[I_dataset,I_multi_device_iterator,I_max_buffer_size],[],[],[],[D_dataset,D_multi_device_iterator,D_max_buffer_size])
  end;
function ExecMultiDeviceIteratorToStringHandle(const I_multi_device_iterator:TF_TensorPtr; const D_multi_device_iterator:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MultiDeviceIteratorToStringHandle',[I_multi_device_iterator],[],[],[],[D_multi_device_iterator])
  end;
function ExecMultinomial(const I_logits:TF_TensorPtr; const I_num_samples:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_output_dtype:TF_DataType; const D_logits:boolean=false; const D_num_samples:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  result:=ExecOper('Multinomial',[I_logits,I_num_samples],['seed','seed2','T','output_dtype'],['int','int','type','type'],[@A_seed,@A_seed2,@F_T,@A_output_dtype],[D_logits,D_num_samples])
  end;
function ExecMutableDenseHashTable(const I_empty_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:integer; const A_max_load_factor:real; const D_empty_key:boolean=false):TF_TensorPtr;
  var
    F_key_dtype:TF_DataType;
  begin
  F_key_dtype:=TF_TensorType(I_empty_key);
  result:=ExecOper('MutableDenseHashTable',[I_empty_key],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@F_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor],[D_empty_key])
  end;
function ExecMutableDenseHashTableV2(const I_empty_key:TF_TensorPtr; const I_deleted_key:TF_TensorPtr; const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape; const A_initial_num_buckets:integer; const A_max_load_factor:real; const D_empty_key:boolean=false; const D_deleted_key:boolean=false):TF_TensorPtr;
  var
    F_key_dtype:TF_DataType;
  begin
  F_key_dtype:=TF_TensorType(I_empty_key);
  result:=ExecOper('MutableDenseHashTableV2',[I_empty_key,I_deleted_key],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape','initial_num_buckets','max_load_factor'],['string','string','bool','type','type','shape','int','float'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@F_key_dtype,@A_value_dtype,@A_value_shape,@A_initial_num_buckets,@A_max_load_factor],[D_empty_key,D_deleted_key])
  end;
function ExecMutableHashTable(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTable',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecMutableHashTableOfTensors(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTableOfTensors',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape],[])
  end;
function ExecMutableHashTableOfTensorsV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType; const A_value_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTableOfTensorsV2',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype','value_shape'],['string','string','bool','type','type','shape'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype,@A_value_shape],[])
  end;
function ExecMutableHashTableV2(const A_container:string; const A_shared_name:string; const A_use_node_name_sharing:boolean; const A_key_dtype:TF_DataType; const A_value_dtype:TF_DataType):TF_TensorPtr;
  begin
  result:=ExecOper('MutableHashTableV2',[],['container','shared_name','use_node_name_sharing','key_dtype','value_dtype'],['string','string','bool','type','type'],[@A_container,@A_shared_name,@A_use_node_name_sharing,@A_key_dtype,@A_value_dtype],[])
  end;
function ExecMutexLock(const I_mutex:TF_TensorPtr; const D_mutex:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('MutexLock',[I_mutex],[],[],[],[D_mutex])
  end;
function ExecMutexV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('MutexV2',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecNcclAllReduce(const I_input:TF_TensorPtr; const A_reduction:string; const A_num_devices:integer; const A_shared_name:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('NcclAllReduce',[I_input],['reduction','T','num_devices','shared_name'],['string','type','int','string'],[@A_reduction,@F_T,@A_num_devices,@A_shared_name],[D_input])
  end;
function ExecNcclBroadcast(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('NcclBroadcast',[I_input],['T','shape'],['type','shape'],[@F_T,@A_shape],[D_input])
  end;
function ExecNdtri(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Ndtri',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecNeg(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Neg',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecNextAfter(const I_x1:TF_TensorPtr; const I_x2:TF_TensorPtr; const D_x1:boolean=false; const D_x2:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x1);
  result:=ExecOper('NextAfter',[I_x1,I_x2],['T'],['type'],[@F_T],[D_x1,D_x2])
  end;
function ExecNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('NextIteration',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecNonDeterministicInts(const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  result:=ExecOper('NonDeterministicInts',[I_shape],['dtype','shape_dtype'],['type','type'],[@A_dtype,@F_shape_dtype],[D_shape])
  end;
function ExecNonMaxSuppression(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const A_iou_threshold:real; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('NonMaxSuppression',[I_boxes,I_scores,I_max_output_size],['iou_threshold'],['float'],[@A_iou_threshold],[D_boxes,D_scores,D_max_output_size])
  end;
function ExecNonMaxSuppressionV2(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_iou_threshold:TF_TensorPtr; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_iou_threshold:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_T_threshold:TF_DataType;
  begin
  F_T:=TF_TensorType(I_boxes);
  F_T_threshold:=TF_TensorType(I_iou_threshold);
  result:=ExecOper('NonMaxSuppressionV2',[I_boxes,I_scores,I_max_output_size,I_iou_threshold],['T','T_threshold'],['type','type'],[@F_T,@F_T_threshold],[D_boxes,D_scores,D_max_output_size,D_iou_threshold])
  end;
function ExecNonMaxSuppressionV3(const I_boxes:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_iou_threshold:TF_TensorPtr; const I_score_threshold:TF_TensorPtr; const D_boxes:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_iou_threshold:boolean=false; const D_score_threshold:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_T_threshold:TF_DataType;
  begin
  F_T:=TF_TensorType(I_boxes);
  F_T_threshold:=TF_TensorType(I_iou_threshold);
  result:=ExecOper('NonMaxSuppressionV3',[I_boxes,I_scores,I_max_output_size,I_iou_threshold,I_score_threshold],['T','T_threshold'],['type','type'],[@F_T,@F_T_threshold],[D_boxes,D_scores,D_max_output_size,D_iou_threshold,D_score_threshold])
  end;
function ExecNonMaxSuppressionWithOverlaps(const I_overlaps:TF_TensorPtr; const I_scores:TF_TensorPtr; const I_max_output_size:TF_TensorPtr; const I_overlap_threshold:TF_TensorPtr; const I_score_threshold:TF_TensorPtr; const D_overlaps:boolean=false; const D_scores:boolean=false; const D_max_output_size:boolean=false; const D_overlap_threshold:boolean=false; const D_score_threshold:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('NonMaxSuppressionWithOverlaps',[I_overlaps,I_scores,I_max_output_size,I_overlap_threshold,I_score_threshold],[],[],[],[D_overlaps,D_scores,D_max_output_size,D_overlap_threshold,D_score_threshold])
  end;
function ExecNonSerializableDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('NonSerializableDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecNotEqual(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const A_incompatible_shape_error:boolean; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('NotEqual',[I_x,I_y],['T','incompatible_shape_error'],['type','bool'],[@F_T,@A_incompatible_shape_error],[D_x,D_y])
  end;
function ExecNthElement(const I_input:TF_TensorPtr; const I_n:TF_TensorPtr; const A_reverse:boolean; const D_input:boolean=false; const D_n:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('NthElement',[I_input,I_n],['reverse','T'],['bool','type'],[@A_reverse,@F_T],[D_input,D_n])
  end;
function ExecOneHot(const I_indices:TF_TensorPtr; const I_depth:TF_TensorPtr; const I_on_value:TF_TensorPtr; const I_off_value:TF_TensorPtr; const A_axis:integer; const D_indices:boolean=false; const D_depth:boolean=false; const D_on_value:boolean=false; const D_off_value:boolean=false):TF_TensorPtr;
  var
    F_TI:TF_DataType;
    F_T:TF_DataType;
  begin
  F_TI:=TF_TensorType(I_indices);
  F_T:=TF_TensorType(I_on_value);
  result:=ExecOper('OneHot',[I_indices,I_depth,I_on_value,I_off_value],['axis','T','TI'],['int','type','type'],[@A_axis,@F_T,@F_TI],[D_indices,D_depth,D_on_value,D_off_value])
  end;
function ExecOneShotIterator(const A_dataset_factory:string; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('OneShotIterator',[],['dataset_factory','output_types','output_shapes','container','shared_name'],['func','list(type)','list(shape)','string','string'],[@A_dataset_factory,@A_output_types,@A_output_shapes,@A_container,@A_shared_name],[])
  end;
function ExecOnesLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('OnesLike',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecOptimizeDataset(const I_input_dataset:TF_TensorPtr; const I_optimizations:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_optimization_configs:array of string; const D_input_dataset:boolean=false; const D_optimizations:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('OptimizeDataset',[I_input_dataset,I_optimizations],['output_types','output_shapes','optimization_configs'],['list(type)','list(shape)','list(string)'],[@A_output_types,@A_output_shapes,@A_optimization_configs],[D_input_dataset,D_optimizations])
  end;
function ExecOptionalHasValue(const I_optional:TF_TensorPtr; const D_optional:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('OptionalHasValue',[I_optional],[],[],[],[D_optional])
  end;
function ExecOptionalNone():TF_TensorPtr;
  begin
  result:=ExecOper('OptionalNone',[],[],[],[],[])
  end;
function ExecOrderedMapIncompleteSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('OrderedMapIncompleteSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecOrderedMapSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('OrderedMapSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecOutfeedDequeue(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_device_ordinal:integer):TF_TensorPtr;
  begin
  result:=ExecOper('OutfeedDequeue',[],['dtype','shape','device_ordinal'],['type','shape','int'],[@A_dtype,@A_shape,@A_device_ordinal],[])
  end;
function ExecPad(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('Pad',[I_input,I_paddings],['T','Tpaddings'],['type','type'],[@F_T,@F_Tpaddings],[D_input,D_paddings])
  end;
function ExecPadV2(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const I_constant_values:TF_TensorPtr; const D_input:boolean=false; const D_paddings:boolean=false; const D_constant_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('PadV2',[I_input,I_paddings,I_constant_values],['T','Tpaddings'],['type','type'],[@F_T,@F_Tpaddings],[D_input,D_paddings,D_constant_values])
  end;
function ExecPaddingFIFOQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PaddingFIFOQueue',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecPaddingFIFOQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PaddingFIFOQueueV2',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecParameterizedTruncatedNormal(const I_shape:TF_TensorPtr; const I_means:TF_TensorPtr; const I_stdevs:TF_TensorPtr; const I_minvals:TF_TensorPtr; const I_maxvals:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_means:boolean=false; const D_stdevs:boolean=false; const D_minvals:boolean=false; const D_maxvals:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_dtype:=TF_TensorType(I_means);
  result:=ExecOper('ParameterizedTruncatedNormal',[I_shape,I_means,I_stdevs,I_minvals,I_maxvals],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@F_dtype,@F_T],[D_shape,D_means,D_stdevs,D_minvals,D_maxvals])
  end;
function ExecParseTensor(const I_serialized:TF_TensorPtr; const A_out_type:TF_DataType; const D_serialized:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ParseTensor',[I_serialized],['out_type'],['type'],[@A_out_type],[D_serialized])
  end;
function ExecPlaceholder(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('Placeholder',[],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape],[])
  end;
function ExecPlaceholderV2(const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('PlaceholderV2',[],['dtype','shape'],['type','shape'],[@A_dtype,@A_shape],[])
  end;
function ExecPlaceholderWithDefault(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const D_input:boolean=false):TF_TensorPtr;
  var
    F_dtype:TF_DataType;
  begin
  F_dtype:=TF_TensorType(I_input);
  result:=ExecOper('PlaceholderWithDefault',[I_input],['dtype','shape'],['type','shape'],[@F_dtype,@A_shape],[D_input])
  end;
function ExecPolygamma(const I_a:TF_TensorPtr; const I_x:TF_TensorPtr; const D_a:boolean=false; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_a);
  result:=ExecOper('Polygamma',[I_a,I_x],['T'],['type'],[@F_T],[D_a,D_x])
  end;
function ExecPopulationCount(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('PopulationCount',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecPow(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Pow',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecPrefetchDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_slack_period:integer; const A_legacy_autotune:boolean; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('PrefetchDataset',[I_input_dataset,I_buffer_size],['output_types','output_shapes','slack_period','legacy_autotune'],['list(type)','list(shape)','int','bool'],[@A_output_types,@A_output_shapes,@A_slack_period,@A_legacy_autotune],[D_input_dataset,D_buffer_size])
  end;
function ExecPrelinearize(const I_input:TF_TensorPtr; const A_shape:TF_Shape; const A_layout:array of integer; const D_input:boolean=false):TF_TensorPtr;
  var
    F_dtype:TF_DataType;
  begin
  F_dtype:=TF_TensorType(I_input);
  result:=ExecOper('Prelinearize',[I_input],['dtype','shape','layout'],['type','shape','list(int)'],[@F_dtype,@A_shape,@A_layout],[D_input])
  end;
function ExecPreventGradient(const I_input:TF_TensorPtr; const A_message:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('PreventGradient',[I_input],['T','message'],['type','string'],[@F_T,@A_message],[D_input])
  end;
function ExecPriorityQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PriorityQueue',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecPriorityQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('PriorityQueueV2',[],['component_types','shapes','capacity','container','shared_name'],['list(type)','list(shape)','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_container,@A_shared_name],[])
  end;
function ExecPrivateThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_num_threads:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_threads:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('PrivateThreadPoolDataset',[I_input_dataset,I_num_threads],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_num_threads])
  end;
function ExecProd(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Prod',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecQuantizeAndDequantize(const I_input:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:integer; const A_range_given:boolean; const A_input_min:real; const A_input_max:real; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('QuantizeAndDequantize',[I_input],['signed_input','num_bits','range_given','input_min','input_max','T'],['bool','int','bool','float','float','type'],[@A_signed_input,@A_num_bits,@A_range_given,@A_input_min,@A_input_max,@F_T],[D_input])
  end;
function ExecQuantizeAndDequantizeV2(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const A_signed_input:boolean; const A_num_bits:integer; const A_range_given:boolean; const A_round_mode:string; const A_narrow_range:boolean; const A_axis:integer; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('QuantizeAndDequantizeV2',[I_input,I_input_min,I_input_max],['signed_input','num_bits','range_given','T','round_mode','narrow_range','axis'],['bool','int','bool','type','string','bool','int'],[@A_signed_input,@A_num_bits,@A_range_given,@F_T,@A_round_mode,@A_narrow_range,@A_axis],[D_input,D_input_min,D_input_max])
  end;
function ExecQuantizeAndDequantizeV3(const I_input:TF_TensorPtr; const I_input_min:TF_TensorPtr; const I_input_max:TF_TensorPtr; const I_num_bits:TF_TensorPtr; const A_signed_input:boolean; const A_range_given:boolean; const A_narrow_range:boolean; const A_axis:integer; const D_input:boolean=false; const D_input_min:boolean=false; const D_input_max:boolean=false; const D_num_bits:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('QuantizeAndDequantizeV3',[I_input,I_input_min,I_input_max,I_num_bits],['signed_input','range_given','T','narrow_range','axis'],['bool','bool','type','bool','int'],[@A_signed_input,@A_range_given,@F_T,@A_narrow_range,@A_axis],[D_input,D_input_min,D_input_max,D_num_bits])
  end;
function ExecQueueIsClosed(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueIsClosed',[I_handle],[],[],[],[D_handle])
  end;
function ExecQueueIsClosedV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueIsClosedV2',[I_handle],[],[],[],[D_handle])
  end;
function ExecQueueSize(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueSize',[I_handle],[],[],[],[D_handle])
  end;
function ExecQueueSizeV2(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('QueueSizeV2',[I_handle],[],[],[],[D_handle])
  end;
function ExecRFFT(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Tcomplex:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  var
    F_Treal:TF_DataType;
  begin
  F_Treal:=TF_TensorType(I_input);
  result:=ExecOper('RFFT',[I_input,I_fft_length],['Treal','Tcomplex'],['type','type'],[@F_Treal,@A_Tcomplex],[D_input,D_fft_length])
  end;
function ExecRFFT2D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Tcomplex:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  var
    F_Treal:TF_DataType;
  begin
  F_Treal:=TF_TensorType(I_input);
  result:=ExecOper('RFFT2D',[I_input,I_fft_length],['Treal','Tcomplex'],['type','type'],[@F_Treal,@A_Tcomplex],[D_input,D_fft_length])
  end;
function ExecRFFT3D(const I_input:TF_TensorPtr; const I_fft_length:TF_TensorPtr; const A_Tcomplex:TF_DataType; const D_input:boolean=false; const D_fft_length:boolean=false):TF_TensorPtr;
  var
    F_Treal:TF_DataType;
  begin
  F_Treal:=TF_TensorType(I_input);
  result:=ExecOper('RFFT3D',[I_input,I_fft_length],['Treal','Tcomplex'],['type','type'],[@F_Treal,@A_Tcomplex],[D_input,D_fft_length])
  end;
function ExecRGBToHSV(const I_images:TF_TensorPtr; const D_images:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('RGBToHSV',[I_images],['T'],['type'],[@F_T],[D_images])
  end;
function ExecRandomCrop(const I_image:TF_TensorPtr; const I_size:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_image:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_image);
  result:=ExecOper('RandomCrop',[I_image,I_size],['T','seed','seed2'],['type','int','int'],[@F_T,@A_seed,@A_seed2],[D_image,D_size])
  end;
function ExecRandomDataset(const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RandomDataset',[I_seed,I_seed2],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_seed,D_seed2])
  end;
function ExecRandomGamma(const I_shape:TF_TensorPtr; const I_alpha:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_alpha:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_T:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_T:=TF_TensorType(I_alpha);
  result:=ExecOper('RandomGamma',[I_shape,I_alpha],['seed','seed2','S','T'],['int','int','type','type'],[@A_seed,@A_seed2,@F_S,@F_T],[D_shape,D_alpha])
  end;
function ExecRandomGammaGrad(const I_alpha:TF_TensorPtr; const I_sample:TF_TensorPtr; const D_alpha:boolean=false; const D_sample:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_alpha);
  result:=ExecOper('RandomGammaGrad',[I_alpha,I_sample],['T'],['type'],[@F_T],[D_alpha,D_sample])
  end;
function ExecRandomPoisson(const I_shape:TF_TensorPtr; const I_rate:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_rate:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_dtype:=TF_TensorType(I_rate);
  result:=ExecOper('RandomPoisson',[I_shape,I_rate],['seed','seed2','S','dtype'],['int','int','type','type'],[@A_seed,@A_seed2,@F_S,@F_dtype],[D_shape,D_rate])
  end;
function ExecRandomPoissonV2(const I_shape:TF_TensorPtr; const I_rate:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_rate:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_R:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_R:=TF_TensorType(I_rate);
  result:=ExecOper('RandomPoissonV2',[I_shape,I_rate],['seed','seed2','S','R','dtype'],['int','int','type','type','type'],[@A_seed,@A_seed2,@F_S,@F_R,@A_dtype],[D_shape,D_rate])
  end;
function ExecRandomShuffle(const I_value:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('RandomShuffle',[I_value],['seed','seed2','T'],['int','int','type'],[@A_seed,@A_seed2,@F_T],[D_value])
  end;
function ExecRandomShuffleQueue(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_min_after_dequeue:integer; const A_seed:integer; const A_seed2:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('RandomShuffleQueue',[],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name],[])
  end;
function ExecRandomShuffleQueueV2(const A_component_types:array of TF_DataType; const A_shapes:array of TF_Shape; const A_capacity:integer; const A_min_after_dequeue:integer; const A_seed:integer; const A_seed2:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('RandomShuffleQueueV2',[],['component_types','shapes','capacity','min_after_dequeue','seed','seed2','container','shared_name'],['list(type)','list(shape)','int','int','int','int','string','string'],[@A_component_types,@A_shapes,@A_capacity,@A_min_after_dequeue,@A_seed,@A_seed2,@A_container,@A_shared_name],[])
  end;
function ExecRandomStandardNormal(const I_shape:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('RandomStandardNormal',[I_shape],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@F_T],[D_shape])
  end;
function ExecRandomUniform(const I_shape:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('RandomUniform',[I_shape],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@F_T],[D_shape])
  end;
function ExecRandomUniformInt(const I_shape:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const D_shape:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tout:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tout:=TF_TensorType(I_minval);
  result:=ExecOper('RandomUniformInt',[I_shape,I_minval,I_maxval],['seed','seed2','Tout','T'],['int','int','type','type'],[@A_seed,@A_seed2,@F_Tout,@F_T],[D_shape,D_minval,D_maxval])
  end;
function ExecRange(const I_start:TF_TensorPtr; const I_limit:TF_TensorPtr; const I_delta:TF_TensorPtr; const D_start:boolean=false; const D_limit:boolean=false; const D_delta:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_start);
  result:=ExecOper('Range',[I_start,I_limit,I_delta],['Tidx'],['type'],[@F_Tidx],[D_start,D_limit,D_delta])
  end;
function ExecRangeDataset(const I_start:TF_TensorPtr; const I_stop:TF_TensorPtr; const I_step:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_start:boolean=false; const D_stop:boolean=false; const D_step:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RangeDataset',[I_start,I_stop,I_step],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_start,D_stop,D_step])
  end;
function ExecRank(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Rank',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecReadFile(const I_filename:TF_TensorPtr; const D_filename:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReadFile',[I_filename],[],[],[],[D_filename])
  end;
function ExecReadVariableOp(const I_resource:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReadVariableOp',[I_resource],['dtype'],['type'],[@A_dtype],[D_resource])
  end;
function ExecReaderNumRecordsProduced(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumRecordsProduced',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderNumRecordsProducedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumRecordsProducedV2',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderNumWorkUnitsCompleted(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumWorkUnitsCompleted',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderNumWorkUnitsCompletedV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderNumWorkUnitsCompletedV2',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderSerializeState(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderSerializeState',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReaderSerializeStateV2(const I_reader_handle:TF_TensorPtr; const D_reader_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReaderSerializeStateV2',[I_reader_handle],[],[],[],[D_reader_handle])
  end;
function ExecReal(const I_input:TF_TensorPtr; const A_Tout:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Real',[I_input],['T','Tout'],['type','type'],[@F_T,@A_Tout],[D_input])
  end;
function ExecRealDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('RealDiv',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecRebatchDataset(const I_input_dataset:TF_TensorPtr; const I_num_replicas:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_use_fallback:boolean; const D_input_dataset:boolean=false; const D_num_replicas:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RebatchDataset',[I_input_dataset,I_num_replicas],['output_types','output_shapes','use_fallback'],['list(type)','list(shape)','bool'],[@A_output_types,@A_output_shapes,@A_use_fallback],[D_input_dataset,D_num_replicas])
  end;
function ExecReciprocal(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Reciprocal',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecReciprocalGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('ReciprocalGrad',[I_y,I_dy],['T'],['type'],[@F_T],[D_y,D_dy])
  end;
function ExecRecordInput(const A_file_pattern:string; const A_file_random_seed:integer; const A_file_shuffle_shift_ratio:real; const A_file_buffer_size:integer; const A_file_parallelism:integer; const A_batch_size:integer; const A_compression_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('RecordInput',[],['file_pattern','file_random_seed','file_shuffle_shift_ratio','file_buffer_size','file_parallelism','batch_size','compression_type'],['string','int','float','int','int','int','string'],[@A_file_pattern,@A_file_random_seed,@A_file_shuffle_shift_ratio,@A_file_buffer_size,@A_file_parallelism,@A_batch_size,@A_compression_type],[])
  end;
function ExecRecv(const A_tensor_type:TF_DataType; const A_tensor_name:string; const A_send_device:string; const A_send_device_incarnation:integer; const A_recv_device:string; const A_client_terminated:boolean):TF_TensorPtr;
  begin
  result:=ExecOper('Recv',[],['tensor_type','tensor_name','send_device','send_device_incarnation','recv_device','client_terminated'],['type','string','string','int','string','bool'],[@A_tensor_type,@A_tensor_name,@A_send_device,@A_send_device_incarnation,@A_recv_device,@A_client_terminated],[])
  end;
function ExecReduceJoin(const I_inputs:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const A_separator:string; const D_inputs:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ReduceJoin',[I_inputs,I_reduction_indices],['keep_dims','separator'],['bool','string'],[@A_keep_dims,@A_separator],[D_inputs,D_reduction_indices])
  end;
function ExecRefEnter(const I_data:TF_TensorPtr; const A_frame_name:string; const A_is_constant:boolean; const A_parallel_iterations:integer; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('RefEnter',[I_data],['T','frame_name','is_constant','parallel_iterations'],['type','string','bool','int'],[@F_T,@A_frame_name,@A_is_constant,@A_parallel_iterations],[D_data])
  end;
function ExecRefExit(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('RefExit',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecRefIdentity(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('RefIdentity',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecRefNextIteration(const I_data:TF_TensorPtr; const D_data:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  result:=ExecOper('RefNextIteration',[I_data],['T'],['type'],[@F_T],[D_data])
  end;
function ExecRegexFullMatch(const I_input:TF_TensorPtr; const I_pattern:TF_TensorPtr; const D_input:boolean=false; const D_pattern:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RegexFullMatch',[I_input,I_pattern],[],[],[],[D_input,D_pattern])
  end;
function ExecRegexReplace(const I_input:TF_TensorPtr; const I_pattern:TF_TensorPtr; const I_rewrite:TF_TensorPtr; const A_replace_global:boolean; const D_input:boolean=false; const D_pattern:boolean=false; const D_rewrite:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RegexReplace',[I_input,I_pattern,I_rewrite],['replace_global'],['bool'],[@A_replace_global],[D_input,D_pattern,D_rewrite])
  end;
function ExecRelu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Relu',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecRelu6(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Relu6',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecRelu6Grad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('Relu6Grad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecReluGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('ReluGrad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecRepeatDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RepeatDataset',[I_input_dataset,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_count])
  end;
function ExecReshape(const I_tensor:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tshape:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tshape:=TF_TensorType(I_shape);
  result:=ExecOper('Reshape',[I_tensor,I_shape],['T','Tshape'],['type','type'],[@F_T,@F_Tshape],[D_tensor,D_shape])
  end;
function ExecResizeArea(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeArea',[I_images,I_size],['T','align_corners'],['type','bool'],[@F_T,@A_align_corners],[D_images,D_size])
  end;
function ExecResizeBicubic(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeBicubic',[I_images,I_size],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@F_T,@A_align_corners,@A_half_pixel_centers],[D_images,D_size])
  end;
function ExecResizeBicubicGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_grads:boolean=false; const D_original_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_original_image);
  result:=ExecOper('ResizeBicubicGrad',[I_grads,I_original_image],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@F_T,@A_align_corners,@A_half_pixel_centers],[D_grads,D_original_image])
  end;
function ExecResizeBilinear(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeBilinear',[I_images,I_size],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@F_T,@A_align_corners,@A_half_pixel_centers],[D_images,D_size])
  end;
function ExecResizeBilinearGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_grads:boolean=false; const D_original_image:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_original_image);
  result:=ExecOper('ResizeBilinearGrad',[I_grads,I_original_image],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@F_T,@A_align_corners,@A_half_pixel_centers],[D_grads,D_original_image])
  end;
function ExecResizeNearestNeighbor(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_images:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ResizeNearestNeighbor',[I_images,I_size],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@F_T,@A_align_corners,@A_half_pixel_centers],[D_images,D_size])
  end;
function ExecResizeNearestNeighborGrad(const I_grads:TF_TensorPtr; const I_size:TF_TensorPtr; const A_align_corners:boolean; const A_half_pixel_centers:boolean; const D_grads:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grads);
  result:=ExecOper('ResizeNearestNeighborGrad',[I_grads,I_size],['T','align_corners','half_pixel_centers'],['type','bool','bool'],[@F_T,@A_align_corners,@A_half_pixel_centers],[D_grads,D_size])
  end;
function ExecResourceAccumulatorNumAccumulated(const I_handle:TF_TensorPtr; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ResourceAccumulatorNumAccumulated',[I_handle],[],[],[],[D_handle])
  end;
function ExecResourceAccumulatorTakeGradient(const I_handle:TF_TensorPtr; const I_num_required:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_num_required:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ResourceAccumulatorTakeGradient',[I_handle,I_num_required],['dtype'],['type'],[@A_dtype],[D_handle,D_num_required])
  end;
function ExecResourceConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('ResourceConditionalAccumulator',[],['dtype','shape','container','shared_name','reduction_type'],['type','shape','string','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name,@A_reduction_type],[])
  end;
function ExecResourceCountUpTo(const I_resource:TF_TensorPtr; const A_limit:integer; const A_T:TF_DataType; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ResourceCountUpTo',[I_resource],['limit','T'],['int','type'],[@A_limit,@A_T],[D_resource])
  end;
function ExecResourceGather(const I_resource:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_batch_dims:integer; const A_validate_indices:boolean; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ResourceGather',[I_resource,I_indices],['batch_dims','validate_indices','dtype','Tindices'],['int','bool','type','type'],[@A_batch_dims,@A_validate_indices,@A_dtype,@F_Tindices],[D_resource,D_indices])
  end;
function ExecResourceGatherNd(const I_resource:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ResourceGatherNd',[I_resource,I_indices],['dtype','Tindices'],['type','type'],[@A_dtype,@F_Tindices],[D_resource,D_indices])
  end;
function ExecRestore(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:integer; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Restore',[I_file_pattern,I_tensor_name],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard],[D_file_pattern,D_tensor_name])
  end;
function ExecRestoreSlice(const I_file_pattern:TF_TensorPtr; const I_tensor_name:TF_TensorPtr; const I_shape_and_slice:TF_TensorPtr; const A_dt:TF_DataType; const A_preferred_shard:integer; const D_file_pattern:boolean=false; const D_tensor_name:boolean=false; const D_shape_and_slice:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('RestoreSlice',[I_file_pattern,I_tensor_name,I_shape_and_slice],['dt','preferred_shard'],['type','int'],[@A_dt,@A_preferred_shard],[D_file_pattern,D_tensor_name,D_shape_and_slice])
  end;
function ExecRetrieveTPUEmbeddingStochasticGradientDescentParameters(const A_table_id:integer; const A_table_name:string; const A_num_shards:integer; const A_shard_id:integer; const A_config:string):TF_TensorPtr;
  begin
  result:=ExecOper('RetrieveTPUEmbeddingStochasticGradientDescentParameters',[],['table_id','table_name','num_shards','shard_id','config'],['int','string','int','int','string'],[@A_table_id,@A_table_name,@A_num_shards,@A_shard_id,@A_config],[])
  end;
function ExecReverse(const I_tensor:TF_TensorPtr; const I_dims:TF_TensorPtr; const D_tensor:boolean=false; const D_dims:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('Reverse',[I_tensor,I_dims],['T'],['type'],[@F_T],[D_tensor,D_dims])
  end;
function ExecReverseSequence(const I_input:TF_TensorPtr; const I_seq_lengths:TF_TensorPtr; const A_seq_dim:integer; const A_batch_dim:integer; const D_input:boolean=false; const D_seq_lengths:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tlen:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tlen:=TF_TensorType(I_seq_lengths);
  result:=ExecOper('ReverseSequence',[I_input,I_seq_lengths],['seq_dim','batch_dim','T','Tlen'],['int','int','type','type'],[@A_seq_dim,@A_batch_dim,@F_T,@F_Tlen],[D_input,D_seq_lengths])
  end;
function ExecReverseV2(const I_tensor:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_tensor:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tidx:=TF_TensorType(I_axis);
  result:=ExecOper('ReverseV2',[I_tensor,I_axis],['Tidx','T'],['type','type'],[@F_Tidx,@F_T],[D_tensor,D_axis])
  end;
function ExecRightShift(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('RightShift',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecRint(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Rint',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecRoll(const I_input:TF_TensorPtr; const I_shift:TF_TensorPtr; const I_axis:TF_TensorPtr; const D_input:boolean=false; const D_shift:boolean=false; const D_axis:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tshift:TF_DataType;
    F_Taxis:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tshift:=TF_TensorType(I_shift);
  F_Taxis:=TF_TensorType(I_axis);
  result:=ExecOper('Roll',[I_input,I_shift,I_axis],['T','Tshift','Taxis'],['type','type','type'],[@F_T,@F_Tshift,@F_Taxis],[D_input,D_shift,D_axis])
  end;
function ExecRound(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Round',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecRpc(const I_address:TF_TensorPtr; const I_method:TF_TensorPtr; const I_request:TF_TensorPtr; const A_protocol:string; const A_fail_fast:boolean; const A_timeout_in_ms:integer; const D_address:boolean=false; const D_method:boolean=false; const D_request:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('Rpc',[I_address,I_method,I_request],['protocol','fail_fast','timeout_in_ms'],['string','bool','int'],[@A_protocol,@A_fail_fast,@A_timeout_in_ms],[D_address,D_method,D_request])
  end;
function ExecRsqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Rsqrt',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecRsqrtGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('RsqrtGrad',[I_y,I_dy],['T'],['type'],[@F_T],[D_y,D_dy])
  end;
function ExecSamplingDataset(const I_input_dataset:TF_TensorPtr; const I_rate:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_rate:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SamplingDataset',[I_input_dataset,I_rate,I_seed,I_seed2],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_rate,D_seed,D_seed2])
  end;
function ExecScalarSummary(const I_tags:TF_TensorPtr; const I_values:TF_TensorPtr; const D_tags:boolean=false; const D_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_values);
  result:=ExecOper('ScalarSummary',[I_tags,I_values],['T'],['type'],[@F_T],[D_tags,D_values])
  end;
function ExecScaleAndTranslate(const I_images:TF_TensorPtr; const I_size:TF_TensorPtr; const I_scale:TF_TensorPtr; const I_translation:TF_TensorPtr; const A_kernel_type:string; const A_antialias:boolean; const D_images:boolean=false; const D_size:boolean=false; const D_scale:boolean=false; const D_translation:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_images);
  result:=ExecOper('ScaleAndTranslate',[I_images,I_size,I_scale,I_translation],['T','kernel_type','antialias'],['type','string','bool'],[@F_T,@A_kernel_type,@A_antialias],[D_images,D_size,D_scale,D_translation])
  end;
function ExecScaleAndTranslateGrad(const I_grads:TF_TensorPtr; const I_original_image:TF_TensorPtr; const I_scale:TF_TensorPtr; const I_translation:TF_TensorPtr; const A_kernel_type:string; const A_antialias:boolean; const D_grads:boolean=false; const D_original_image:boolean=false; const D_scale:boolean=false; const D_translation:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grads);
  result:=ExecOper('ScaleAndTranslateGrad',[I_grads,I_original_image,I_scale,I_translation],['T','kernel_type','antialias'],['type','string','bool'],[@F_T,@A_kernel_type,@A_antialias],[D_grads,D_original_image,D_scale,D_translation])
  end;
function ExecScatterAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterAdd',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterDiv(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterDiv',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterMax(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterMax',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterMin(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterMin',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterMul(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterMul',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterNd(const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const I_shape:TF_TensorPtr; const D_indices:boolean=false; const D_updates:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_indices);
  F_T:=TF_TensorType(I_updates);
  result:=ExecOper('ScatterNd',[I_indices,I_updates,I_shape],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_indices,D_updates,D_shape])
  end;
function ExecScatterNdAdd(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdAdd',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterNdNonAliasingAdd(const I_input:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_input:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdNonAliasingAdd',[I_input,I_indices,I_updates],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_input,D_indices,D_updates])
  end;
function ExecScatterNdSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdSub',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterNdUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterNdUpdate',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterSub(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterSub',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecScatterUpdate(const I_ref:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const A_use_locking:boolean; const D_ref:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('ScatterUpdate',[I_ref,I_indices,I_updates],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_ref,D_indices,D_updates])
  end;
function ExecSdcaFprint(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SdcaFprint',[I_input],[],[],[],[D_input])
  end;
function ExecSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentMax',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentMean(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentMean',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentMin(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentMin',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentProd(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentProd',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  result:=ExecOper('SegmentSum',[I_data,I_segment_ids],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_data,D_segment_ids])
  end;
function ExecSelect(const I_condition:TF_TensorPtr; const I_t:TF_TensorPtr; const I_e:TF_TensorPtr; const D_condition:boolean=false; const D_t:boolean=false; const D_e:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('Select',[I_condition,I_t,I_e],['T'],['type'],[@F_T],[D_condition,D_t,D_e])
  end;
function ExecSelectV2(const I_condition:TF_TensorPtr; const I_t:TF_TensorPtr; const I_e:TF_TensorPtr; const D_condition:boolean=false; const D_t:boolean=false; const D_e:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_t);
  result:=ExecOper('SelectV2',[I_condition,I_t,I_e],['T'],['type'],[@F_T],[D_condition,D_t,D_e])
  end;
function ExecSelfAdjointEig(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('SelfAdjointEig',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecSelu(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Selu',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecSeluGrad(const I_gradients:TF_TensorPtr; const I_outputs:TF_TensorPtr; const D_gradients:boolean=false; const D_outputs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('SeluGrad',[I_gradients,I_outputs],['T'],['type'],[@F_T],[D_gradients,D_outputs])
  end;
function ExecSerializeIterator(const I_resource_handle:TF_TensorPtr; const A_external_state_policy:integer; const D_resource_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SerializeIterator',[I_resource_handle],['external_state_policy'],['int'],[@A_external_state_policy],[D_resource_handle])
  end;
function ExecSerializeManySparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_out_type:TF_DataType; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('SerializeManySparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecSerializeSparse(const I_sparse_indices:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_sparse_shape:TF_TensorPtr; const A_out_type:TF_DataType; const D_sparse_indices:boolean=false; const D_sparse_values:boolean=false; const D_sparse_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('SerializeSparse',[I_sparse_indices,I_sparse_values,I_sparse_shape],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_sparse_indices,D_sparse_values,D_sparse_shape])
  end;
function ExecSerializeTensor(const I_tensor:TF_TensorPtr; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('SerializeTensor',[I_tensor],['T'],['type'],[@F_T],[D_tensor])
  end;
function ExecSetSize(const I_set_indices:TF_TensorPtr; const I_set_values:TF_TensorPtr; const I_set_shape:TF_TensorPtr; const A_validate_indices:boolean; const D_set_indices:boolean=false; const D_set_values:boolean=false; const D_set_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_set_values);
  result:=ExecOper('SetSize',[I_set_indices,I_set_values,I_set_shape],['validate_indices','T'],['bool','type'],[@A_validate_indices,@F_T],[D_set_indices,D_set_values,D_set_shape])
  end;
function ExecSetStatsAggregatorDataset(const I_input_dataset:TF_TensorPtr; const I_stats_aggregator:TF_TensorPtr; const I_tag:TF_TensorPtr; const I_counter_prefix:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_stats_aggregator:boolean=false; const D_tag:boolean=false; const D_counter_prefix:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SetStatsAggregatorDataset',[I_input_dataset,I_stats_aggregator,I_tag,I_counter_prefix],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_stats_aggregator,D_tag,D_counter_prefix])
  end;
function ExecShape(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Shape',[I_input],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_input])
  end;
function ExecShardDataset(const I_input_dataset:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const I_index:TF_TensorPtr; const A_require_non_empty:boolean; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_num_shards:boolean=false; const D_index:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShardDataset',[I_input_dataset,I_num_shards,I_index],['require_non_empty','output_types','output_shapes'],['bool','list(type)','list(shape)'],[@A_require_non_empty,@A_output_types,@A_output_shapes],[D_input_dataset,D_num_shards,D_index])
  end;
function ExecShardedFilename(const I_basename:TF_TensorPtr; const I_shard:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_shard:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShardedFilename',[I_basename,I_shard,I_num_shards],[],[],[],[D_basename,D_shard,D_num_shards])
  end;
function ExecShardedFilespec(const I_basename:TF_TensorPtr; const I_num_shards:TF_TensorPtr; const D_basename:boolean=false; const D_num_shards:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShardedFilespec',[I_basename,I_num_shards],[],[],[],[D_basename,D_num_shards])
  end;
function ExecShuffleAndRepeatDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShuffleAndRepeatDataset',[I_input_dataset,I_buffer_size,I_seed,I_seed2,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_buffer_size,D_seed,D_seed2,D_count])
  end;
function ExecShuffleDataset(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_seed2:TF_TensorPtr; const A_reshuffle_each_iteration:boolean; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed:boolean=false; const D_seed2:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShuffleDataset',[I_input_dataset,I_buffer_size,I_seed,I_seed2],['reshuffle_each_iteration','output_types','output_shapes'],['bool','list(type)','list(shape)'],[@A_reshuffle_each_iteration,@A_output_types,@A_output_shapes],[D_input_dataset,D_buffer_size,D_seed,D_seed2])
  end;
function ExecShuffleDatasetV2(const I_input_dataset:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const I_seed_generator:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_buffer_size:boolean=false; const D_seed_generator:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ShuffleDatasetV2',[I_input_dataset,I_buffer_size,I_seed_generator],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_buffer_size,D_seed_generator])
  end;
function ExecSigmoid(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sigmoid',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSigmoidGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('SigmoidGrad',[I_y,I_dy],['T'],['type'],[@F_T],[D_y,D_dy])
  end;
function ExecSign(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sign',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSin(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sin',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSinh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sinh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSize(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Size',[I_input],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_input])
  end;
function ExecSkipDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SkipDataset',[I_input_dataset,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_count])
  end;
function ExecSleepDataset(const I_input_dataset:TF_TensorPtr; const I_sleep_microseconds:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_sleep_microseconds:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SleepDataset',[I_input_dataset,I_sleep_microseconds],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_sleep_microseconds])
  end;
function ExecSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_size:TF_TensorPtr; const D_input:boolean=false; const D_begin:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('Slice',[I_input,I_begin,I_size],['T','Index'],['type','type'],[@F_T,@F_Index],[D_input,D_begin,D_size])
  end;
function ExecSlidingWindowDataset(const I_input_dataset:TF_TensorPtr; const I_window_size:TF_TensorPtr; const I_window_shift:TF_TensorPtr; const I_window_stride:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_window_size:boolean=false; const D_window_shift:boolean=false; const D_window_stride:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SlidingWindowDataset',[I_input_dataset,I_window_size,I_window_shift,I_window_stride],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_window_size,D_window_shift,D_window_stride])
  end;
function ExecSnapshot(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Snapshot',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecSnapshotDataset(const I_input_dataset:TF_TensorPtr; const I_path:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const A_compression:string; const A_reader_path_prefix:string; const A_writer_path_prefix:string; const A_shard_size_bytes:integer; const A_pending_snapshot_expiry_seconds:integer; const A_num_reader_threads:integer; const A_reader_buffer_size:integer; const A_num_writer_threads:integer; const A_writer_buffer_size:integer; const A_shuffle_on_read:boolean; const A_seed:integer; const A_seed2:integer; const A_mode:string; const A_snapshot_name:string; const D_input_dataset:boolean=false; const D_path:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SnapshotDataset',[I_input_dataset,I_path],['output_types','output_shapes','compression','reader_path_prefix','writer_path_prefix','shard_size_bytes','pending_snapshot_expiry_seconds','num_reader_threads','reader_buffer_size','num_writer_threads','writer_buffer_size','shuffle_on_read','seed','seed2','mode','snapshot_name'],['list(type)','list(shape)','string','string','string','int','int','int','int','int','int','bool','int','int','string','string'],[@A_output_types,@A_output_shapes,@A_compression,@A_reader_path_prefix,@A_writer_path_prefix,@A_shard_size_bytes,@A_pending_snapshot_expiry_seconds,@A_num_reader_threads,@A_reader_buffer_size,@A_num_writer_threads,@A_writer_buffer_size,@A_shuffle_on_read,@A_seed,@A_seed2,@A_mode,@A_snapshot_name],[D_input_dataset,D_path])
  end;
function ExecSobolSample(const I_dim:TF_TensorPtr; const I_num_results:TF_TensorPtr; const I_skip:TF_TensorPtr; const A_dtype:TF_DataType; const D_dim:boolean=false; const D_num_results:boolean=false; const D_skip:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SobolSample',[I_dim,I_num_results,I_skip],['dtype'],['type'],[@A_dtype],[D_dim,D_num_results,D_skip])
  end;
function ExecSoftmax(const I_logits:TF_TensorPtr; const D_logits:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  result:=ExecOper('Softmax',[I_logits],['T'],['type'],[@F_T],[D_logits])
  end;
function ExecSoftplus(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Softplus',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecSoftplusGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('SoftplusGrad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecSoftsign(const I_features:TF_TensorPtr; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_features);
  result:=ExecOper('Softsign',[I_features],['T'],['type'],[@F_T],[D_features])
  end;
function ExecSoftsignGrad(const I_gradients:TF_TensorPtr; const I_features:TF_TensorPtr; const D_gradients:boolean=false; const D_features:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_gradients);
  result:=ExecOper('SoftsignGrad',[I_gradients,I_features],['T'],['type'],[@F_T],[D_gradients,D_features])
  end;
function ExecSpaceToBatch(const I_input:TF_TensorPtr; const I_paddings:TF_TensorPtr; const A_block_size:integer; const D_input:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('SpaceToBatch',[I_input,I_paddings],['T','Tpaddings','block_size'],['type','type','int'],[@F_T,@F_Tpaddings,@A_block_size],[D_input,D_paddings])
  end;
function ExecSpaceToBatchND(const I_input:TF_TensorPtr; const I_block_shape:TF_TensorPtr; const I_paddings:TF_TensorPtr; const D_input:boolean=false; const D_block_shape:boolean=false; const D_paddings:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tblock_shape:TF_DataType;
    F_Tpaddings:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tblock_shape:=TF_TensorType(I_block_shape);
  F_Tpaddings:=TF_TensorType(I_paddings);
  result:=ExecOper('SpaceToBatchND',[I_input,I_block_shape,I_paddings],['T','Tblock_shape','Tpaddings'],['type','type','type'],[@F_T,@F_Tblock_shape,@F_Tpaddings],[D_input,D_block_shape,D_paddings])
  end;
function ExecSpaceToDepth(const I_input:TF_TensorPtr; const A_block_size:integer; const A_data_format:string; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('SpaceToDepth',[I_input],['T','block_size','data_format'],['type','int','string'],[@F_T,@A_block_size,@A_data_format],[D_input])
  end;
function ExecSparseApplyAdadelta(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_accum_update:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_accum_update:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdadelta',[I_var,I_accum,I_accum_update,I_lr,I_rho,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_accum_update,D_lr,D_rho,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseApplyAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdagrad',[I_var,I_accum,I_lr,I_grad,I_indices],['T','Tindices','use_locking','update_slots'],['type','type','bool','bool'],[@F_T,@F_Tindices,@A_use_locking,@A_update_slots],[D_var,D_accum,D_lr,D_grad,D_indices])
  end;
function ExecSparseApplyAdagradDA(const I_var:TF_TensorPtr; const I_gradient_accumulator:TF_TensorPtr; const I_gradient_squared_accumulator:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_global_step:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_gradient_accumulator:boolean=false; const D_gradient_squared_accumulator:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_global_step:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdagradDA',[I_var,I_gradient_accumulator,I_gradient_squared_accumulator,I_grad,I_indices,I_lr,I_l1,I_l2,I_global_step],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_gradient_accumulator,D_gradient_squared_accumulator,D_grad,D_indices,D_lr,D_l1,D_l2,D_global_step])
  end;
function ExecSparseApplyAdagradV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const A_update_slots:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyAdagradV2',[I_var,I_accum,I_lr,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking','update_slots'],['type','type','bool','bool'],[@F_T,@F_Tindices,@A_use_locking,@A_update_slots],[D_var,D_accum,D_lr,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseApplyCenteredRMSProp(const I_var:TF_TensorPtr; const I_mg:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_mg:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyCenteredRMSProp',[I_var,I_mg,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_mg,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseApplyFtrl(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyFtrl',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_lr_power],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_indices,D_lr,D_l1,D_l2,D_lr_power])
  end;
function ExecSparseApplyFtrlV2(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_linear:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_l2_shrinkage:TF_TensorPtr; const I_lr_power:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_linear:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_l2_shrinkage:boolean=false; const D_lr_power:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyFtrlV2',[I_var,I_accum,I_linear,I_grad,I_indices,I_lr,I_l1,I_l2,I_l2_shrinkage,I_lr_power],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_linear,D_grad,D_indices,D_lr,D_l1,D_l2,D_l2_shrinkage,D_lr_power])
  end;
function ExecSparseApplyMomentum(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_momentum:TF_TensorPtr; const A_use_locking:boolean; const A_use_nesterov:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false; const D_momentum:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyMomentum',[I_var,I_accum,I_lr,I_grad,I_indices,I_momentum],['T','Tindices','use_locking','use_nesterov'],['type','type','bool','bool'],[@F_T,@F_Tindices,@A_use_locking,@A_use_nesterov],[D_var,D_accum,D_lr,D_grad,D_indices,D_momentum])
  end;
function ExecSparseApplyProximalAdagrad(const I_var:TF_TensorPtr; const I_accum:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_accum:boolean=false; const D_lr:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyProximalAdagrad',[I_var,I_accum,I_lr,I_l1,I_l2,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_accum,D_lr,D_l1,D_l2,D_grad,D_indices])
  end;
function ExecSparseApplyProximalGradientDescent(const I_var:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_l1:TF_TensorPtr; const I_l2:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_alpha:boolean=false; const D_l1:boolean=false; const D_l2:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyProximalGradientDescent',[I_var,I_alpha,I_l1,I_l2,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_alpha,D_l1,D_l2,D_grad,D_indices])
  end;
function ExecSparseApplyRMSProp(const I_var:TF_TensorPtr; const I_ms:TF_TensorPtr; const I_mom:TF_TensorPtr; const I_lr:TF_TensorPtr; const I_rho:TF_TensorPtr; const I_momentum:TF_TensorPtr; const I_epsilon:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const A_use_locking:boolean; const D_var:boolean=false; const D_ms:boolean=false; const D_mom:boolean=false; const D_lr:boolean=false; const D_rho:boolean=false; const D_momentum:boolean=false; const D_epsilon:boolean=false; const D_grad:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_var);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('SparseApplyRMSProp',[I_var,I_ms,I_mom,I_lr,I_rho,I_momentum,I_epsilon,I_grad,I_indices],['T','Tindices','use_locking'],['type','type','bool'],[@F_T,@F_Tindices,@A_use_locking],[D_var,D_ms,D_mom,D_lr,D_rho,D_momentum,D_epsilon,D_grad,D_indices])
  end;
function ExecSparseConditionalAccumulator(const A_dtype:TF_DataType; const A_shape:TF_Shape; const A_container:string; const A_shared_name:string; const A_reduction_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('SparseConditionalAccumulator',[],['dtype','shape','container','shared_name','reduction_type'],['type','shape','string','string','string'],[@A_dtype,@A_shape,@A_container,@A_shared_name,@A_reduction_type],[])
  end;
function ExecSparseDenseCwiseAdd(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseDenseCwiseAdd',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape,D_dense])
  end;
function ExecSparseDenseCwiseDiv(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseDenseCwiseDiv',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape,D_dense])
  end;
function ExecSparseDenseCwiseMul(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const I_dense:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false; const D_dense:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseDenseCwiseMul',[I_sp_indices,I_sp_values,I_sp_shape,I_dense],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape,D_dense])
  end;
function ExecSparseMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_a_is_sparse:boolean; const A_b_is_sparse:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_Ta:TF_DataType;
    F_Tb:TF_DataType;
  begin
  F_Ta:=TF_TensorType(I_a);
  F_Tb:=TF_TensorType(I_b);
  result:=ExecOper('SparseMatMul',[I_a,I_b],['transpose_a','transpose_b','a_is_sparse','b_is_sparse','Ta','Tb'],['bool','bool','bool','bool','type','type'],[@A_transpose_a,@A_transpose_b,@A_a_is_sparse,@A_b_is_sparse,@F_Ta,@F_Tb],[D_a,D_b])
  end;
function ExecSparseMatrixAdd(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const I_alpha:TF_TensorPtr; const I_beta:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false; const D_alpha:boolean=false; const D_beta:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_alpha);
  result:=ExecOper('SparseMatrixAdd',[I_a,I_b,I_alpha,I_beta],['T'],['type'],[@F_T],[D_a,D_b,D_alpha,D_beta])
  end;
function ExecSparseMatrixMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const A_transpose_output:boolean; const A_conjugate_output:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_b);
  result:=ExecOper('SparseMatrixMatMul',[I_a,I_b],['T','transpose_a','transpose_b','adjoint_a','adjoint_b','transpose_output','conjugate_output'],['type','bool','bool','bool','bool','bool','bool'],[@F_T,@A_transpose_a,@A_transpose_b,@A_adjoint_a,@A_adjoint_b,@A_transpose_output,@A_conjugate_output],[D_a,D_b])
  end;
function ExecSparseMatrixMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_b);
  result:=ExecOper('SparseMatrixMul',[I_a,I_b],['T'],['type'],[@F_T],[D_a,D_b])
  end;
function ExecSparseMatrixNNZ(const I_sparse_matrix:TF_TensorPtr; const D_sparse_matrix:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixNNZ',[I_sparse_matrix],[],[],[],[D_sparse_matrix])
  end;
function ExecSparseMatrixOrderingAMD(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixOrderingAMD',[I_input],[],[],[],[D_input])
  end;
function ExecSparseMatrixSoftmax(const I_logits:TF_TensorPtr; const A_type:TF_DataType; const D_logits:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixSoftmax',[I_logits],['type'],['type'],[@A_type],[D_logits])
  end;
function ExecSparseMatrixSoftmaxGrad(const I_softmax:TF_TensorPtr; const I_grad_softmax:TF_TensorPtr; const A_type:TF_DataType; const D_softmax:boolean=false; const D_grad_softmax:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixSoftmaxGrad',[I_softmax,I_grad_softmax],['type'],['type'],[@A_type],[D_softmax,D_grad_softmax])
  end;
function ExecSparseMatrixSparseCholesky(const I_input:TF_TensorPtr; const I_permutation:TF_TensorPtr; const A_type:TF_DataType; const D_input:boolean=false; const D_permutation:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixSparseCholesky',[I_input,I_permutation],['type'],['type'],[@A_type],[D_input,D_permutation])
  end;
function ExecSparseMatrixSparseMatMul(const I_a:TF_TensorPtr; const I_b:TF_TensorPtr; const A_type:TF_DataType; const A_transpose_a:boolean; const A_transpose_b:boolean; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const D_a:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixSparseMatMul',[I_a,I_b],['type','transpose_a','transpose_b','adjoint_a','adjoint_b'],['type','bool','bool','bool','bool'],[@A_type,@A_transpose_a,@A_transpose_b,@A_adjoint_a,@A_adjoint_b],[D_a,D_b])
  end;
function ExecSparseMatrixTranspose(const I_input:TF_TensorPtr; const A_conjugate:boolean; const A_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixTranspose',[I_input],['conjugate','type'],['bool','type'],[@A_conjugate,@A_type],[D_input])
  end;
function ExecSparseMatrixZeros(const I_dense_shape:TF_TensorPtr; const A_type:TF_DataType; const D_dense_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SparseMatrixZeros',[I_dense_shape],['type'],['type'],[@A_type],[D_dense_shape])
  end;
function ExecSparseReduceMax(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input_values);
  result:=ExecOper('SparseReduceMax',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],['keep_dims','T'],['bool','type'],[@A_keep_dims,@F_T],[D_input_indices,D_input_values,D_input_shape,D_reduction_axes])
  end;
function ExecSparseReduceSum(const I_input_indices:TF_TensorPtr; const I_input_values:TF_TensorPtr; const I_input_shape:TF_TensorPtr; const I_reduction_axes:TF_TensorPtr; const A_keep_dims:boolean; const D_input_indices:boolean=false; const D_input_values:boolean=false; const D_input_shape:boolean=false; const D_reduction_axes:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input_values);
  result:=ExecOper('SparseReduceSum',[I_input_indices,I_input_values,I_input_shape,I_reduction_axes],['keep_dims','T'],['bool','type'],[@A_keep_dims,@F_T],[D_input_indices,D_input_values,D_input_shape,D_reduction_axes])
  end;
function ExecSparseSegmentMean(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentMean',[I_data,I_indices,I_segment_ids],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_data,D_indices,D_segment_ids])
  end;
function ExecSparseSegmentMeanGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentMeanGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_grad,D_indices,D_segment_ids,D_output_dim0])
  end;
function ExecSparseSegmentMeanWithNumSegments(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('SparseSegmentMeanWithNumSegments',[I_data,I_indices,I_segment_ids,I_num_segments],['T','Tidx','Tnumsegments'],['type','type','type'],[@F_T,@F_Tidx,@F_Tnumsegments],[D_data,D_indices,D_segment_ids,D_num_segments])
  end;
function ExecSparseSegmentSqrtN(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentSqrtN',[I_data,I_indices,I_segment_ids],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_data,D_indices,D_segment_ids])
  end;
function ExecSparseSegmentSqrtNGrad(const I_grad:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_output_dim0:TF_TensorPtr; const D_grad:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_output_dim0:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_grad);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentSqrtNGrad',[I_grad,I_indices,I_segment_ids,I_output_dim0],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_grad,D_indices,D_segment_ids,D_output_dim0])
  end;
function ExecSparseSegmentSqrtNWithNumSegments(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('SparseSegmentSqrtNWithNumSegments',[I_data,I_indices,I_segment_ids,I_num_segments],['T','Tidx','Tnumsegments'],['type','type','type'],[@F_T,@F_Tidx,@F_Tnumsegments],[D_data,D_indices,D_segment_ids,D_num_segments])
  end;
function ExecSparseSegmentSum(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('SparseSegmentSum',[I_data,I_indices,I_segment_ids],['T','Tidx'],['type','type'],[@F_T,@F_Tidx],[D_data,D_indices,D_segment_ids])
  end;
function ExecSparseSegmentSumWithNumSegments(const I_data:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_indices:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tidx:=TF_TensorType(I_indices);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('SparseSegmentSumWithNumSegments',[I_data,I_indices,I_segment_ids,I_num_segments],['T','Tidx','Tnumsegments'],['type','type','type'],[@F_T,@F_Tidx,@F_Tnumsegments],[D_data,D_indices,D_segment_ids,D_num_segments])
  end;
function ExecSparseSliceGrad(const I_backprop_val_grad:TF_TensorPtr; const I_input_indices:TF_TensorPtr; const I_input_start:TF_TensorPtr; const I_output_indices:TF_TensorPtr; const D_backprop_val_grad:boolean=false; const D_input_indices:boolean=false; const D_input_start:boolean=false; const D_output_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_backprop_val_grad);
  result:=ExecOper('SparseSliceGrad',[I_backprop_val_grad,I_input_indices,I_input_start,I_output_indices],['T'],['type'],[@F_T],[D_backprop_val_grad,D_input_indices,D_input_start,D_output_indices])
  end;
function ExecSparseSoftmax(const I_sp_indices:TF_TensorPtr; const I_sp_values:TF_TensorPtr; const I_sp_shape:TF_TensorPtr; const D_sp_indices:boolean=false; const D_sp_values:boolean=false; const D_sp_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sp_values);
  result:=ExecOper('SparseSoftmax',[I_sp_indices,I_sp_values,I_sp_shape],['T'],['type'],[@F_T],[D_sp_indices,D_sp_values,D_sp_shape])
  end;
function ExecSparseTensorDenseAdd(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_a_indices);
  F_T:=TF_TensorType(I_a_values);
  result:=ExecOper('SparseTensorDenseAdd',[I_a_indices,I_a_values,I_a_shape,I_b],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_a_indices,D_a_values,D_a_shape,D_b])
  end;
function ExecSparseTensorDenseMatMul(const I_a_indices:TF_TensorPtr; const I_a_values:TF_TensorPtr; const I_a_shape:TF_TensorPtr; const I_b:TF_TensorPtr; const A_adjoint_a:boolean; const A_adjoint_b:boolean; const D_a_indices:boolean=false; const D_a_values:boolean=false; const D_a_shape:boolean=false; const D_b:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_a_indices);
  F_T:=TF_TensorType(I_a_values);
  result:=ExecOper('SparseTensorDenseMatMul',[I_a_indices,I_a_values,I_a_shape,I_b],['T','Tindices','adjoint_a','adjoint_b'],['type','type','bool','bool'],[@F_T,@F_Tindices,@A_adjoint_a,@A_adjoint_b],[D_a_indices,D_a_values,D_a_shape,D_b])
  end;
function ExecSparseTensorSliceDataset(const I_indices:TF_TensorPtr; const I_values:TF_TensorPtr; const I_dense_shape:TF_TensorPtr; const D_indices:boolean=false; const D_values:boolean=false; const D_dense_shape:boolean=false):TF_TensorPtr;
  var
    F_Tvalues:TF_DataType;
  begin
  F_Tvalues:=TF_TensorType(I_values);
  result:=ExecOper('SparseTensorSliceDataset',[I_indices,I_values,I_dense_shape],['Tvalues'],['type'],[@F_Tvalues],[D_indices,D_values,D_dense_shape])
  end;
function ExecSparseTensorToCSRSparseMatrix(const I_indices:TF_TensorPtr; const I_values:TF_TensorPtr; const I_dense_shape:TF_TensorPtr; const D_indices:boolean=false; const D_values:boolean=false; const D_dense_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_values);
  result:=ExecOper('SparseTensorToCSRSparseMatrix',[I_indices,I_values,I_dense_shape],['T'],['type'],[@F_T],[D_indices,D_values,D_dense_shape])
  end;
function ExecSparseToDense(const I_sparse_indices:TF_TensorPtr; const I_output_shape:TF_TensorPtr; const I_sparse_values:TF_TensorPtr; const I_default_value:TF_TensorPtr; const A_validate_indices:boolean; const D_sparse_indices:boolean=false; const D_output_shape:boolean=false; const D_sparse_values:boolean=false; const D_default_value:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_sparse_indices);
  F_T:=TF_TensorType(I_sparse_values);
  result:=ExecOper('SparseToDense',[I_sparse_indices,I_output_shape,I_sparse_values,I_default_value],['validate_indices','T','Tindices'],['bool','type','type'],[@A_validate_indices,@F_T,@F_Tindices],[D_sparse_indices,D_output_shape,D_sparse_values,D_default_value])
  end;
function ExecSpence(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Spence',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSqlDataset(const I_driver_name:TF_TensorPtr; const I_data_source_name:TF_TensorPtr; const I_query:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_driver_name:boolean=false; const D_data_source_name:boolean=false; const D_query:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('SqlDataset',[I_driver_name,I_data_source_name,I_query],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_driver_name,D_data_source_name,D_query])
  end;
function ExecSqrt(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sqrt',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSqrtGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('SqrtGrad',[I_y,I_dy],['T'],['type'],[@F_T],[D_y,D_dy])
  end;
function ExecSquare(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Square',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecSquaredDifference(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('SquaredDifference',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecSqueeze(const I_input:TF_TensorPtr; const A_squeeze_dims:array of integer; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Squeeze',[I_input],['T','squeeze_dims'],['type','list(int)'],[@F_T,@A_squeeze_dims],[D_input])
  end;
function ExecStack(const A_elem_type:TF_DataType; const A_stack_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('Stack',[],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name],[])
  end;
function ExecStackPop(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StackPop',[I_handle],['elem_type'],['type'],[@A_elem_type],[D_handle])
  end;
function ExecStackPopV2(const I_handle:TF_TensorPtr; const A_elem_type:TF_DataType; const D_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StackPopV2',[I_handle],['elem_type'],['type'],[@A_elem_type],[D_handle])
  end;
function ExecStackPush(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_elem);
  result:=ExecOper('StackPush',[I_handle,I_elem],['T','swap_memory'],['type','bool'],[@F_T,@A_swap_memory],[D_handle,D_elem])
  end;
function ExecStackPushV2(const I_handle:TF_TensorPtr; const I_elem:TF_TensorPtr; const A_swap_memory:boolean; const D_handle:boolean=false; const D_elem:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_elem);
  result:=ExecOper('StackPushV2',[I_handle,I_elem],['T','swap_memory'],['type','bool'],[@F_T,@A_swap_memory],[D_handle,D_elem])
  end;
function ExecStackV2(const I_max_size:TF_TensorPtr; const A_elem_type:TF_DataType; const A_stack_name:string; const D_max_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StackV2',[I_max_size],['elem_type','stack_name'],['type','string'],[@A_elem_type,@A_stack_name],[D_max_size])
  end;
function ExecStageSize(const A_capacity:integer; const A_memory_limit:integer; const A_dtypes:array of TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('StageSize',[],['capacity','memory_limit','dtypes','container','shared_name'],['int','int','list(type)','string','string'],[@A_capacity,@A_memory_limit,@A_dtypes,@A_container,@A_shared_name],[])
  end;
function ExecStatefulRandomBinomial(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const I_counts:TF_TensorPtr; const I_probs:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false; const D_counts:boolean=false; const D_probs:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_T:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_T:=TF_TensorType(I_counts);
  result:=ExecOper('StatefulRandomBinomial',[I_resource,I_algorithm,I_shape,I_counts,I_probs],['S','T','dtype'],['type','type','type'],[@F_S,@F_T,@A_dtype],[D_resource,D_algorithm,D_shape,D_counts,D_probs])
  end;
function ExecStatefulStandardNormal(const I_resource:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  result:=ExecOper('StatefulStandardNormal',[I_resource,I_shape],['dtype','shape_dtype'],['type','type'],[@A_dtype,@F_shape_dtype],[D_resource,D_shape])
  end;
function ExecStatefulStandardNormalV2(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  result:=ExecOper('StatefulStandardNormalV2',[I_resource,I_algorithm,I_shape],['dtype','shape_dtype'],['type','type'],[@A_dtype,@F_shape_dtype],[D_resource,D_algorithm,D_shape])
  end;
function ExecStatefulTruncatedNormal(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  result:=ExecOper('StatefulTruncatedNormal',[I_resource,I_algorithm,I_shape],['dtype','shape_dtype'],['type','type'],[@A_dtype,@F_shape_dtype],[D_resource,D_algorithm,D_shape])
  end;
function ExecStatefulUniform(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  result:=ExecOper('StatefulUniform',[I_resource,I_algorithm,I_shape],['dtype','shape_dtype'],['type','type'],[@A_dtype,@F_shape_dtype],[D_resource,D_algorithm,D_shape])
  end;
function ExecStatefulUniformFullInt(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const A_dtype:TF_DataType; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  result:=ExecOper('StatefulUniformFullInt',[I_resource,I_algorithm,I_shape],['dtype','shape_dtype'],['type','type'],[@A_dtype,@F_shape_dtype],[D_resource,D_algorithm,D_shape])
  end;
function ExecStatefulUniformInt(const I_resource:TF_TensorPtr; const I_algorithm:TF_TensorPtr; const I_shape:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const D_resource:boolean=false; const D_algorithm:boolean=false; const D_shape:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
  var
    F_shape_dtype:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_shape_dtype:=TF_TensorType(I_shape);
  F_dtype:=TF_TensorType(I_minval);
  result:=ExecOper('StatefulUniformInt',[I_resource,I_algorithm,I_shape,I_minval,I_maxval],['dtype','shape_dtype'],['type','type'],[@F_dtype,@F_shape_dtype],[D_resource,D_algorithm,D_shape,D_minval,D_maxval])
  end;
function ExecStatelessMultinomial(const I_logits:TF_TensorPtr; const I_num_samples:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_output_dtype:TF_DataType; const D_logits:boolean=false; const D_num_samples:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
  begin
  F_T:=TF_TensorType(I_logits);
  F_Tseed:=TF_TensorType(I_seed);
  result:=ExecOper('StatelessMultinomial',[I_logits,I_num_samples,I_seed],['T','Tseed','output_dtype'],['type','type','type'],[@F_T,@F_Tseed,@A_output_dtype],[D_logits,D_num_samples,D_seed])
  end;
function ExecStatelessRandomBinomial(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_counts:TF_TensorPtr; const I_probs:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false; const D_counts:boolean=false; const D_probs:boolean=false):TF_TensorPtr;
  var
    F_S:TF_DataType;
    F_Tseed:TF_DataType;
    F_T:TF_DataType;
  begin
  F_S:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  F_T:=TF_TensorType(I_counts);
  result:=ExecOper('StatelessRandomBinomial',[I_shape,I_seed,I_counts,I_probs],['S','Tseed','T','dtype'],['type','type','type','type'],[@F_S,@F_Tseed,@F_T,@A_dtype],[D_shape,D_seed,D_counts,D_probs])
  end;
function ExecStatelessRandomGammaV2(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_alpha:TF_TensorPtr; const D_shape:boolean=false; const D_seed:boolean=false; const D_alpha:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  F_dtype:=TF_TensorType(I_alpha);
  result:=ExecOper('StatelessRandomGammaV2',[I_shape,I_seed,I_alpha],['dtype','T','Tseed'],['type','type','type'],[@F_dtype,@F_T,@F_Tseed],[D_shape,D_seed,D_alpha])
  end;
function ExecStatelessRandomNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  result:=ExecOper('StatelessRandomNormal',[I_shape,I_seed],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@F_T,@F_Tseed],[D_shape,D_seed])
  end;
function ExecStatelessRandomPoisson(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_lam:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false; const D_lam:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
    F_Rtype:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  F_Rtype:=TF_TensorType(I_lam);
  result:=ExecOper('StatelessRandomPoisson',[I_shape,I_seed,I_lam],['Rtype','dtype','T','Tseed'],['type','type','type','type'],[@F_Rtype,@A_dtype,@F_T,@F_Tseed],[D_shape,D_seed,D_lam])
  end;
function ExecStatelessRandomUniform(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  result:=ExecOper('StatelessRandomUniform',[I_shape,I_seed],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@F_T,@F_Tseed],[D_shape,D_seed])
  end;
function ExecStatelessRandomUniformInt(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const I_minval:TF_TensorPtr; const I_maxval:TF_TensorPtr; const D_shape:boolean=false; const D_seed:boolean=false; const D_minval:boolean=false; const D_maxval:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
    F_dtype:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  F_dtype:=TF_TensorType(I_minval);
  result:=ExecOper('StatelessRandomUniformInt',[I_shape,I_seed,I_minval,I_maxval],['dtype','T','Tseed'],['type','type','type'],[@F_dtype,@F_T,@F_Tseed],[D_shape,D_seed,D_minval,D_maxval])
  end;
function ExecStatelessTruncatedNormal(const I_shape:TF_TensorPtr; const I_seed:TF_TensorPtr; const A_dtype:TF_DataType; const D_shape:boolean=false; const D_seed:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tseed:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  F_Tseed:=TF_TensorType(I_seed);
  result:=ExecOper('StatelessTruncatedNormal',[I_shape,I_seed],['dtype','T','Tseed'],['type','type','type'],[@A_dtype,@F_T,@F_Tseed],[D_shape,D_seed])
  end;
function ExecStaticRegexFullMatch(const I_input:TF_TensorPtr; const A_pattern:string; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StaticRegexFullMatch',[I_input],['pattern'],['string'],[@A_pattern],[D_input])
  end;
function ExecStaticRegexReplace(const I_input:TF_TensorPtr; const A_pattern:string; const A_rewrite:string; const A_replace_global:boolean; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StaticRegexReplace',[I_input],['pattern','rewrite','replace_global'],['string','string','bool'],[@A_pattern,@A_rewrite,@A_replace_global],[D_input])
  end;
function ExecStatsAggregatorHandle(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('StatsAggregatorHandle',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecStatsAggregatorHandleV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('StatsAggregatorHandleV2',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecStatsAggregatorSummary(const I_iterator:TF_TensorPtr; const D_iterator:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StatsAggregatorSummary',[I_iterator],[],[],[],[D_iterator])
  end;
function ExecStopGradient(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('StopGradient',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecStridedSlice(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_input:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('StridedSlice',[I_input,I_begin,I_end,I_strides],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_input,D_begin,D_end,D_strides])
  end;
function ExecStridedSliceAssign(const I_ref:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_value:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_ref:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_ref);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('StridedSliceAssign',[I_ref,I_begin,I_end,I_strides,I_value],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_ref,D_begin,D_end,D_strides,D_value])
  end;
function ExecStridedSliceGrad(const I_shape:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_dy:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_shape:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_Index:TF_DataType;
    F_T:TF_DataType;
  begin
  F_Index:=TF_TensorType(I_shape);
  F_T:=TF_TensorType(I_dy);
  result:=ExecOper('StridedSliceGrad',[I_shape,I_begin,I_end,I_strides,I_dy],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_shape,D_begin,D_end,D_strides,D_dy])
  end;
function ExecStringLength(const I_input:TF_TensorPtr; const A_unit:string; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringLength',[I_input],['unit'],['string'],[@A_unit],[D_input])
  end;
function ExecStringLower(const I_input:TF_TensorPtr; const A_encoding:string; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringLower',[I_input],['encoding'],['string'],[@A_encoding],[D_input])
  end;
function ExecStringStrip(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringStrip',[I_input],[],[],[],[D_input])
  end;
function ExecStringToHashBucket(const I_string_tensor:TF_TensorPtr; const A_num_buckets:integer; const D_string_tensor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToHashBucket',[I_string_tensor],['num_buckets'],['int'],[@A_num_buckets],[D_string_tensor])
  end;
function ExecStringToHashBucketFast(const I_input:TF_TensorPtr; const A_num_buckets:integer; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToHashBucketFast',[I_input],['num_buckets'],['int'],[@A_num_buckets],[D_input])
  end;
function ExecStringToHashBucketStrong(const I_input:TF_TensorPtr; const A_num_buckets:integer; const A_key:array of integer; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToHashBucketStrong',[I_input],['num_buckets','key'],['int','list(int)'],[@A_num_buckets,@A_key],[D_input])
  end;
function ExecStringToNumber(const I_string_tensor:TF_TensorPtr; const A_out_type:TF_DataType; const D_string_tensor:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringToNumber',[I_string_tensor],['out_type'],['type'],[@A_out_type],[D_string_tensor])
  end;
function ExecStringUpper(const I_input:TF_TensorPtr; const A_encoding:string; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('StringUpper',[I_input],['encoding'],['string'],[@A_encoding],[D_input])
  end;
function ExecSub(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Sub',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecSubstr(const I_input:TF_TensorPtr; const I_pos:TF_TensorPtr; const I_len:TF_TensorPtr; const A_unit:string; const D_input:boolean=false; const D_pos:boolean=false; const D_len:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_pos);
  result:=ExecOper('Substr',[I_input,I_pos,I_len],['T','unit'],['type','string'],[@F_T,@A_unit],[D_input,D_pos,D_len])
  end;
function ExecSum(const I_input:TF_TensorPtr; const I_reduction_indices:TF_TensorPtr; const A_keep_dims:boolean; const D_input:boolean=false; const D_reduction_indices:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tidx:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tidx:=TF_TensorType(I_reduction_indices);
  result:=ExecOper('Sum',[I_input,I_reduction_indices],['keep_dims','T','Tidx'],['bool','type','type'],[@A_keep_dims,@F_T,@F_Tidx],[D_input,D_reduction_indices])
  end;
function ExecSummaryWriter(const A_shared_name:string; const A_container:string):TF_TensorPtr;
  begin
  result:=ExecOper('SummaryWriter',[],['shared_name','container'],['string','string'],[@A_shared_name,@A_container],[])
  end;
function ExecTFRecordDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TFRecordDataset',[I_filenames,I_compression_type,I_buffer_size],[],[],[],[D_filenames,D_compression_type,D_buffer_size])
  end;
function ExecTFRecordReader(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('TFRecordReader',[],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type],[])
  end;
function ExecTFRecordReaderV2(const A_container:string; const A_shared_name:string; const A_compression_type:string):TF_TensorPtr;
  begin
  result:=ExecOper('TFRecordReaderV2',[],['container','shared_name','compression_type'],['string','string','string'],[@A_container,@A_shared_name,@A_compression_type],[])
  end;
function ExecTPUCompilationResult():TF_TensorPtr;
  begin
  result:=ExecOper('TPUCompilationResult',[],[],[],[],[])
  end;
function ExecTPUEmbeddingActivations(const I_embedding_variable:TF_TensorPtr; const I_sliced_activations:TF_TensorPtr; const A_table_id:integer; const A_lookup_id:integer; const D_embedding_variable:boolean=false; const D_sliced_activations:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TPUEmbeddingActivations',[I_embedding_variable,I_sliced_activations],['table_id','lookup_id'],['int','int'],[@A_table_id,@A_lookup_id],[D_embedding_variable,D_sliced_activations])
  end;
function ExecTPUOrdinalSelector():TF_TensorPtr;
  begin
  result:=ExecOper('TPUOrdinalSelector',[],[],[],[],[])
  end;
function ExecTakeDataset(const I_input_dataset:TF_TensorPtr; const I_count:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_count:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TakeDataset',[I_input_dataset,I_count],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_count])
  end;
function ExecTan(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Tan',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecTanh(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Tanh',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecTanhGrad(const I_y:TF_TensorPtr; const I_dy:TF_TensorPtr; const D_y:boolean=false; const D_dy:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_y);
  result:=ExecOper('TanhGrad',[I_y,I_dy],['T'],['type'],[@F_T],[D_y,D_dy])
  end;
function ExecTemporaryVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_var_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TemporaryVariable',[],['shape','dtype','var_name'],['shape','type','string'],[@A_shape,@A_dtype,@A_var_name],[])
  end;
function ExecTensorArray(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const A_element_shape:TF_Shape; const D_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArray',[I_size],['dtype','dynamic_size','clear_after_read','tensor_array_name','element_shape'],['type','bool','bool','string','shape'],[@A_dtype,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name,@A_element_shape],[D_size])
  end;
function ExecTensorArrayGather(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGather',[I_handle,I_indices,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_indices,D_flow_in])
  end;
function ExecTensorArrayGatherV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGatherV2',[I_handle,I_indices,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_indices,D_flow_in])
  end;
function ExecTensorArrayGatherV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_indices:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGatherV3',[I_handle,I_indices,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_indices,D_flow_in])
  end;
function ExecTensorArrayGrad(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGrad',[I_handle,I_flow_in],['source'],['string'],[@A_source],[D_handle,D_flow_in])
  end;
function ExecTensorArrayGradV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_source:string; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayGradV2',[I_handle,I_flow_in],['source'],['string'],[@A_source],[D_handle,D_flow_in])
  end;
function ExecTensorArrayPack(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayPack',[I_handle,I_flow_in],['dtype','element_shape'],['type','shape'],[@A_dtype,@A_element_shape],[D_handle,D_flow_in])
  end;
function ExecTensorArrayRead(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayRead',[I_handle,I_index,I_flow_in],['dtype'],['type'],[@A_dtype],[D_handle,D_index,D_flow_in])
  end;
function ExecTensorArrayReadV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayReadV2',[I_handle,I_index,I_flow_in],['dtype'],['type'],[@A_dtype],[D_handle,D_index,D_flow_in])
  end;
function ExecTensorArrayReadV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const A_dtype:TF_DataType; const D_handle:boolean=false; const D_index:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayReadV3',[I_handle,I_index,I_flow_in],['dtype'],['type'],[@A_dtype],[D_handle,D_index,D_flow_in])
  end;
function ExecTensorArrayScatter(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayScatter',[I_handle,I_indices,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_indices,D_value,D_flow_in])
  end;
function ExecTensorArrayScatterV2(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayScatterV2',[I_handle,I_indices,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_indices,D_value,D_flow_in])
  end;
function ExecTensorArrayScatterV3(const I_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_indices:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayScatterV3',[I_handle,I_indices,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_indices,D_value,D_flow_in])
  end;
function ExecTensorArraySize(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArraySize',[I_handle,I_flow_in],[],[],[],[D_handle,D_flow_in])
  end;
function ExecTensorArraySizeV2(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArraySizeV2',[I_handle,I_flow_in],[],[],[],[D_handle,D_flow_in])
  end;
function ExecTensorArraySizeV3(const I_handle:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArraySizeV3',[I_handle,I_flow_in],[],[],[],[D_handle,D_flow_in])
  end;
function ExecTensorArraySplit(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArraySplit',[I_handle,I_value,I_lengths,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_lengths,D_flow_in])
  end;
function ExecTensorArraySplitV2(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArraySplitV2',[I_handle,I_value,I_lengths,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_lengths,D_flow_in])
  end;
function ExecTensorArraySplitV3(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_lengths:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_lengths:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArraySplitV3',[I_handle,I_value,I_lengths,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_lengths,D_flow_in])
  end;
function ExecTensorArrayUnpack(const I_handle:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayUnpack',[I_handle,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_value,D_flow_in])
  end;
function ExecTensorArrayV2(const I_size:TF_TensorPtr; const A_dtype:TF_DataType; const A_element_shape:TF_Shape; const A_dynamic_size:boolean; const A_clear_after_read:boolean; const A_tensor_array_name:string; const D_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorArrayV2',[I_size],['dtype','element_shape','dynamic_size','clear_after_read','tensor_array_name'],['type','shape','bool','bool','string'],[@A_dtype,@A_element_shape,@A_dynamic_size,@A_clear_after_read,@A_tensor_array_name],[D_size])
  end;
function ExecTensorArrayWrite(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayWrite',[I_handle,I_index,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_index,D_value,D_flow_in])
  end;
function ExecTensorArrayWriteV2(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayWriteV2',[I_handle,I_index,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_index,D_value,D_flow_in])
  end;
function ExecTensorArrayWriteV3(const I_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_value:TF_TensorPtr; const I_flow_in:TF_TensorPtr; const D_handle:boolean=false; const D_index:boolean=false; const D_value:boolean=false; const D_flow_in:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_value);
  result:=ExecOper('TensorArrayWriteV3',[I_handle,I_index,I_value,I_flow_in],['T'],['type'],[@F_T],[D_handle,D_index,D_value,D_flow_in])
  end;
function ExecTensorForestTreeIsInitializedOp(const I_tree_handle:TF_TensorPtr; const D_tree_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorForestTreeIsInitializedOp',[I_tree_handle],[],[],[],[D_tree_handle])
  end;
function ExecTensorForestTreePredict(const I_tree_handle:TF_TensorPtr; const I_dense_features:TF_TensorPtr; const A_logits_dimension:integer; const D_tree_handle:boolean=false; const D_dense_features:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorForestTreePredict',[I_tree_handle,I_dense_features],['logits_dimension'],['int'],[@A_logits_dimension],[D_tree_handle,D_dense_features])
  end;
function ExecTensorForestTreeResourceHandleOp(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TensorForestTreeResourceHandleOp',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecTensorForestTreeSerialize(const I_tree_handle:TF_TensorPtr; const D_tree_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorForestTreeSerialize',[I_tree_handle],[],[],[],[D_tree_handle])
  end;
function ExecTensorForestTreeSize(const I_tree_handle:TF_TensorPtr; const D_tree_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorForestTreeSize',[I_tree_handle],[],[],[],[D_tree_handle])
  end;
function ExecTensorListConcatLists(const I_input_a:TF_TensorPtr; const I_input_b:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_input_a:boolean=false; const D_input_b:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListConcatLists',[I_input_a,I_input_b],['element_dtype'],['type'],[@A_element_dtype],[D_input_a,D_input_b])
  end;
function ExecTensorListElementShape(const I_input_handle:TF_TensorPtr; const A_shape_type:TF_DataType; const D_input_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListElementShape',[I_input_handle],['shape_type'],['type'],[@A_shape_type],[D_input_handle])
  end;
function ExecTensorListFromTensor(const I_tensor:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
    F_shape_type:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  F_shape_type:=TF_TensorType(I_element_shape);
  result:=ExecOper('TensorListFromTensor',[I_tensor,I_element_shape],['element_dtype','shape_type'],['type','type'],[@F_element_dtype,@F_shape_type],[D_tensor,D_element_shape])
  end;
function ExecTensorListGather(const I_input_handle:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_input_handle:boolean=false; const D_indices:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListGather',[I_input_handle,I_indices,I_element_shape],['element_dtype'],['type'],[@A_element_dtype],[D_input_handle,D_indices,D_element_shape])
  end;
function ExecTensorListGetItem(const I_input_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_input_handle:boolean=false; const D_index:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListGetItem',[I_input_handle,I_index,I_element_shape],['element_dtype'],['type'],[@A_element_dtype],[D_input_handle,D_index,D_element_shape])
  end;
function ExecTensorListLength(const I_input_handle:TF_TensorPtr; const D_input_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListLength',[I_input_handle],[],[],[],[D_input_handle])
  end;
function ExecTensorListPushBack(const I_input_handle:TF_TensorPtr; const I_tensor:TF_TensorPtr; const D_input_handle:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorListPushBack',[I_input_handle,I_tensor],['element_dtype'],['type'],[@F_element_dtype],[D_input_handle,D_tensor])
  end;
function ExecTensorListPushBackBatch(const I_input_handles:TF_TensorPtr; const I_tensor:TF_TensorPtr; const D_input_handles:boolean=false; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorListPushBackBatch',[I_input_handles,I_tensor],['element_dtype'],['type'],[@F_element_dtype],[D_input_handles,D_tensor])
  end;
function ExecTensorListReserve(const I_element_shape:TF_TensorPtr; const I_num_elements:TF_TensorPtr; const A_element_dtype:TF_DataType; const D_element_shape:boolean=false; const D_num_elements:boolean=false):TF_TensorPtr;
  var
    F_shape_type:TF_DataType;
  begin
  F_shape_type:=TF_TensorType(I_element_shape);
  result:=ExecOper('TensorListReserve',[I_element_shape,I_num_elements],['element_dtype','shape_type'],['type','type'],[@A_element_dtype,@F_shape_type],[D_element_shape,D_num_elements])
  end;
function ExecTensorListResize(const I_input_handle:TF_TensorPtr; const I_size:TF_TensorPtr; const D_input_handle:boolean=false; const D_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListResize',[I_input_handle,I_size],[],[],[],[D_input_handle,D_size])
  end;
function ExecTensorListScatter(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
    F_shape_type:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  F_shape_type:=TF_TensorType(I_element_shape);
  result:=ExecOper('TensorListScatter',[I_tensor,I_indices,I_element_shape],['element_dtype','shape_type'],['type','type'],[@F_element_dtype,@F_shape_type],[D_tensor,D_indices,D_element_shape])
  end;
function ExecTensorListScatterIntoExistingList(const I_input_handle:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const D_input_handle:boolean=false; const D_tensor:boolean=false; const D_indices:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorListScatterIntoExistingList',[I_input_handle,I_tensor,I_indices],['element_dtype'],['type'],[@F_element_dtype],[D_input_handle,D_tensor,D_indices])
  end;
function ExecTensorListScatterV2(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const I_num_elements:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_element_shape:boolean=false; const D_num_elements:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
    F_shape_type:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  F_shape_type:=TF_TensorType(I_element_shape);
  result:=ExecOper('TensorListScatterV2',[I_tensor,I_indices,I_element_shape,I_num_elements],['element_dtype','shape_type'],['type','type'],[@F_element_dtype,@F_shape_type],[D_tensor,D_indices,D_element_shape,D_num_elements])
  end;
function ExecTensorListSetItem(const I_input_handle:TF_TensorPtr; const I_index:TF_TensorPtr; const I_item:TF_TensorPtr; const D_input_handle:boolean=false; const D_index:boolean=false; const D_item:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_item);
  result:=ExecOper('TensorListSetItem',[I_input_handle,I_index,I_item],['element_dtype'],['type'],[@F_element_dtype],[D_input_handle,D_index,D_item])
  end;
function ExecTensorListSplit(const I_tensor:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const I_lengths:TF_TensorPtr; const D_tensor:boolean=false; const D_element_shape:boolean=false; const D_lengths:boolean=false):TF_TensorPtr;
  var
    F_element_dtype:TF_DataType;
    F_shape_type:TF_DataType;
  begin
  F_element_dtype:=TF_TensorType(I_tensor);
  F_shape_type:=TF_TensorType(I_element_shape);
  result:=ExecOper('TensorListSplit',[I_tensor,I_element_shape,I_lengths],['element_dtype','shape_type'],['type','type'],[@F_element_dtype,@F_shape_type],[D_tensor,D_element_shape,D_lengths])
  end;
function ExecTensorListStack(const I_input_handle:TF_TensorPtr; const I_element_shape:TF_TensorPtr; const A_element_dtype:TF_DataType; const A_num_elements:integer; const D_input_handle:boolean=false; const D_element_shape:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TensorListStack',[I_input_handle,I_element_shape],['element_dtype','num_elements'],['type','int'],[@A_element_dtype,@A_num_elements],[D_input_handle,D_element_shape])
  end;
function ExecTensorScatterAdd(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('TensorScatterAdd',[I_tensor,I_indices,I_updates],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_tensor,D_indices,D_updates])
  end;
function ExecTensorScatterSub(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('TensorScatterSub',[I_tensor,I_indices,I_updates],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_tensor,D_indices,D_updates])
  end;
function ExecTensorScatterUpdate(const I_tensor:TF_TensorPtr; const I_indices:TF_TensorPtr; const I_updates:TF_TensorPtr; const D_tensor:boolean=false; const D_indices:boolean=false; const D_updates:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  F_Tindices:=TF_TensorType(I_indices);
  result:=ExecOper('TensorScatterUpdate',[I_tensor,I_indices,I_updates],['T','Tindices'],['type','type'],[@F_T,@F_Tindices],[D_tensor,D_indices,D_updates])
  end;
function ExecTensorStridedSliceUpdate(const I_input:TF_TensorPtr; const I_begin:TF_TensorPtr; const I_end:TF_TensorPtr; const I_strides:TF_TensorPtr; const I_value:TF_TensorPtr; const A_begin_mask:integer; const A_end_mask:integer; const A_ellipsis_mask:integer; const A_new_axis_mask:integer; const A_shrink_axis_mask:integer; const D_input:boolean=false; const D_begin:boolean=false; const D_end:boolean=false; const D_strides:boolean=false; const D_value:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Index:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Index:=TF_TensorType(I_begin);
  result:=ExecOper('TensorStridedSliceUpdate',[I_input,I_begin,I_end,I_strides,I_value],['T','Index','begin_mask','end_mask','ellipsis_mask','new_axis_mask','shrink_axis_mask'],['type','type','int','int','int','int','int'],[@F_T,@F_Index,@A_begin_mask,@A_end_mask,@A_ellipsis_mask,@A_new_axis_mask,@A_shrink_axis_mask],[D_input,D_begin,D_end,D_strides,D_value])
  end;
function ExecTensorSummary(const I_tensor:TF_TensorPtr; const A_description:string; const A_labels:array of string; const A_display_name:string; const D_tensor:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorSummary',[I_tensor],['T','description','labels','display_name'],['type','string','list(string)','string'],[@F_T,@A_description,@A_labels,@A_display_name],[D_tensor])
  end;
function ExecTensorSummaryV2(const I_tag:TF_TensorPtr; const I_tensor:TF_TensorPtr; const I_serialized_summary_metadata:TF_TensorPtr; const D_tag:boolean=false; const D_tensor:boolean=false; const D_serialized_summary_metadata:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_tensor);
  result:=ExecOper('TensorSummaryV2',[I_tag,I_tensor,I_serialized_summary_metadata],['T'],['type'],[@F_T],[D_tag,D_tensor,D_serialized_summary_metadata])
  end;
function ExecTextLineDataset(const I_filenames:TF_TensorPtr; const I_compression_type:TF_TensorPtr; const I_buffer_size:TF_TensorPtr; const D_filenames:boolean=false; const D_compression_type:boolean=false; const D_buffer_size:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('TextLineDataset',[I_filenames,I_compression_type,I_buffer_size],[],[],[],[D_filenames,D_compression_type,D_buffer_size])
  end;
function ExecTextLineReader(const A_skip_header_lines:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TextLineReader',[],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name],[])
  end;
function ExecTextLineReaderV2(const A_skip_header_lines:integer; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('TextLineReaderV2',[],['skip_header_lines','container','shared_name'],['int','string','string'],[@A_skip_header_lines,@A_container,@A_shared_name],[])
  end;
function ExecThreadPoolDataset(const I_input_dataset:TF_TensorPtr; const I_thread_pool:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_thread_pool:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('ThreadPoolDataset',[I_input_dataset,I_thread_pool],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_thread_pool])
  end;
function ExecThreadPoolHandle(const A_num_threads:integer; const A_max_intra_op_parallelism:integer; const A_display_name:string; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('ThreadPoolHandle',[],['num_threads','max_intra_op_parallelism','display_name','container','shared_name'],['int','int','string','string','string'],[@A_num_threads,@A_max_intra_op_parallelism,@A_display_name,@A_container,@A_shared_name],[])
  end;
function ExecTile(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tmultiples:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  F_Tmultiples:=TF_TensorType(I_multiples);
  result:=ExecOper('Tile',[I_input,I_multiples],['T','Tmultiples'],['type','type'],[@F_T,@F_Tmultiples],[D_input,D_multiples])
  end;
function ExecTileGrad(const I_input:TF_TensorPtr; const I_multiples:TF_TensorPtr; const D_input:boolean=false; const D_multiples:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('TileGrad',[I_input,I_multiples],['T'],['type'],[@F_T],[D_input,D_multiples])
  end;
function ExecTimestamp():TF_TensorPtr;
  begin
  result:=ExecOper('Timestamp',[],[],[],[],[])
  end;
function ExecToBool(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('ToBool',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecTranspose(const I_x:TF_TensorPtr; const I_perm:TF_TensorPtr; const D_x:boolean=false; const D_perm:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tperm:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  F_Tperm:=TF_TensorType(I_perm);
  result:=ExecOper('Transpose',[I_x,I_perm],['T','Tperm'],['type','type'],[@F_T,@F_Tperm],[D_x,D_perm])
  end;
function ExecTridiagonalMatMul(const I_superdiag:TF_TensorPtr; const I_maindiag:TF_TensorPtr; const I_subdiag:TF_TensorPtr; const I_rhs:TF_TensorPtr; const D_superdiag:boolean=false; const D_maindiag:boolean=false; const D_subdiag:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_superdiag);
  result:=ExecOper('TridiagonalMatMul',[I_superdiag,I_maindiag,I_subdiag,I_rhs],['T'],['type'],[@F_T],[D_superdiag,D_maindiag,D_subdiag,D_rhs])
  end;
function ExecTridiagonalSolve(const I_diagonals:TF_TensorPtr; const I_rhs:TF_TensorPtr; const A_partial_pivoting:boolean; const D_diagonals:boolean=false; const D_rhs:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_diagonals);
  result:=ExecOper('TridiagonalSolve',[I_diagonals,I_rhs],['partial_pivoting','T'],['bool','type'],[@A_partial_pivoting,@F_T],[D_diagonals,D_rhs])
  end;
function ExecTruncateDiv(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('TruncateDiv',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecTruncateMod(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('TruncateMod',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecTruncatedNormal(const I_shape:TF_TensorPtr; const A_seed:integer; const A_seed2:integer; const A_dtype:TF_DataType; const D_shape:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_shape);
  result:=ExecOper('TruncatedNormal',[I_shape],['seed','seed2','dtype','T'],['int','int','type','type'],[@A_seed,@A_seed2,@A_dtype,@F_T],[D_shape])
  end;
function ExecUnbatch(const I_batched_tensor:TF_TensorPtr; const I_batch_index:TF_TensorPtr; const I_id:TF_TensorPtr; const A_timeout_micros:integer; const A_container:string; const A_shared_name:string; const D_batched_tensor:boolean=false; const D_batch_index:boolean=false; const D_id:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_batched_tensor);
  result:=ExecOper('Unbatch',[I_batched_tensor,I_batch_index,I_id],['timeout_micros','container','shared_name','T'],['int','string','string','type'],[@A_timeout_micros,@A_container,@A_shared_name,@F_T],[D_batched_tensor,D_batch_index,D_id])
  end;
function ExecUnbatchDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('UnbatchDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecUnbatchGrad(const I_original_input:TF_TensorPtr; const I_batch_index:TF_TensorPtr; const I_grad:TF_TensorPtr; const I_id:TF_TensorPtr; const A_container:string; const A_shared_name:string; const D_original_input:boolean=false; const D_batch_index:boolean=false; const D_grad:boolean=false; const D_id:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_original_input);
  result:=ExecOper('UnbatchGrad',[I_original_input,I_batch_index,I_grad,I_id],['container','shared_name','T'],['string','string','type'],[@A_container,@A_shared_name,@F_T],[D_original_input,D_batch_index,D_grad,D_id])
  end;
function ExecUnicodeEncode(const I_input_values:TF_TensorPtr; const I_input_splits:TF_TensorPtr; const A_errors:string; const A_output_encoding:string; const A_replacement_char:integer; const D_input_values:boolean=false; const D_input_splits:boolean=false):TF_TensorPtr;
  var
    F_Tsplits:TF_DataType;
  begin
  F_Tsplits:=TF_TensorType(I_input_splits);
  result:=ExecOper('UnicodeEncode',[I_input_values,I_input_splits],['errors','output_encoding','replacement_char','Tsplits'],['string','string','int','type'],[@A_errors,@A_output_encoding,@A_replacement_char,@F_Tsplits],[D_input_values,D_input_splits])
  end;
function ExecUnicodeScript(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('UnicodeScript',[I_input],[],[],[],[D_input])
  end;
function ExecUnicodeTranscode(const I_input:TF_TensorPtr; const A_input_encoding:string; const A_output_encoding:string; const A_errors:string; const A_replacement_char:integer; const A_replace_control_characters:boolean; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('UnicodeTranscode',[I_input],['input_encoding','output_encoding','errors','replacement_char','replace_control_characters'],['string','string','string','int','bool'],[@A_input_encoding,@A_output_encoding,@A_errors,@A_replacement_char,@A_replace_control_characters],[D_input])
  end;
function ExecUniqueDataset(const I_input_dataset:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('UniqueDataset',[I_input_dataset],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset])
  end;
function ExecUnravelIndex(const I_indices:TF_TensorPtr; const I_dims:TF_TensorPtr; const D_indices:boolean=false; const D_dims:boolean=false):TF_TensorPtr;
  var
    F_Tidx:TF_DataType;
  begin
  F_Tidx:=TF_TensorType(I_indices);
  result:=ExecOper('UnravelIndex',[I_indices,I_dims],['Tidx'],['type'],[@F_Tidx],[D_indices,D_dims])
  end;
function ExecUnsortedSegmentJoin(const I_inputs:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const A_separator:string; const D_inputs:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_Tindices:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_Tindices:=TF_TensorType(I_segment_ids);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('UnsortedSegmentJoin',[I_inputs,I_segment_ids,I_num_segments],['separator','Tindices','Tnumsegments'],['string','type','type'],[@A_separator,@F_Tindices,@F_Tnumsegments],[D_inputs,D_segment_ids,D_num_segments])
  end;
function ExecUnsortedSegmentMax(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('UnsortedSegmentMax',[I_data,I_segment_ids,I_num_segments],['T','Tindices','Tnumsegments'],['type','type','type'],[@F_T,@F_Tindices,@F_Tnumsegments],[D_data,D_segment_ids,D_num_segments])
  end;
function ExecUnsortedSegmentMin(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('UnsortedSegmentMin',[I_data,I_segment_ids,I_num_segments],['T','Tindices','Tnumsegments'],['type','type','type'],[@F_T,@F_Tindices,@F_Tnumsegments],[D_data,D_segment_ids,D_num_segments])
  end;
function ExecUnsortedSegmentProd(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('UnsortedSegmentProd',[I_data,I_segment_ids,I_num_segments],['T','Tindices','Tnumsegments'],['type','type','type'],[@F_T,@F_Tindices,@F_Tnumsegments],[D_data,D_segment_ids,D_num_segments])
  end;
function ExecUnsortedSegmentSum(const I_data:TF_TensorPtr; const I_segment_ids:TF_TensorPtr; const I_num_segments:TF_TensorPtr; const D_data:boolean=false; const D_segment_ids:boolean=false; const D_num_segments:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
    F_Tindices:TF_DataType;
    F_Tnumsegments:TF_DataType;
  begin
  F_T:=TF_TensorType(I_data);
  F_Tindices:=TF_TensorType(I_segment_ids);
  F_Tnumsegments:=TF_TensorType(I_num_segments);
  result:=ExecOper('UnsortedSegmentSum',[I_data,I_segment_ids,I_num_segments],['T','Tindices','Tnumsegments'],['type','type','type'],[@F_T,@F_Tindices,@F_Tnumsegments],[D_data,D_segment_ids,D_num_segments])
  end;
function ExecUnwrapDatasetVariant(const I_input_handle:TF_TensorPtr; const D_input_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('UnwrapDatasetVariant',[I_input_handle],[],[],[],[D_input_handle])
  end;
function ExecUpperBound(const I_sorted_inputs:TF_TensorPtr; const I_values:TF_TensorPtr; const A_out_type:TF_DataType; const D_sorted_inputs:boolean=false; const D_values:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_sorted_inputs);
  result:=ExecOper('UpperBound',[I_sorted_inputs,I_values],['T','out_type'],['type','type'],[@F_T,@A_out_type],[D_sorted_inputs,D_values])
  end;
function ExecVarHandleOp(const A_container:string; const A_shared_name:string; const A_dtype:TF_DataType; const A_shape:TF_Shape):TF_TensorPtr;
  begin
  result:=ExecOper('VarHandleOp',[],['container','shared_name','dtype','shape'],['string','string','type','shape'],[@A_container,@A_shared_name,@A_dtype,@A_shape],[])
  end;
function ExecVarIsInitializedOp(const I_resource:TF_TensorPtr; const D_resource:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('VarIsInitializedOp',[I_resource],[],[],[],[D_resource])
  end;
function ExecVariable(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('Variable',[],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name],[])
  end;
function ExecVariableShape(const I_input:TF_TensorPtr; const A_out_type:TF_DataType; const D_input:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('VariableShape',[I_input],['out_type'],['type'],[@A_out_type],[D_input])
  end;
function ExecVariableV2(const A_shape:TF_Shape; const A_dtype:TF_DataType; const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('VariableV2',[],['shape','dtype','container','shared_name'],['shape','type','string','string'],[@A_shape,@A_dtype,@A_container,@A_shared_name],[])
  end;
function ExecWhere(const I_input:TF_TensorPtr; const D_input:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_input);
  result:=ExecOper('Where',[I_input],['T'],['type'],[@F_T],[D_input])
  end;
function ExecWholeFileReader(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('WholeFileReader',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecWholeFileReaderV2(const A_container:string; const A_shared_name:string):TF_TensorPtr;
  begin
  result:=ExecOper('WholeFileReaderV2',[],['container','shared_name'],['string','string'],[@A_container,@A_shared_name],[])
  end;
function ExecWindowDataset(const I_input_dataset:TF_TensorPtr; const I_size:TF_TensorPtr; const I_shift:TF_TensorPtr; const I_stride:TF_TensorPtr; const I_drop_remainder:TF_TensorPtr; const A_output_types:array of TF_DataType; const A_output_shapes:array of TF_Shape; const D_input_dataset:boolean=false; const D_size:boolean=false; const D_shift:boolean=false; const D_stride:boolean=false; const D_drop_remainder:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('WindowDataset',[I_input_dataset,I_size,I_shift,I_stride,I_drop_remainder],['output_types','output_shapes'],['list(type)','list(shape)'],[@A_output_types,@A_output_shapes],[D_input_dataset,D_size,D_shift,D_stride,D_drop_remainder])
  end;
function ExecWorkerHeartbeat(const I_request:TF_TensorPtr; const D_request:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('WorkerHeartbeat',[I_request],[],[],[],[D_request])
  end;
function ExecWrapDatasetVariant(const I_input_handle:TF_TensorPtr; const D_input_handle:boolean=false):TF_TensorPtr;
  begin
  result:=ExecOper('WrapDatasetVariant',[I_input_handle],[],[],[],[D_input_handle])
  end;
function ExecXdivy(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Xdivy',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecXlog1py(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Xlog1py',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecXlogy(const I_x:TF_TensorPtr; const I_y:TF_TensorPtr; const D_x:boolean=false; const D_y:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Xlogy',[I_x,I_y],['T'],['type'],[@F_T],[D_x,D_y])
  end;
function ExecZerosLike(const I_x:TF_TensorPtr; const D_x:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('ZerosLike',[I_x],['T'],['type'],[@F_T],[D_x])
  end;
function ExecZeta(const I_x:TF_TensorPtr; const I_q:TF_TensorPtr; const D_x:boolean=false; const D_q:boolean=false):TF_TensorPtr;
  var
    F_T:TF_DataType;
  begin
  F_T:=TF_TensorType(I_x);
  result:=ExecOper('Zeta',[I_x,I_q],['T'],['type'],[@F_T],[D_x,D_q])
  end;

end.

