program examples;

//**********************************************************************************************************************************
//
//  Pascal example to use TensorFlow through Graph and Eager methods, both Generic and operation Specific
//
//  Copyright: (C) 2020, Zsolt Szakaly
//
//  This source is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
//  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
//
//  This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
//  A copy of the GNU General Public License is available on the World Wide Web at <http://www.gnu.org/copyleft/gpl.html>. You can
//  also obtain it by writing to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1335, USA.
//
//  Change log:
//    13/02/2020 Initial version
//    15/02/2020 Example12 added to convert a BMP to JPG file (use input file "myinput.bmp")
//               Minor changes in line with the tf_operations changes
//    18/02/2020 New examples upto Example 16
//    21/02/2020 New examples upto Example 18
//               Correction of earlier examples in line with the changes in tf_operations and tf_wrapper
//
//**********************************************************************************************************************************
//
//  Description
//
//  There are different examples in this file for simple matrix operations.
//  Some used the TensorFlow "native" Graph based approach where first a Graph has to be built and then that Graph can be executed
//  through a Session. To add Nodes to the Graph there are two ways. Either use the TGraph.AddOper method, that can cater -
//  hopefully - for all possible Operation types, OR use the specific TGraphExt.Add<oper> methods that are somewhat easier. Need to
//  be noted though, that while for the Generic AddOper you can easily leave out Attributes with Default values, for the specific
//  Add<oper> methods you have to add all attributes, regardless if it has default or no. Later the WrapperMaker program, that
//  generates the tf_wrapper unit, can be improved to have different versions of Add<oper>, but it is not a priority.
//  Some other examples use the Eager approach, where operations are executed immediately. Here again, you have two options; either
//  use the Generic ExecOper method or the specific Exec<oper> methods. The ExecOper can be found in tf_operations in two versions,
//  one is a full version, while the second is somewhat simplified for those operations that have no InputList input and that has
//  only one Output. The Specific Exec<oper> methods can be found in tf_wrapper and are generated automatically by WrapperMaker. As
//  in the case of the Graph operations, here again, for the Generic ExecOper you can skip default values, while for the specific
//  Exec<oper> methods you have to give all parameters. This again can be improved later. Also some of the parameters of Exec<oper>
//  can be automatically calculated, e.g. "T" is typically the TensorType of the first input Tensor. These attributes are
//  automatically generated by the relevant Exec<oper> and so, you do not need to give it. Both ExecOper and Exec<oper> have
//  additional and optional parameters to delete the input Tensors once the execution is finished. This is a big help to simplify
//  your program (avoid memory leak). Finally it must be mentioned that Exec<oper> type methods are only generated for operations
//  with exactly ONE Output and NO InputList or OutputList parameters. If you want to use such an operation in Eager mode, you must
//  use the longer version of the Generic ExecOper function.
//
//**********************************************************************************************************************************

uses
  sysutils,
  tf_api,              // the basic interface to tensorflow, based on c_api.h
  tf_tensors,          // the unit to manipulate tensors (TF_TensorPtr)
  tf_operations,       // the unit to handle Graphs, Operations and Sessions in a TensorFlow style (use Oper names)
  tf_wrapper,          // the unit where all Operations are explicitely interfaced for Graph and/or Eager use
  tf_utils;            // some very basic printing routines


procedure Example1;
// In this example a simple matrix multiplication is done on two Int32 Tensors, using the Graph based General interface
  var
    t1:TF_TensorPtr;   // The two input tensors
    t2:TF_TensorPtr;
    g:TGraph;          // The TGraph object we will use
    s:TSession;        // The TSession object we use to run
    attr:TF_DataType;  // For the Generic AddOper all Attrubute Values are handed over as pointer and so a variable is needed
    tout:TF_TensorPtr; // The result of TSession.Run
  begin
  writeln('Starting Example 1');
  t1:=CreateTensorInt32([3,2],[1,2,3,4,5,6]);     // A 3x2 matrix, and the data is filled through a vector
  t2:=CreateTensorInt32([2,4],[1,2,3,4,5,6,7,8]); // A 2x4 matrix, filled the same way
  g.Init;                                         // Need to call Init before the first use
  attr:=TF_TensorType(t1);                        // Set the Attribute Value for Attribute "T"
  if g.AddOper('Placeholder',[],[],['tensor1'],['dtype'],['type'],[@attr])='' then // The Generic call to add and Input
    writeln('Error while adding tensor1');
  if g.AddInput('tensor2',TF_Int32)='' then      // The same as tensor1, but with a simplified function created to add Inputs
    writeln('Error while adding tensor2');
  if g.AddOper('MatMul',['tensor1','tensor2'],[],['tensorout'],['T'],['type'],[@attr])='' then // The Generic call
    writeln('Soemthing went wrong!');
  s.Init(g);                                      // Need to make a Session that runs the Graph
  tout:=s.run(['tensor1','tensor2'],[t1,t2],'tensorout'); // The actual run of the Session
  PrintTensorShape(tout,'tOut');           // A quick control that the product matrix is indeed 3x4, Int32
  PrintTensorData(tout);
  s.Done;                                         // Release the Session and in it the SessionPtr
  g.Done;                                         // Release the Graph and in it the GraphPtr, the StatusPtr and the Outputs
  TF_DeleteTensor(t1);                            // need to delete all the three tensors to avoid memory leak
  TF_DeleteTensor(t2);
  TF_DeleteTensor(tout);
  writeln('Finished Example 1');
  writeln;
  end;

procedure Example2;
// In this example a simple matrix multiplication is done on two Single Tensors, one of them is Transposed before multiplication
// It is done using the long version of the Eager type General interface (ExecOper)
  var
    t1:TF_TensorPtr;
    t2:TF_TensorPtr;
    attr1:TF_DataType; // For the Generic ExecOper all Attrubute Values are handed over as pointer as well
    attr2:boolean;
    tout:TF_TensorPtr; // The result of TSession.Run
  begin
  writeln('Starting Example 2');
  t1:=CreateTensorSingle([2,3],[1.0,2.0,3.0,4.0,5.0,6.0]);     // A 2x3 matrix, need to transpose before MatMul
  t2:=CreateTensorSingle([2,4],[1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8]); // A 2x4 matrix,no need to transpose
  attr1:=TF_TensorType(t1);
  attr2:=true;
  tout:=ExecOper('MatMul',[t1,t2],['T','transpose_a'],['type','bool'],[@attr1,@attr2],[false,false]);
  PrintTensorShape(tout,'TOut');                 // A quick control that the product matrix is indeed 3x4, Int32
  PrintTensorData(tout);
  TF_DeleteTensor(t1);                            // need to delete all the three tensors to avoid memory leak
  TF_DeleteTensor(t2);
  TF_DeleteTensor(tout);
  writeln('Finished Example 2');
  writeln;
  end;

procedure Example3;
// In this example two identical size matrices are multiplied element-wise. It uses the short version of the Eager type General
// interface (ExecOper)
  var
    t1:TF_TensorPtr;
    t2:TF_TensorPtr;
    attr:TF_DataType;
    tout:TF_TensorPtr;
  begin
  writeln('Starting Example 3');
  t1:=CreateTensorSingle([2,3],[1.0,2.0,3.0,4.0,5.0,6.0]);     // A 2x3 matrix
  t2:=CreateTensorSingle([2,3],[1.1,2.2,3.3,4.4,5.5,6.6]);     // Must be the same Shape
  attr:=TF_TensorType(t1);
  tout:=ExecOper('Mul',[t1,t2],['T'],['type'],[@attr],[true,true]);
  PrintTensorShape(tout,'TOut');
  PrintTensorData(tout);
  TF_DeleteTensor(tout); // only tout has to be deleted, t1 and t2 were delete in the ExecOper
  writeln('Finished Example 3');
  writeln;
  end;

procedure Example4;
// In this example two identical size matrices are added element-wise. It uses the Graph based specific interface (ExecAdd)
  var
    t1:TF_TensorPtr;
    t2:TF_TensorPtr;
    g:TGraphExt;       // The TGraphExt object that includes the detailed calls
    s:TSession;        // The TSession object we use to run
    touts:TF_TensorPtrs; // The result of TSession.Run in this case is an array as the output is given as an array as well
  begin
  writeln('Starting Example 4');
  t1:=CreateTensorSingle([2,3],[1.0,2.0,3.0,4.0,5.0,6.0]);     // A 2x3 matrix
  t2:=CreateTensorSingle([2,3],[1.1,2.2,3.3,4.4,5.5,6.6]);     // Must be the same Shape
  g.Init;                                         // Need to call Init before the first use
  g.AddInput('tensor1',TF_FLOAT);                 // not checking the result this time
  g.AddInput('tensor2',TF_FLOAT);
  g.AddAdd('tensor1','tensor2','tensorout',TF_FLOAT);
  s.Init(g);                                      // Need to make a Session that runs the Graph
  touts:=s.run(['tensor1','tensor2'],[t1,t2],['tensorout']); // The actual run of the Session
  PrintTensorShape(touts[0],'TOut[0]');           // A quick control that the product matrix is indeed 3x4, Int32
  PrintTensorData(touts[0]);
  s.Done;                                         // Release the Session and in it the SessionPtr
  g.Done;                                         // Release the Graph and in it the GraphPtr, the StatusPtr and the Outputs
  TF_DeleteTensor(t1);                            // need to delete all the three tensors to avoid memory leak
  TF_DeleteTensor(t2);
  TF_DeleteTensor(touts[0]);
  SetLength(touts,0);
  writeln('Finished Example 4');
  writeln;
  end;

procedure Example5;
// In this example the absolute value of one matrix is calculated (element-wise). It uses the Eager Specific interface (ExecAbs)
  var
    t:TF_TensorPtr;
    tout:TF_TensorPtr;
  begin
  writeln('Starting Example 5');
  t:=CreateTensorSingle([2,3],[-1.0,2.0,-3.0,4.0,-5.0,6.0]);
  tout:=ExecAbs(t);
  PrintTensorShape(tout);
  PrintTensorData(tout);
  TF_DeleteTensor(t);    // need to delete manually, because ExecAbs was called without adding ",true" to the end of the call
  TF_DeleteTensor(tout); // otherwise only tout should be deleted
  writeln('Finished Example 5');
  writeln;
  end;

procedure Example6;
// In this example a three step flow is implemented. In the first step one matrix (actually a vector) is substracted from another
// (same shape) matrix (element-wise).
// In the second step the square of the difference matrix is calculated (again element-wise).
// Finally in the third step the sum of the squares is calculated.
// This is basically a chi-square like approach (with no weighting).
  var
    t1,t2:TF_TensorPtr;
    g:TGraph;          // The TGraph object we will use
    s:TSession;        // The TSession object we use to run
    attr:TF_DataType;  // For the Generic AddOper all Attrubute Values are handed over as pointer and so a variable is needed
    tout:TF_TensorPtr;
  begin
  writeln('Starting Example 6');
  t1:=CreateTensorSingle([5],[-1.0,2.0,-3.0,4.0,-5.0]);
  t2:=CreateTensorSingle([5],[1.0,-2.0,3.0,-4.0,5.0]);
  attr:=TF_TensorType(t1);                        // Set the Attribute Value for Attribute "T"
  g.Init;
  g.AddInput('tensor1',TF_FLOAT);                 // Using the simple input adding method
  g.AddInput('tensor2',TF_FLOAT);
  g.AddOper('Sub',['tensor1','tensor2'],[],['difference'],['T'],['type'],[@attr]); // The first step
  g.AddOper('Square',['difference'],[],['squareofdifference'],['T'],['type'],[@attr]); // The second step
  g.AddConstant('zerodimension',Int32(0));               // need to add a constant tensor that is used to indicate which dimension to Sum
  g.AddOper('Sum',['squareofdifference','zerodimension'],[],['finalresult'],['T'],['type'],[@attr]); // The third step
  s.Init(g);                                      // Need to make a Session that runs the Graph
  tout:=s.run(['tensor1','tensor2'],[t1,t2],'finalresult'); // The actual run of the Session
  PrintTensorShape(tout,'TOut');                  // A quick control that the product matrix is indeed scalar
  PrintTensorData(tout);                          // Print the value (must be 220 = 2^2 + 4^2 + 6^2 + 8^2 + 10^2)
  s.Done;                                         // Release the Session and in it the SessionPtr
  g.Done;                                         // Release the Graph and in it the GraphPtr, the StatusPtr and the Outputs
  TF_DeleteTensor(t1);                            // need to delete all the three tensors to avoid memory leak
  TF_DeleteTensor(t2);
  TF_DeleteTensor(tout);
  writeln('Finished Example 6');
  writeln;
  end;

procedure Example7;
// This example is the same as Example 6, but uses the Specific Graph methods from the tf_wrapper family
  var
    t1,t2:TF_TensorPtr;
    g:TGraphExt;
    s:TSession;
    tout:TF_TensorPtr;
  begin
  writeln('Starting Example 7');
  t1:=CreateTensorSingle([5],[-1.0,2.0,-3.0,4.0,-5.0]);
  t2:=CreateTensorSingle([5],[1.0,-2.0,3.0,-4.0,5.0]);
  g.Init;
  g.AddInput('tensor1',TF_FLOAT);
  g.AddInput('tensor2',TF_FLOAT);
  g.AddSub('tensor1','tensor2','difference',TF_FLOAT); // This is the Specific AddOper version for Sub - AddSub
  g.AddSquare('difference','squareofdifference',TF_FLOAT);
  g.AddConstant('zerodimension',Int32(0));
  g.AddSum('squareofdifference','zerodimension','finalresult',false,TF_FLOAT,TF_INT32);
  s.Init(g);
  tout:=s.run(['tensor1','tensor2'],[t1,t2],'finalresult');
  PrintTensorShape(tout,'TOut');
  PrintTensorData(tout);
  s.Done;
  g.Done;
  TF_DeleteTensor(t1);
  TF_DeleteTensor(t2);
  TF_DeleteTensor(tout);
  writeln('Finished Example 7');
  writeln;
  end;

procedure Example8;
// Still the same as 6 and 7, but using the Generic Eager method
  var
    t1,t2:TF_TensorPtr;
    attr:TF_DataType;
  begin
  writeln('Starting Example 8');
  t1:=CreateTensorSingle([5],[-1.0,2.0,-3.0,4.0,-5.0]);
  t2:=CreateTensorSingle([5],[1.0,-2.0,3.0,-4.0,5.0]);
  attr:=TF_TensorType(t1);
  t1:=ExecOper('Sub',[t1,t2],['T'],['type'],[@attr],[true,true]);
  t1:=ExecOper('Square',t1,['T'],['type'],[@attr],[true]);
  t2:=CreateTensorInt32(0);
  t1:=ExecOper('Sum',[t1,t2],['T'],['type'],[@attr],[true,true]);
  PrintTensorShape(t1,'T1');
  PrintTensorData(t1);
  TF_DeleteTensor(t1);
  writeln('Finished Example 8');
  writeln;
  end;

procedure Example9;
// Still the same as 6, 7 and 8, but using the Specific Eager methods
  var
    t:TF_TensorPtr;
  begin
  writeln('Starting Example 9');
  t:=CreateTensorSingle([5],[-1.0,2.0,-3.0,4.0,-5.0]);
  t:=ExecSub(t,CreateTensorSingle([5],[1.0,-2.0,3.0,-4.0,5.0]),true,true); // Showing that CreateTensor can be used in-line
  t:=ExecSquare(t,true);
  t:=ExecSum(t,CreateTensorInt32(0),false,true,true);
  PrintTensorShape(t,'T');
  PrintTensorData(t);
  TF_DeleteTensor(t);
  writeln('Finished Example 9');
  writeln;
  end;

procedure Example10;
// Still the same as 6, 7, 8 and 9, but showing how (theoretically) operations can be linked
// It is strictly an EXAMPLE, not a recommendation, how to use it.
  var
    t:TF_TensorPtr;
  begin
  writeln('Starting Example 10');
  t:=ExecSum(ExecSquare(
                 ExecSub(
                     CreateTensorSingle([5],[-1.0,2.0,-3.0,4.0,-5.0]),
                     CreateTensorSingle([5],[1.0,-2.0,3.0,-4.0,5.0]),
                     true,
                     true),
                 true),
             CreateTensorInt32(0),
             false,
             true,
             true);
  PrintTensorShape(t,'T');
  PrintTensorData(t);
  TF_DeleteTensor(t);
  writeln('Finished Example 10');
  writeln;
  end;

procedure Example11;
// Still the same (especially Example9), but using a specific function for SquaredDifference
  var
    t:TF_TensorPtr;
  begin
  writeln('Starting Example 11');
  t:=CreateTensorSingle([5],[-1.0,2.0,-3.0,4.0,-5.0]);
  t:=ExecSquaredDifference(t,CreateTensorSingle([5],[1.0,-2.0,3.0,-4.0,5.0]),true,true); // difference and square in one step
  t:=ExecSum(t,CreateTensorInt32(0),false,true,true);
  PrintTensorShape(t,'T');
  PrintTensorData(t);
  TF_DeleteTensor(t);
  writeln('Finished Example 11');
  writeln;
  end;

procedure Example12;
// A simple example, how to generate e.g. a Tensor, filled with random numbers in a range
  var
    t:TF_TensorPtr;
  begin
  writeln('Starting Example 12');
  t:=CreateTensorSingleRandom([3,4,5],-10,10);
  PrintTensorShape(t,'T'); // its Shape is 3 dimensional, so the printout is sequential
  PrintTensorData(t);
  TF_DeleteTensor(t);
  writeln('Finished Example 12');
  writeln;
  end;

procedure Example13;
// This example converts a BMP image into a JPEG image while its contrast is also adjusted
  var
    g:TGraphExt;
    s:TSession;
    t:TF_TensorPtr;
    LastOperationName:string;
  begin
  writeln('Starting Example 13');
  g.Init;
  g.AddInput('input-bmp',TF_String); // The input bmp file name will be given as an input parameter
  g.AddConstant('jpeg-resolution',Int32(80));
  g.AddReadFile('input-bmp','bmp-content');
  g.AddDecodeBmp('bmp-content','decoded-image',3);
  g.AddCast('decoded-image','extended-image',TF_UINT8,TF_FLOAT,false);
  g.AddConstant('contrast-factor',1.0); // no change
  g.AddAdjustContrastV2('extended-image','contrast-factor','contrasted-image',TF_FLOAT);
  g.AddCast('contrasted-image','backsized-image',TF_FLOAT,TF_UINT8,false);
  g.AddEncodeJpegVariableQuality('backsized-image','jpeg-resolution','jpeg-content');
  g.AddConstant('output-jpg','myoutput.jpg'); // The output jpg name will be given as a constant (just to illustrate the difference)
  LastOperationName:=g.AddWriteFile('output-jpg','jpeg-content');
  s.Init(g);
  t:=createtensorstring('myinput.bmp'); // Since the input bmp is an input parameter, we have to create it
  s.run([LastOperationName],['input-bmp'],[t]); // The actual run of the Session, making sure that the last operation runs
  TF_DeleteTensor(t); // In Graph operation, there is no automatic tensor deletion, so it has to be done manually
  s.Done;
  g.Done;
  writeln('Finished Example 13');
  writeln;
  end;

procedure Example14;
// In this example a batch matrix multiplication is done on one batch and one fixed Single Tensor
  var
    t1:TF_TensorPtr;
    t2:TF_TensorPtr;
    attr:TF_DataType;
    tout:TF_TensorPtr;
  begin
  writeln('Starting Example 14');
  t1:=CreateTensorSingle([3,1,2],[1.0,2.0,3.0,4.0,5.0,6.0]);     // A 3 pieces of 1x2 matrix (3 long batch)
  t2:=CreateTensorSingle([2,4],[1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8]); // A 2x4 matrix to use for all
  attr:=TF_TensorType(t1);
  tout:=ExecOper('BatchMatMulV2',[t1,t2],['T'],['type'],[@attr],[false,true]); // V2 supports batch vs. non-batch
  PrintTensorData(tout);
  TF_DeleteTensor(t1); // Only t1 since t2 is deleted in ExecOper
  TF_DeleteTensor(tout);
  writeln('Finished Example 14');
  writeln;
  end;

procedure Example15;
  var
    g:TGraphExt;
    s:TSession;
    t:TF_TensorPtr;
    SaveOperationName:string;
    attr:TF_TypeList;
    DataList:TF_StringList;
  begin
  // This example shows how to save one Tensors.
  writeln('Starting Example 15');
  g.Init;
  t:=CreateTensorString([1],['fancynamesingle']); // This is a stringlist in one Tensor, with the name(s) to be used for the saved tensors
  g.AddTensor('whatnametouse',t,true);                         // This is used as a constant inside the Graph
  g.AddConstant('whatfilename','test.tft');                    // The file name (another Constant)
  g.AddConstant('emptystring','');                             // No encryption (another Constant)
  g.AddInput('thisistosave',TF_FLOAT);                         // It will be the one to save
  SetLength(attr,1);                                           // Before FPC 3.2 Dynamic Arrays cannot be called with values
  attr[0]:=TF_FLOAT;                                           // The first Attribute is the first (and now only) Tensor's type
  SetLength(DataList,1);
  DataList[0]:='thisistosave';
  SaveOperationName:=g.AddSave('whatfilename','whatnametouse',DataList,attr);

  t:=CreateTensorSingle([3,1,2],[1.0,2.0,3.0,4.0,5.0,6.0]); // This will be saved as one
  s.init(g);
  s.run([SaveOperationName],['thisistosave'],[t]);
  s.Done;
  g.Done;
  writeln('Finished Example 15');
  writeln;
  end;

procedure Example16;
  var
    g:TGraphExt;
    s:TSession;
    t:TF_TensorPtr;
    tout:TF_TensorPtr;
  begin
  // And how to read it back
  writeln('Starting Example 16');
  g.Init;
  g.AddConstant('whatfilepattern','test.tft'); // The file pattern, in this case a direct name
  t:=CreateTensorString('fancynamesingle'); // This is a string with the name of the tensor to restore
  g.AddTensor('whattorestore',t,true);
  g.AddRestore('whatfilepattern','whattorestore','readtensor',TF_FLOAT,-1);
  s.init(g);
  tout:=s.run([],[],'readtensor');
  PrintTensorShape(tout);
  PrintTensorData(tout);
  TF_DeleteTensor(tout);
  s.Done;
  g.Done;
  writeln('Finished Example 16');
  writeln;
  end;

procedure Example17;
  var
    g:TGraphExt;
    s:TSession;
    t:TF_TensorPtr;
    touts:TF_TensorPtrs; // showing again the s.run with multiple outputs, even if that "multiple" is just one
  begin
  // This is to test the Frac(x) functionality on two different ways
  writeln('Starting Example 17');
  t:=CreateTensorSingleRandom([30000,10000],0,1000);
  g.Init;
  g.AddInput('x',TF_FLOAT);
  g.AddConstant('1',1.0);
  g.AddMod('x','1','xmod1',TF_FLOAT);
  s.init(g);
  Writeln('Before x mod 1 ',DateTimeToStr(Now));
  touts:=s.run(['x'],[t],['xmod1']);
  Writeln('After x mod 1 ',DateTimeToStr(Now));
  PrintTensorShape(touts[0]);
  TF_DeleteTensor(touts[0]);
  SetLength(touts,0);
  s.Done;
  g.Done;

  g.Init;
  g.AddInput('x',TF_FLOAT);
  g.AddFloor('x','xfloor',TF_FLOAT);
  g.AddSub('x','xfloor','xminusxfloor',TF_FLOAT);
  s.init(g);
  Writeln('Before x - xfloor ',DateTimeToStr(Now));
  touts:=s.run(['x'],[t],['xminusxfloor']);
  Writeln('After x - x floor ',DateTimeToStr(Now));
  PrintTensorShape(touts[0]);
  TF_DeleteTensor(touts[0]);
  SetLength(touts,0);
  s.Done;
  g.Done;

  TF_DeleteTensor(t);

  writeln('Finished Example 17');
  writeln;
  end;

procedure Example18;
  var
    g:TGraphExt;
    s:TSession;
    t,t1,t2:TF_TensorPtr;
    SaveOperationName:string;
    attr:TF_TypeList;
    DataList:TF_StringList;
  begin
  // This example shows how to save multiple Tensors in one save.
  writeln('Starting Example 18');
  g.Init;
  t:=CreateTensorString([2],['fancynamesingle','fancynameint']); // This is a stringlist in one Tensor, with the name(s) to be used for the saved tensors
  g.AddTensor('whatnametouse',t,true);                         // This is used as a constant inside the Graph
  g.AddConstant('whatfilename','test2.tft');                    // The file name (another Constant)
  g.AddConstant('emptystring','');                             // No encryption (another Constant)
  g.AddInput('thisistosave1',TF_FLOAT);                        // It will be the first to save
  g.AddInput('thisistosave2',TF_INT32);                        // It will be the second to save
  SetLength(attr,2);                                           // Before FPC 3.2 Dynamic Arrays cannot be called with values
  attr[0]:=TF_FLOAT;                                           // The first Attribute is the first Tensor's type
  attr[1]:=TF_INT32;                                           // The first Attribute is the second Tensor's type
  SetLength(DataList,2);
  DataList[0]:='thisistosave1';
  DataList[1]:='thisistosave2';
  SaveOperationName:=g.AddSave('whatfilename','whatnametouse',DataList,attr);

  t1:=CreateTensorSingle([3,1,2],[1.0,2.0,3.0,4.0,5.0,6.0]); // This will be saved as first
  t2:=CreateTensorInt32([8],[1,2,3,4,5,6,7,8]);              // This will be saved as second
  s.init(g);

  s.run([SaveOperationName],['thisistosave1','thisistosave2'],[t1,t2]);
  TF_DeleteTensor(t1);
  TF_DeleteTensor(t2);
  s.Done;
  g.Done;
  writeln('Finished Example 18');
  writeln;
  end;

begin
Example1;
Example2;
Example3;
Example4;
Example5;
Example6;
Example7;
Example8;
Example9;
Example10;
Example11;
Example12;
Example13;
Example14;
Example15;
Example16;
Example17;
Example18;
end.

